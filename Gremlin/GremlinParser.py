# Generated from Gremlin.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u0110")
        buf.write("\u099a\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\4p\tp\4")
        buf.write("q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4")
        buf.write("z\tz\4{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080")
        buf.write("\4\u0081\t\u0081\4\u0082\t\u0082\4\u0083\t\u0083\4\u0084")
        buf.write("\t\u0084\4\u0085\t\u0085\4\u0086\t\u0086\4\u0087\t\u0087")
        buf.write("\4\u0088\t\u0088\4\u0089\t\u0089\4\u008a\t\u008a\4\u008b")
        buf.write("\t\u008b\4\u008c\t\u008c\4\u008d\t\u008d\4\u008e\t\u008e")
        buf.write("\4\u008f\t\u008f\4\u0090\t\u0090\4\u0091\t\u0091\4\u0092")
        buf.write("\t\u0092\4\u0093\t\u0093\4\u0094\t\u0094\4\u0095\t\u0095")
        buf.write("\4\u0096\t\u0096\4\u0097\t\u0097\4\u0098\t\u0098\4\u0099")
        buf.write("\t\u0099\4\u009a\t\u009a\4\u009b\t\u009b\4\u009c\t\u009c")
        buf.write("\4\u009d\t\u009d\4\u009e\t\u009e\4\u009f\t\u009f\4\u00a0")
        buf.write("\t\u00a0\4\u00a1\t\u00a1\4\u00a2\t\u00a2\4\u00a3\t\u00a3")
        buf.write("\4\u00a4\t\u00a4\4\u00a5\t\u00a5\4\u00a6\t\u00a6\4\u00a7")
        buf.write("\t\u00a7\4\u00a8\t\u00a8\4\u00a9\t\u00a9\4\u00aa\t\u00aa")
        buf.write("\4\u00ab\t\u00ab\4\u00ac\t\u00ac\4\u00ad\t\u00ad\4\u00ae")
        buf.write("\t\u00ae\4\u00af\t\u00af\4\u00b0\t\u00b0\4\u00b1\t\u00b1")
        buf.write("\4\u00b2\t\u00b2\4\u00b3\t\u00b3\4\u00b4\t\u00b4\4\u00b5")
        buf.write("\t\u00b5\4\u00b6\t\u00b6\4\u00b7\t\u00b7\4\u00b8\t\u00b8")
        buf.write("\4\u00b9\t\u00b9\4\u00ba\t\u00ba\4\u00bb\t\u00bb\4\u00bc")
        buf.write("\t\u00bc\4\u00bd\t\u00bd\4\u00be\t\u00be\4\u00bf\t\u00bf")
        buf.write("\4\u00c0\t\u00c0\4\u00c1\t\u00c1\4\u00c2\t\u00c2\4\u00c3")
        buf.write("\t\u00c3\4\u00c4\t\u00c4\4\u00c5\t\u00c5\4\u00c6\t\u00c6")
        buf.write("\4\u00c7\t\u00c7\4\u00c8\t\u00c8\4\u00c9\t\u00c9\4\u00ca")
        buf.write("\t\u00ca\4\u00cb\t\u00cb\4\u00cc\t\u00cc\4\u00cd\t\u00cd")
        buf.write("\4\u00ce\t\u00ce\4\u00cf\t\u00cf\4\u00d0\t\u00d0\4\u00d1")
        buf.write("\t\u00d1\4\u00d2\t\u00d2\4\u00d3\t\u00d3\4\u00d4\t\u00d4")
        buf.write("\4\u00d5\t\u00d5\4\u00d6\t\u00d6\4\u00d7\t\u00d7\4\u00d8")
        buf.write("\t\u00d8\4\u00d9\t\u00d9\4\u00da\t\u00da\4\u00db\t\u00db")
        buf.write("\4\u00dc\t\u00dc\4\u00dd\t\u00dd\4\u00de\t\u00de\4\u00df")
        buf.write("\t\u00df\3\2\3\2\5\2\u01c1\n\2\3\2\7\2\u01c4\n\2\f\2\16")
        buf.write("\2\u01c7\13\2\3\2\5\2\u01ca\n\2\3\2\3\2\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3\u01da\n\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\7\3\u01e1\n\3\f\3\16\3\u01e4\13\3\3\4\3")
        buf.write("\4\3\5\3\5\3\5\3\5\3\5\5\5\u01ed\n\5\3\5\3\5\3\5\7\5\u01f2")
        buf.write("\n\5\f\5\16\5\u01f5\13\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\5\6\u0208\n\6\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\5\7\u021a\n\7\3\b\3\b\3\b\3\b\3\b\3\b\5\b\u0222")
        buf.write("\n\b\3\t\3\t\3\t\3\t\3\t\3\n\3\n\3\n\3\n\3\13\3\13\3\13")
        buf.write("\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\5\13\u0239")
        buf.write("\n\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3\r")
        buf.write("\5\r\u0247\n\r\3\r\3\r\3\16\3\16\3\16\3\16\3\16\3\16\3")
        buf.write("\16\3\16\3\16\3\16\3\16\3\16\5\16\u0257\n\16\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\17\5\17\u025f\n\17\3\20\3\20\3\20\3")
        buf.write("\20\3\20\3\20\3\20\3\20\3\20\3\20\5\20\u026b\n\20\3\21")
        buf.write("\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21")
        buf.write("\3\21\3\21\3\21\3\21\3\21\3\21\5\21\u027f\n\21\3\22\3")
        buf.write("\22\3\22\3\22\3\22\3\23\3\23\3\23\3\23\3\23\3\24\3\24")
        buf.write("\3\24\3\24\3\24\3\25\3\25\3\25\3\25\3\25\3\26\3\26\3\26")
        buf.write("\3\26\3\26\3\26\3\26\3\26\3\26\7\26\u029e\n\26\f\26\16")
        buf.write("\26\u02a1\13\26\3\27\3\27\3\27\3\27\3\27\3\27\7\27\u02a9")
        buf.write("\n\27\f\27\16\27\u02ac\13\27\3\30\3\30\3\30\3\30\3\30")
        buf.write("\5\30\u02b3\n\30\3\31\3\31\3\31\3\31\3\32\3\32\3\32\3")
        buf.write("\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\5\32")
        buf.write("\u031e\n\32\3\33\3\33\3\33\3\33\3\33\3\34\3\34\3\34\3")
        buf.write("\34\3\34\3\34\3\34\3\34\3\34\3\34\5\34\u032f\n\34\3\35")
        buf.write("\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35")
        buf.write("\3\35\3\35\3\35\3\35\3\35\3\35\5\35\u0343\n\35\3\36\3")
        buf.write("\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36")
        buf.write("\5\36\u0351\n\36\3\37\3\37\3\37\3\37\3\37\3 \3 \3 \3 ")
        buf.write("\3 \5 \u035d\n \3 \3 \3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3")
        buf.write("!\3!\3!\5!\u036e\n!\3\"\3\"\3\"\3\"\3\"\3#\3#\3#\3#\3")
        buf.write("#\3$\3$\3$\3$\3%\3%\3%\3%\3%\3&\3&\3&\3&\3&\3&\3&\3&\3")
        buf.write("&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3")
        buf.write("&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3")
        buf.write("&\3&\3&\3&\3&\3&\3&\3&\3&\3&\5&\u03b9\n&\3\'\3\'\3\'\3")
        buf.write("\'\3\'\5\'\u03c0\n\'\3\'\3\'\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\5(\u03ee")
        buf.write("\n(\3)\3)\3)\3)\3)\3*\3*\3*\3*\3*\3+\3+\3+\3+\3,\3,\3")
        buf.write(",\3,\3,\3-\3-\3-\3-\3-\3-\3-\3-\5-\u040b\n-\3.\3.\3.\3")
        buf.write(".\3/\3/\3/\3/\3/\5/\u0416\n/\3/\3/\3/\3/\3/\3/\3/\5/\u041f")
        buf.write("\n/\3\60\3\60\3\60\3\60\3\61\3\61\3\61\3\61\3\61\3\62")
        buf.write("\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62")
        buf.write("\3\62\5\62\u0437\n\62\3\63\3\63\3\63\3\63\3\63\3\63\3")
        buf.write("\63\3\63\3\63\3\63\5\63\u0443\n\63\3\64\3\64\3\64\3\64")
        buf.write("\3\64\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65")
        buf.write("\5\65\u0454\n\65\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3")
        buf.write("\66\3\66\3\66\5\66\u0460\n\66\3\67\3\67\3\67\3\67\3\67")
        buf.write("\3\67\3\67\3\67\5\67\u046a\n\67\38\38\38\38\38\38\38\3")
        buf.write("8\58\u0474\n8\39\39\39\39\39\39\39\39\39\39\39\39\39\3")
        buf.write("9\39\39\39\39\39\39\39\39\39\39\39\39\39\39\39\39\39\3")
        buf.write("9\39\39\39\39\39\39\39\39\39\39\39\39\39\39\39\39\39\3")
        buf.write("9\39\39\39\39\39\39\39\39\39\39\39\39\39\39\39\59\u04b7")
        buf.write("\n9\3:\3:\3:\3:\3:\5:\u04be\n:\3:\3:\3:\3:\3:\3:\3:\5")
        buf.write(":\u04c7\n:\3;\3;\3;\3;\3;\3;\3;\3;\3;\3;\5;\u04d3\n;\3")
        buf.write(";\3;\5;\u04d7\n;\3<\3<\3<\3<\3<\3<\3<\3<\3<\3<\5<\u04e3")
        buf.write("\n<\3<\3<\5<\u04e7\n<\3=\3=\3=\3=\3=\3>\3>\3>\3>\3>\5")
        buf.write(">\u04f3\n>\3>\3>\3>\3>\3>\3>\3>\5>\u04fc\n>\3?\3?\3?\3")
        buf.write("?\3@\3@\3@\3@\3A\3A\3A\3A\3A\3B\3B\3B\3B\3B\3C\3C\3C\3")
        buf.write("C\3D\3D\3D\3D\3E\3E\3E\3E\3E\3F\3F\3F\3F\3F\3F\3F\3F\3")
        buf.write("F\3F\5F\u0527\nF\3G\3G\3G\3G\3H\3H\3H\3H\3I\3I\3I\3I\3")
        buf.write("I\3I\3I\3I\3I\3I\3I\3I\5I\u053d\nI\3J\3J\3J\3J\3J\3K\3")
        buf.write("K\3K\3K\3K\3K\3K\3K\5K\u054c\nK\3L\3L\3L\3L\3L\3M\3M\3")
        buf.write("M\3M\3M\3N\3N\3N\3N\3N\3O\3O\3O\3O\3O\3O\3O\3O\5O\u0565")
        buf.write("\nO\3P\3P\3P\3P\3P\3P\3P\3P\5P\u056f\nP\3Q\3Q\3Q\3Q\3")
        buf.write("Q\3Q\3Q\3Q\5Q\u0579\nQ\3R\3R\3R\3R\3R\3S\3S\3S\3S\3S\3")
        buf.write("S\3S\3S\3S\3S\3S\3S\3S\3S\3S\3S\3S\3S\3S\5S\u0593\nS\3")
        buf.write("T\3T\3T\3T\3T\3U\3U\3U\3U\3U\3V\3V\3V\3V\3V\3V\3V\3V\5")
        buf.write("V\u05a7\nV\3W\3W\3W\3W\3X\3X\3X\3X\3X\3Y\3Y\3Y\3Y\3Y\3")
        buf.write("Z\3Z\3Z\3Z\3[\3[\3[\3[\3[\3[\3[\3[\5[\u05c3\n[\3\\\3\\")
        buf.write("\3\\\3\\\3]\3]\3]\3]\3^\3^\3^\3^\3^\3^\3^\3^\5^\u05d5")
        buf.write("\n^\3_\3_\3_\3_\3_\5_\u05dc\n_\3_\3_\3`\3`\3`\3`\3`\3")
        buf.write("a\3a\3a\3a\3a\3a\3a\3a\3a\5a\u05ee\na\3a\3a\3a\3a\3a\3")
        buf.write("a\3a\3a\3a\5a\u05f9\na\3a\3a\5a\u05fd\na\3b\3b\3b\3b\3")
        buf.write("b\3c\3c\3c\3c\3c\3c\3c\3c\3c\3c\3c\3c\3c\3c\3c\3c\5c\u0614")
        buf.write("\nc\3d\3d\3d\3d\3e\3e\3e\3e\3e\3e\3e\3e\3e\3e\3e\3e\5")
        buf.write("e\u0626\ne\3f\3f\3f\3f\3f\3f\3f\3f\5f\u0630\nf\3g\3g\3")
        buf.write("g\3g\3g\3g\3g\3g\3g\3g\3g\3g\5g\u063e\ng\3h\3h\3h\3h\3")
        buf.write("h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\5h\u0655")
        buf.write("\nh\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3h\3")
        buf.write("h\3h\3h\3h\3h\5h\u066c\nh\3h\3h\3h\3h\3h\3h\3h\5h\u0675")
        buf.write("\nh\3i\3i\3i\3i\3j\3j\3j\3j\3j\3k\3k\3k\3k\3l\3l\3l\3")
        buf.write("l\3l\3l\3l\3l\3l\3l\3l\3l\5l\u0690\nl\3m\3m\3m\3m\3m\3")
        buf.write("n\3n\3n\3n\3n\3o\3o\3o\3o\3o\3o\3o\3o\5o\u06a4\no\3p\3")
        buf.write("p\3p\3p\3p\3p\3p\3p\3p\3p\3p\3p\3p\3p\3p\3p\3p\3p\3p\3")
        buf.write("p\5p\u06ba\np\3q\3q\3q\3q\3q\3r\3r\3r\3r\3r\3s\3s\3s\3")
        buf.write("s\3s\5s\u06cb\ns\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\5")
        buf.write("s\u06d9\ns\3t\3t\3t\3t\3t\5t\u06e0\nt\3t\3t\3u\3u\3u\3")
        buf.write("u\3u\3v\3v\3v\3v\3v\3v\3v\3v\5v\u06f1\nv\3w\3w\3w\3w\3")
        buf.write("x\3x\3x\3x\3x\3y\3y\3y\3y\3y\3y\3y\3y\3y\3y\5y\u0706\n")
        buf.write("y\3z\3z\3z\3z\3{\3{\3{\3{\3{\3{\3{\3{\3{\3{\5{\u0716\n")
        buf.write("{\3{\3{\5{\u071a\n{\3|\3|\3|\3|\3|\3}\3}\3}\3}\3}\3}\3")
        buf.write("}\3}\3}\3}\3}\3}\3}\3}\3}\3}\3}\5}\u0732\n}\3~\3~\3~\3")
        buf.write("~\3~\3~\3~\3~\3~\3~\3~\3~\5~\u0740\n~\3\177\3\177\3\177")
        buf.write("\3\177\3\u0080\3\u0080\3\u0080\3\u0080\5\u0080\u074a\n")
        buf.write("\u0080\3\u0080\3\u0080\7\u0080\u074e\n\u0080\f\u0080\16")
        buf.write("\u0080\u0751\13\u0080\3\u0080\3\u0080\3\u0080\3\u0080")
        buf.write("\3\u0080\3\u0080\3\u0080\3\u0080\3\u0080\3\u0080\3\u0080")
        buf.write("\5\u0080\u075e\n\u0080\3\u0080\3\u0080\7\u0080\u0762\n")
        buf.write("\u0080\f\u0080\16\u0080\u0765\13\u0080\3\u0080\3\u0080")
        buf.write("\3\u0080\3\u0080\3\u0080\5\u0080\u076c\n\u0080\3\u0080")
        buf.write("\3\u0080\7\u0080\u0770\n\u0080\f\u0080\16\u0080\u0773")
        buf.write("\13\u0080\3\u0080\3\u0080\3\u0080\3\u0080\3\u0080\3\u0080")
        buf.write("\5\u0080\u077b\n\u0080\3\u0080\3\u0080\7\u0080\u077f\n")
        buf.write("\u0080\f\u0080\16\u0080\u0782\13\u0080\3\u0080\5\u0080")
        buf.write("\u0785\n\u0080\3\u0081\3\u0081\3\u0081\3\u0081\3\u0081")
        buf.write("\3\u0081\3\u0081\3\u0081\3\u0081\3\u0081\3\u0081\3\u0081")
        buf.write("\5\u0081\u0793\n\u0081\3\u0082\3\u0082\3\u0082\3\u0082")
        buf.write("\3\u0082\3\u0082\3\u0082\3\u0082\3\u0082\3\u0082\3\u0082")
        buf.write("\3\u0082\5\u0082\u07a1\n\u0082\3\u0083\3\u0083\3\u0083")
        buf.write("\3\u0083\3\u0083\3\u0083\5\u0083\u07a9\n\u0083\3\u0084")
        buf.write("\3\u0084\3\u0084\3\u0084\3\u0084\3\u0084\3\u0084\3\u0084")
        buf.write("\3\u0084\5\u0084\u07b4\n\u0084\3\u0085\3\u0085\3\u0086")
        buf.write("\3\u0086\3\u0087\3\u0087\3\u0088\3\u0088\3\u0089\3\u0089")
        buf.write("\3\u008a\3\u008a\3\u008b\3\u008b\3\u008c\3\u008c\3\u008d")
        buf.write("\3\u008d\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\5\u008e")
        buf.write("\u07db\n\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\7\u008e\u07f0\n\u008e\f\u008e\16\u008e\u07f3\13\u008e")
        buf.write("\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f")
        buf.write("\3\u008f\5\u008f\u07fd\n\u008f\3\u0090\3\u0090\3\u0091")
        buf.write("\3\u0091\3\u0092\3\u0092\3\u0093\3\u0093\5\u0093\u0807")
        buf.write("\n\u0093\3\u0094\3\u0094\3\u0095\3\u0095\3\u0095\3\u0095")
        buf.write("\3\u0095\3\u0096\3\u0096\3\u0096\3\u0096\3\u0096\3\u0097")
        buf.write("\3\u0097\3\u0097\3\u0097\3\u0097\3\u0098\3\u0098\3\u0098")
        buf.write("\3\u0098\3\u0098\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099")
        buf.write("\3\u009a\3\u009a\3\u009a\3\u009a\3\u009a\3\u009b\3\u009b")
        buf.write("\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009c\3\u009c")
        buf.write("\3\u009c\3\u009c\3\u009c\3\u009c\3\u009c\3\u009d\3\u009d")
        buf.write("\3\u009d\3\u009d\3\u009d\3\u009d\3\u009d\3\u009e\3\u009e")
        buf.write("\3\u009e\3\u009e\3\u009e\3\u009f\3\u009f\3\u009f\3\u009f")
        buf.write("\3\u009f\3\u00a0\3\u00a0\3\u00a0\3\u00a0\3\u00a0\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a2\3\u00a2\3\u00a2")
        buf.write("\3\u00a2\3\u00a2\3\u00a3\3\u00a3\3\u00a3\3\u00a3\3\u00a3")
        buf.write("\3\u00a4\3\u00a4\3\u00a4\3\u00a4\3\u00a4\3\u00a5\3\u00a5")
        buf.write("\3\u00a5\3\u00a5\3\u00a5\3\u00a6\3\u00a6\3\u00a6\3\u00a6")
        buf.write("\3\u00a6\3\u00a7\3\u00a7\3\u00a7\3\u00a7\3\u00a8\3\u00a8")
        buf.write("\3\u00a8\3\u00a8\3\u00a9\3\u00a9\3\u00a9\3\u00a9\3\u00aa")
        buf.write("\3\u00aa\3\u00aa\3\u00aa\3\u00ab\3\u00ab\3\u00ab\3\u00ab")
        buf.write("\3\u00ab\3\u00ab\3\u00ab\3\u00ab\5\u00ab\u0883\n\u00ab")
        buf.write("\3\u00ac\3\u00ac\3\u00ac\3\u00ac\3\u00ad\3\u00ad\3\u00ad")
        buf.write("\3\u00ad\3\u00ae\3\u00ae\3\u00ae\3\u00ae\3\u00af\3\u00af")
        buf.write("\3\u00af\3\u00af\3\u00b0\3\u00b0\3\u00b0\3\u00b0\5\u00b0")
        buf.write("\u0899\n\u00b0\3\u00b1\3\u00b1\3\u00b1\5\u00b1\u089e\n")
        buf.write("\u00b1\3\u00b2\3\u00b2\3\u00b2\5\u00b2\u08a3\n\u00b2\3")
        buf.write("\u00b3\3\u00b3\3\u00b3\3\u00b3\3\u00b3\5\u00b3\u08aa\n")
        buf.write("\u00b3\3\u00b4\3\u00b4\3\u00b4\3\u00b4\3\u00b4\3\u00b4")
        buf.write("\3\u00b4\3\u00b4\3\u00b4\3\u00b4\5\u00b4\u08b6\n\u00b4")
        buf.write("\3\u00b5\3\u00b5\3\u00b5\3\u00b5\3\u00b6\3\u00b6\3\u00b6")
        buf.write("\3\u00b6\3\u00b7\3\u00b7\3\u00b7\3\u00b7\3\u00b8\3\u00b8")
        buf.write("\3\u00b8\3\u00b8\3\u00b9\3\u00b9\3\u00b9\3\u00b9\3\u00ba")
        buf.write("\3\u00ba\3\u00ba\3\u00ba\3\u00bb\3\u00bb\3\u00bb\3\u00bb")
        buf.write("\3\u00bc\3\u00bc\3\u00bc\3\u00bc\3\u00bd\3\u00bd\3\u00bd")
        buf.write("\3\u00bd\3\u00be\3\u00be\3\u00be\3\u00be\3\u00bf\3\u00bf")
        buf.write("\3\u00bf\3\u00bf\3\u00c0\3\u00c0\3\u00c0\3\u00c0\3\u00c1")
        buf.write("\3\u00c1\3\u00c1\3\u00c1\3\u00c2\3\u00c2\3\u00c2\3\u00c2")
        buf.write("\3\u00c3\3\u00c3\3\u00c3\3\u00c3\3\u00c4\3\u00c4\3\u00c4")
        buf.write("\3\u00c4\3\u00c5\3\u00c5\3\u00c5\3\u00c5\3\u00c6\3\u00c6")
        buf.write("\3\u00c6\3\u00c6\3\u00c7\3\u00c7\3\u00c7\3\u00c7\3\u00c8")
        buf.write("\3\u00c8\3\u00c8\3\u00c8\3\u00c9\3\u00c9\3\u00c9\3\u00c9")
        buf.write("\3\u00ca\3\u00ca\3\u00cb\3\u00cb\3\u00cc\3\u00cc\3\u00cd")
        buf.write("\3\u00cd\3\u00ce\5\u00ce\u0915\n\u00ce\3\u00cf\3\u00cf")
        buf.write("\3\u00cf\7\u00cf\u091a\n\u00cf\f\u00cf\16\u00cf\u091d")
        buf.write("\13\u00cf\3\u00d0\5\u00d0\u0920\n\u00d0\3\u00d1\3\u00d1")
        buf.write("\3\u00d1\7\u00d1\u0925\n\u00d1\f\u00d1\16\u00d1\u0928")
        buf.write("\13\u00d1\3\u00d2\5\u00d2\u092b\n\u00d2\3\u00d3\3\u00d3")
        buf.write("\3\u00d3\7\u00d3\u0930\n\u00d3\f\u00d3\16\u00d3\u0933")
        buf.write("\13\u00d3\3\u00d4\3\u00d4\3\u00d4\3\u00d4\3\u00d4\3\u00d4")
        buf.write("\3\u00d4\3\u00d4\3\u00d4\3\u00d4\5\u00d4\u093f\n\u00d4")
        buf.write("\3\u00d5\3\u00d5\3\u00d5\3\u00d5\7\u00d5\u0945\n\u00d5")
        buf.write("\f\u00d5\16\u00d5\u0948\13\u00d5\5\u00d5\u094a\n\u00d5")
        buf.write("\3\u00d5\3\u00d5\3\u00d6\5\u00d6\u094f\n\u00d6\3\u00d6")
        buf.write("\3\u00d6\5\u00d6\u0953\n\u00d6\3\u00d6\5\u00d6\u0956\n")
        buf.write("\u00d6\3\u00d7\3\u00d7\3\u00d7\7\u00d7\u095b\n\u00d7\f")
        buf.write("\u00d7\16\u00d7\u095e\13\u00d7\3\u00d8\3\u00d8\3\u00d8")
        buf.write("\3\u00d8\3\u00d8\3\u00d8\3\u00d8\3\u00d8\3\u00d8\3\u00d8")
        buf.write("\3\u00d8\3\u00d8\3\u00d8\3\u00d8\3\u00d8\5\u00d8\u096f")
        buf.write("\n\u00d8\3\u00d9\3\u00d9\5\u00d9\u0973\n\u00d9\3\u00d9")
        buf.write("\3\u00d9\5\u00d9\u0977\n\u00d9\3\u00d9\3\u00d9\5\u00d9")
        buf.write("\u097b\n\u00d9\3\u00d9\3\u00d9\5\u00d9\u097f\n\u00d9\7")
        buf.write("\u00d9\u0981\n\u00d9\f\u00d9\16\u00d9\u0984\13\u00d9\3")
        buf.write("\u00d9\3\u00d9\3\u00da\3\u00da\3\u00db\3\u00db\3\u00dc")
        buf.write("\3\u00dc\3\u00dd\3\u00dd\3\u00dd\5\u00dd\u0991\n\u00dd")
        buf.write("\3\u00de\3\u00de\3\u00de\3\u00de\3\u00de\3\u00df\3\u00df")
        buf.write("\3\u00df\2\7\4\b*,\u011a\u00e0\2\4\6\b\n\f\16\20\22\24")
        buf.write("\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVX")
        buf.write("Z\\^`bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a")
        buf.write("\u008c\u008e\u0090\u0092\u0094\u0096\u0098\u009a\u009c")
        buf.write("\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa\u00ac\u00ae")
        buf.write("\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0")
        buf.write("\u00c2\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0\u00d2")
        buf.write("\u00d4\u00d6\u00d8\u00da\u00dc\u00de\u00e0\u00e2\u00e4")
        buf.write("\u00e6\u00e8\u00ea\u00ec\u00ee\u00f0\u00f2\u00f4\u00f6")
        buf.write("\u00f8\u00fa\u00fc\u00fe\u0100\u0102\u0104\u0106\u0108")
        buf.write("\u010a\u010c\u010e\u0110\u0112\u0114\u0116\u0118\u011a")
        buf.write("\u011c\u011e\u0120\u0122\u0124\u0126\u0128\u012a\u012c")
        buf.write("\u012e\u0130\u0132\u0134\u0136\u0138\u013a\u013c\u013e")
        buf.write("\u0140\u0142\u0144\u0146\u0148\u014a\u014c\u014e\u0150")
        buf.write("\u0152\u0154\u0156\u0158\u015a\u015c\u015e\u0160\u0162")
        buf.write("\u0164\u0166\u0168\u016a\u016c\u016e\u0170\u0172\u0174")
        buf.write("\u0176\u0178\u017a\u017c\u017e\u0180\u0182\u0184\u0186")
        buf.write("\u0188\u018a\u018c\u018e\u0190\u0192\u0194\u0196\u0198")
        buf.write("\u019a\u019c\u019e\u01a0\u01a2\u01a4\u01a6\u01a8\u01aa")
        buf.write("\u01ac\u01ae\u01b0\u01b2\u01b4\u01b6\u01b8\u01ba\u01bc")
        buf.write("\2\36\4\2>>\u0084\u0086\6\2\64\64;<nn\u0087\u008a\3\2")
        buf.write("\u008b\u0094\3\2\u0095\u009a\3\2\u009b\u00a0\5\2pp\u0083")
        buf.write("\u0083\u00a1\u00a2\3\2\u00a3\u00aa\b\2\24\24CCEEIIcc\u00ab")
        buf.write("\u00bb\3\2\u00bc\u00bf\3\2\u00c1\u00c2\3\2\u00c3\u00c4")
        buf.write("\3\2\u00c5\u00c6\3\2\u00c7\u00c8\3\2\u00c9\u00ca\3\2\u00cb")
        buf.write("\u00cc\3\2\u00cd\u00ce\3\2\u00cf\u00d0\3\2\u00d1\u00d2")
        buf.write("\3\2\u00d3\u00d4\3\2\u00d5\u00d6\3\2\u00d7\u00d8\4\2F")
        buf.write("F\u00d9\u00d9\3\2\u00da\u00db\3\2\u00dc\u00dd\3\2\u00de")
        buf.write("\u00df\3\2\u00e0\u00e1\3\2\u00e2\u00e3\3\2\u00e4\u00e5")
        buf.write("\2\u0a08\2\u01be\3\2\2\2\4\u01d9\3\2\2\2\6\u01e5\3\2\2")
        buf.write("\2\b\u01ec\3\2\2\2\n\u0207\3\2\2\2\f\u0219\3\2\2\2\16")
        buf.write("\u0221\3\2\2\2\20\u0223\3\2\2\2\22\u0228\3\2\2\2\24\u0238")
        buf.write("\3\2\2\2\26\u023a\3\2\2\2\30\u0241\3\2\2\2\32\u0256\3")
        buf.write("\2\2\2\34\u025e\3\2\2\2\36\u026a\3\2\2\2 \u027e\3\2\2")
        buf.write("\2\"\u0280\3\2\2\2$\u0285\3\2\2\2&\u028a\3\2\2\2(\u028f")
        buf.write("\3\2\2\2*\u0294\3\2\2\2,\u02a2\3\2\2\2.\u02b2\3\2\2\2")
        buf.write("\60\u02b4\3\2\2\2\62\u031d\3\2\2\2\64\u031f\3\2\2\2\66")
        buf.write("\u032e\3\2\2\28\u0342\3\2\2\2:\u0350\3\2\2\2<\u0352\3")
        buf.write("\2\2\2>\u0357\3\2\2\2@\u036d\3\2\2\2B\u036f\3\2\2\2D\u0374")
        buf.write("\3\2\2\2F\u0379\3\2\2\2H\u037d\3\2\2\2J\u03b8\3\2\2\2")
        buf.write("L\u03ba\3\2\2\2N\u03ed\3\2\2\2P\u03ef\3\2\2\2R\u03f4\3")
        buf.write("\2\2\2T\u03f9\3\2\2\2V\u03fd\3\2\2\2X\u040a\3\2\2\2Z\u040c")
        buf.write("\3\2\2\2\\\u041e\3\2\2\2^\u0420\3\2\2\2`\u0424\3\2\2\2")
        buf.write("b\u0436\3\2\2\2d\u0442\3\2\2\2f\u0444\3\2\2\2h\u0453\3")
        buf.write("\2\2\2j\u045f\3\2\2\2l\u0469\3\2\2\2n\u0473\3\2\2\2p\u04b6")
        buf.write("\3\2\2\2r\u04c6\3\2\2\2t\u04d6\3\2\2\2v\u04e6\3\2\2\2")
        buf.write("x\u04e8\3\2\2\2z\u04fb\3\2\2\2|\u04fd\3\2\2\2~\u0501\3")
        buf.write("\2\2\2\u0080\u0505\3\2\2\2\u0082\u050a\3\2\2\2\u0084\u050f")
        buf.write("\3\2\2\2\u0086\u0513\3\2\2\2\u0088\u0517\3\2\2\2\u008a")
        buf.write("\u0526\3\2\2\2\u008c\u0528\3\2\2\2\u008e\u052c\3\2\2\2")
        buf.write("\u0090\u053c\3\2\2\2\u0092\u053e\3\2\2\2\u0094\u054b\3")
        buf.write("\2\2\2\u0096\u054d\3\2\2\2\u0098\u0552\3\2\2\2\u009a\u0557")
        buf.write("\3\2\2\2\u009c\u0564\3\2\2\2\u009e\u056e\3\2\2\2\u00a0")
        buf.write("\u0578\3\2\2\2\u00a2\u057a\3\2\2\2\u00a4\u0592\3\2\2\2")
        buf.write("\u00a6\u0594\3\2\2\2\u00a8\u0599\3\2\2\2\u00aa\u05a6\3")
        buf.write("\2\2\2\u00ac\u05a8\3\2\2\2\u00ae\u05ac\3\2\2\2\u00b0\u05b1")
        buf.write("\3\2\2\2\u00b2\u05b6\3\2\2\2\u00b4\u05c2\3\2\2\2\u00b6")
        buf.write("\u05c4\3\2\2\2\u00b8\u05c8\3\2\2\2\u00ba\u05d4\3\2\2\2")
        buf.write("\u00bc\u05d6\3\2\2\2\u00be\u05df\3\2\2\2\u00c0\u05fc\3")
        buf.write("\2\2\2\u00c2\u05fe\3\2\2\2\u00c4\u0613\3\2\2\2\u00c6\u0615")
        buf.write("\3\2\2\2\u00c8\u0625\3\2\2\2\u00ca\u062f\3\2\2\2\u00cc")
        buf.write("\u063d\3\2\2\2\u00ce\u0674\3\2\2\2\u00d0\u0676\3\2\2\2")
        buf.write("\u00d2\u067a\3\2\2\2\u00d4\u067f\3\2\2\2\u00d6\u068f\3")
        buf.write("\2\2\2\u00d8\u0691\3\2\2\2\u00da\u0696\3\2\2\2\u00dc\u06a3")
        buf.write("\3\2\2\2\u00de\u06b9\3\2\2\2\u00e0\u06bb\3\2\2\2\u00e2")
        buf.write("\u06c0\3\2\2\2\u00e4\u06d8\3\2\2\2\u00e6\u06da\3\2\2\2")
        buf.write("\u00e8\u06e3\3\2\2\2\u00ea\u06f0\3\2\2\2\u00ec\u06f2\3")
        buf.write("\2\2\2\u00ee\u06f6\3\2\2\2\u00f0\u0705\3\2\2\2\u00f2\u0707")
        buf.write("\3\2\2\2\u00f4\u0719\3\2\2\2\u00f6\u071b\3\2\2\2\u00f8")
        buf.write("\u0731\3\2\2\2\u00fa\u073f\3\2\2\2\u00fc\u0741\3\2\2\2")
        buf.write("\u00fe\u0784\3\2\2\2\u0100\u0792\3\2\2\2\u0102\u07a0\3")
        buf.write("\2\2\2\u0104\u07a8\3\2\2\2\u0106\u07b3\3\2\2\2\u0108\u07b5")
        buf.write("\3\2\2\2\u010a\u07b7\3\2\2\2\u010c\u07b9\3\2\2\2\u010e")
        buf.write("\u07bb\3\2\2\2\u0110\u07bd\3\2\2\2\u0112\u07bf\3\2\2\2")
        buf.write("\u0114\u07c1\3\2\2\2\u0116\u07c3\3\2\2\2\u0118\u07c5\3")
        buf.write("\2\2\2\u011a\u07da\3\2\2\2\u011c\u07fc\3\2\2\2\u011e\u07fe")
        buf.write("\3\2\2\2\u0120\u0800\3\2\2\2\u0122\u0802\3\2\2\2\u0124")
        buf.write("\u0806\3\2\2\2\u0126\u0808\3\2\2\2\u0128\u080a\3\2\2\2")
        buf.write("\u012a\u080f\3\2\2\2\u012c\u0814\3\2\2\2\u012e\u0819\3")
        buf.write("\2\2\2\u0130\u081e\3\2\2\2\u0132\u0823\3\2\2\2\u0134\u0828")
        buf.write("\3\2\2\2\u0136\u082f\3\2\2\2\u0138\u0836\3\2\2\2\u013a")
        buf.write("\u083d\3\2\2\2\u013c\u0842\3\2\2\2\u013e\u0847\3\2\2\2")
        buf.write("\u0140\u084c\3\2\2\2\u0142\u0851\3\2\2\2\u0144\u0856\3")
        buf.write("\2\2\2\u0146\u085b\3\2\2\2\u0148\u0860\3\2\2\2\u014a\u0865")
        buf.write("\3\2\2\2\u014c\u086a\3\2\2\2\u014e\u086e\3\2\2\2\u0150")
        buf.write("\u0872\3\2\2\2\u0152\u0876\3\2\2\2\u0154\u0882\3\2\2\2")
        buf.write("\u0156\u0884\3\2\2\2\u0158\u0888\3\2\2\2\u015a\u088c\3")
        buf.write("\2\2\2\u015c\u0890\3\2\2\2\u015e\u0898\3\2\2\2\u0160\u089d")
        buf.write("\3\2\2\2\u0162\u08a2\3\2\2\2\u0164\u08a9\3\2\2\2\u0166")
        buf.write("\u08b5\3\2\2\2\u0168\u08b7\3\2\2\2\u016a\u08bb\3\2\2\2")
        buf.write("\u016c\u08bf\3\2\2\2\u016e\u08c3\3\2\2\2\u0170\u08c7\3")
        buf.write("\2\2\2\u0172\u08cb\3\2\2\2\u0174\u08cf\3\2\2\2\u0176\u08d3")
        buf.write("\3\2\2\2\u0178\u08d7\3\2\2\2\u017a\u08db\3\2\2\2\u017c")
        buf.write("\u08df\3\2\2\2\u017e\u08e3\3\2\2\2\u0180\u08e7\3\2\2\2")
        buf.write("\u0182\u08eb\3\2\2\2\u0184\u08ef\3\2\2\2\u0186\u08f3\3")
        buf.write("\2\2\2\u0188\u08f7\3\2\2\2\u018a\u08fb\3\2\2\2\u018c\u08ff")
        buf.write("\3\2\2\2\u018e\u0903\3\2\2\2\u0190\u0907\3\2\2\2\u0192")
        buf.write("\u090b\3\2\2\2\u0194\u090d\3\2\2\2\u0196\u090f\3\2\2\2")
        buf.write("\u0198\u0911\3\2\2\2\u019a\u0914\3\2\2\2\u019c\u0916\3")
        buf.write("\2\2\2\u019e\u091f\3\2\2\2\u01a0\u0921\3\2\2\2\u01a2\u092a")
        buf.write("\3\2\2\2\u01a4\u092c\3\2\2\2\u01a6\u093e\3\2\2\2\u01a8")
        buf.write("\u0940\3\2\2\2\u01aa\u0955\3\2\2\2\u01ac\u0957\3\2\2\2")
        buf.write("\u01ae\u096e\3\2\2\2\u01b0\u0970\3\2\2\2\u01b2\u0987\3")
        buf.write("\2\2\2\u01b4\u0989\3\2\2\2\u01b6\u098b\3\2\2\2\u01b8\u0990")
        buf.write("\3\2\2\2\u01ba\u0992\3\2\2\2\u01bc\u0997\3\2\2\2\u01be")
        buf.write("\u01c5\5\4\3\2\u01bf\u01c1\7\u0109\2\2\u01c0\u01bf\3\2")
        buf.write("\2\2\u01c0\u01c1\3\2\2\2\u01c1\u01c2\3\2\2\2\u01c2\u01c4")
        buf.write("\5\4\3\2\u01c3\u01c0\3\2\2\2\u01c4\u01c7\3\2\2\2\u01c5")
        buf.write("\u01c3\3\2\2\2\u01c5\u01c6\3\2\2\2\u01c6\u01c9\3\2\2\2")
        buf.write("\u01c7\u01c5\3\2\2\2\u01c8\u01ca\7\u0109\2\2\u01c9\u01c8")
        buf.write("\3\2\2\2\u01c9\u01ca\3\2\2\2\u01ca\u01cb\3\2\2\2\u01cb")
        buf.write("\u01cc\7\2\2\3\u01cc\3\3\2\2\2\u01cd\u01ce\b\3\1\2\u01ce")
        buf.write("\u01da\5\b\5\2\u01cf\u01d0\5\b\5\2\u01d0\u01d1\7\u010b")
        buf.write("\2\2\u01d1\u01d2\5\n\6\2\u01d2\u01da\3\2\2\2\u01d3\u01da")
        buf.write("\5\f\7\2\u01d4\u01d5\5\f\7\2\u01d5\u01d6\7\u010b\2\2\u01d6")
        buf.write("\u01d7\5\u011c\u008f\2\u01d7\u01da\3\2\2\2\u01d8\u01da")
        buf.write("\5\6\4\2\u01d9\u01cd\3\2\2\2\u01d9\u01cf\3\2\2\2\u01d9")
        buf.write("\u01d3\3\2\2\2\u01d9\u01d4\3\2\2\2\u01d9\u01d8\3\2\2\2")
        buf.write("\u01da\u01e2\3\2\2\2\u01db\u01dc\f\4\2\2\u01dc\u01dd\7")
        buf.write("\u010b\2\2\u01dd\u01de\7\3\2\2\u01de\u01df\7\u0103\2\2")
        buf.write("\u01df\u01e1\7\u0104\2\2\u01e0\u01db\3\2\2\2\u01e1\u01e4")
        buf.write("\3\2\2\2\u01e2\u01e0\3\2\2\2\u01e2\u01e3\3\2\2\2\u01e3")
        buf.write("\5\3\2\2\2\u01e4\u01e2\3\2\2\2\u01e5\u01e6\7\u0102\2\2")
        buf.write("\u01e6\7\3\2\2\2\u01e7\u01e8\b\5\1\2\u01e8\u01ed\7\u010d")
        buf.write("\2\2\u01e9\u01ea\7\u010d\2\2\u01ea\u01eb\7\u010b\2\2\u01eb")
        buf.write("\u01ed\5\16\b\2\u01ec\u01e7\3\2\2\2\u01ec\u01e9\3\2\2")
        buf.write("\2\u01ed\u01f3\3\2\2\2\u01ee\u01ef\f\3\2\2\u01ef\u01f0")
        buf.write("\7\u010b\2\2\u01f0\u01f2\5\16\b\2\u01f1\u01ee\3\2\2\2")
        buf.write("\u01f2\u01f5\3\2\2\2\u01f3\u01f1\3\2\2\2\u01f3\u01f4\3")
        buf.write("\2\2\2\u01f4\t\3\2\2\2\u01f5\u01f3\3\2\2\2\u01f6\u01f7")
        buf.write("\7\4\2\2\u01f7\u01f8\7\u0103\2\2\u01f8\u01f9\7\u0104\2")
        buf.write("\2\u01f9\u01fa\7\u010b\2\2\u01fa\u01fb\7\5\2\2\u01fb\u01fc")
        buf.write("\7\u0103\2\2\u01fc\u0208\7\u0104\2\2\u01fd\u01fe\7\4\2")
        buf.write("\2\u01fe\u01ff\7\u0103\2\2\u01ff\u0200\7\u0104\2\2\u0200")
        buf.write("\u0201\7\u010b\2\2\u0201\u0202\7\6\2\2\u0202\u0203\7\u0103")
        buf.write("\2\2\u0203\u0208\7\u0104\2\2\u0204\u0205\7\4\2\2\u0205")
        buf.write("\u0206\7\u0103\2\2\u0206\u0208\7\u0104\2\2\u0207\u01f6")
        buf.write("\3\2\2\2\u0207\u01fd\3\2\2\2\u0207\u0204\3\2\2\2\u0208")
        buf.write("\13\3\2\2\2\u0209\u020a\5\b\5\2\u020a\u020b\7\u010b\2")
        buf.write("\2\u020b\u020c\5\34\17\2\u020c\u021a\3\2\2\2\u020d\u020e")
        buf.write("\5\b\5\2\u020e\u020f\7\u010b\2\2\u020f\u0210\5\34\17\2")
        buf.write("\u0210\u0211\7\u010b\2\2\u0211\u0212\5*\26\2\u0212\u021a")
        buf.write("\3\2\2\2\u0213\u0214\5\b\5\2\u0214\u0215\7\u010b\2\2\u0215")
        buf.write("\u0216\5\34\17\2\u0216\u0217\7\u010b\2\2\u0217\u0218\5")
        buf.write(",\27\2\u0218\u021a\3\2\2\2\u0219\u0209\3\2\2\2\u0219\u020d")
        buf.write("\3\2\2\2\u0219\u0213\3\2\2\2\u021a\r\3\2\2\2\u021b\u0222")
        buf.write("\5\20\t\2\u021c\u0222\5\22\n\2\u021d\u0222\5\24\13\2\u021e")
        buf.write("\u0222\5\26\f\2\u021f\u0222\5\30\r\2\u0220\u0222\5\32")
        buf.write("\16\2\u0221\u021b\3\2\2\2\u0221\u021c\3\2\2\2\u0221\u021d")
        buf.write("\3\2\2\2\u0221\u021e\3\2\2\2\u0221\u021f\3\2\2\2\u0221")
        buf.write("\u0220\3\2\2\2\u0222\17\3\2\2\2\u0223\u0224\7\7\2\2\u0224")
        buf.write("\u0225\7\u0103\2\2\u0225\u0226\5\u01b6\u00dc\2\u0226\u0227")
        buf.write("\7\u0104\2\2\u0227\21\3\2\2\2\u0228\u0229\7\b\2\2\u0229")
        buf.write("\u022a\7\u0103\2\2\u022a\u022b\7\u0104\2\2\u022b\23\3")
        buf.write("\2\2\2\u022c\u022d\7\t\2\2\u022d\u022e\7\u0103\2\2\u022e")
        buf.write("\u022f\5\u01ae\u00d8\2\u022f\u0230\7\u0104\2\2\u0230\u0239")
        buf.write("\3\2\2\2\u0231\u0232\7\t\2\2\u0232\u0233\7\u0103\2\2\u0233")
        buf.write("\u0234\5\u01ae\u00d8\2\u0234\u0235\7\u010a\2\2\u0235\u0236")
        buf.write("\5\u0116\u008c\2\u0236\u0237\7\u0104\2\2\u0237\u0239\3")
        buf.write("\2\2\2\u0238\u022c\3\2\2\2\u0238\u0231\3\2\2\2\u0239\25")
        buf.write("\3\2\2\2\u023a\u023b\7\n\2\2\u023b\u023c\7\u0103\2\2\u023c")
        buf.write("\u023d\5\u01b8\u00dd\2\u023d\u023e\7\u010a\2\2\u023e\u023f")
        buf.write("\5\u01ae\u00d8\2\u023f\u0240\7\u0104\2\2\u0240\27\3\2")
        buf.write("\2\2\u0241\u0242\7\13\2\2\u0242\u0243\7\u0103\2\2\u0243")
        buf.write("\u0246\5\u00fe\u0080\2\u0244\u0245\7\u010a\2\2\u0245\u0247")
        buf.write("\5\u019a\u00ce\2\u0246\u0244\3\2\2\2\u0246\u0247\3\2\2")
        buf.write("\2\u0247\u0248\3\2\2\2\u0248\u0249\7\u0104\2\2\u0249\31")
        buf.write("\3\2\2\2\u024a\u024b\7\f\2\2\u024b\u024c\7\u0103\2\2\u024c")
        buf.write("\u024d\5\u01b8\u00dd\2\u024d\u024e\7\u0104\2\2\u024e\u0257")
        buf.write("\3\2\2\2\u024f\u0250\7\f\2\2\u0250\u0251\7\u0103\2\2\u0251")
        buf.write("\u0252\5\u01b8\u00dd\2\u0252\u0253\7\u010a\2\2\u0253\u0254")
        buf.write("\5\u01ae\u00d8\2\u0254\u0255\7\u0104\2\2\u0255\u0257\3")
        buf.write("\2\2\2\u0256\u024a\3\2\2\2\u0256\u024f\3\2\2\2\u0257\33")
        buf.write("\3\2\2\2\u0258\u025f\5\36\20\2\u0259\u025f\5 \21\2\u025a")
        buf.write("\u025f\5\"\22\2\u025b\u025f\5$\23\2\u025c\u025f\5&\24")
        buf.write("\2\u025d\u025f\5(\25\2\u025e\u0258\3\2\2\2\u025e\u0259")
        buf.write("\3\2\2\2\u025e\u025a\3\2\2\2\u025e\u025b\3\2\2\2\u025e")
        buf.write("\u025c\3\2\2\2\u025e\u025d\3\2\2\2\u025f\35\3\2\2\2\u0260")
        buf.write("\u0261\7\r\2\2\u0261\u0262\7\u0103\2\2\u0262\u0263\5\u01b8")
        buf.write("\u00dd\2\u0263\u0264\7\u0104\2\2\u0264\u026b\3\2\2\2\u0265")
        buf.write("\u0266\7\r\2\2\u0266\u0267\7\u0103\2\2\u0267\u0268\5.")
        buf.write("\30\2\u0268\u0269\7\u0104\2\2\u0269\u026b\3\2\2\2\u026a")
        buf.write("\u0260\3\2\2\2\u026a\u0265\3\2\2\2\u026b\37\3\2\2\2\u026c")
        buf.write("\u026d\7\16\2\2\u026d\u026e\7\u0103\2\2\u026e\u027f\7")
        buf.write("\u0104\2\2\u026f\u0270\7\16\2\2\u0270\u0271\7\u0103\2")
        buf.write("\2\u0271\u0272\5\u01b8\u00dd\2\u0272\u0273\7\u0104\2\2")
        buf.write("\u0273\u027f\3\2\2\2\u0274\u0275\7\16\2\2\u0275\u0276")
        buf.write("\7\u0103\2\2\u0276\u0277\5\u01bc\u00df\2\u0277\u0278\7")
        buf.write("\u0104\2\2\u0278\u027f\3\2\2\2\u0279\u027a\7\16\2\2\u027a")
        buf.write("\u027b\7\u0103\2\2\u027b\u027c\5.\30\2\u027c\u027d\7\u0104")
        buf.write("\2\2\u027d\u027f\3\2\2\2\u027e\u026c\3\2\2\2\u027e\u026f")
        buf.write("\3\2\2\2\u027e\u0274\3\2\2\2\u027e\u0279\3\2\2\2\u027f")
        buf.write("!\3\2\2\2\u0280\u0281\7\17\2\2\u0281\u0282\7\u0103\2\2")
        buf.write("\u0282\u0283\5\u01a2\u00d2\2\u0283\u0284\7\u0104\2\2\u0284")
        buf.write("#\3\2\2\2\u0285\u0286\7\20\2\2\u0286\u0287\7\u0103\2\2")
        buf.write("\u0287\u0288\5\u01a2\u00d2\2\u0288\u0289\7\u0104\2\2\u0289")
        buf.write("%\3\2\2\2\u028a\u028b\7\21\2\2\u028b\u028c\7\u0103\2\2")
        buf.write("\u028c\u028d\5\u01a2\u00d2\2\u028d\u028e\7\u0104\2\2\u028e")
        buf.write("\'\3\2\2\2\u028f\u0290\7\22\2\2\u0290\u0291\7\u0103\2")
        buf.write("\2\u0291\u0292\5\u01b8\u00dd\2\u0292\u0293\7\u0104\2\2")
        buf.write("\u0293)\3\2\2\2\u0294\u0295\b\26\1\2\u0295\u0296\5\62")
        buf.write("\32\2\u0296\u029f\3\2\2\2\u0297\u0298\f\4\2\2\u0298\u0299")
        buf.write("\7\u010b\2\2\u0299\u029e\5\62\32\2\u029a\u029b\f\3\2\2")
        buf.write("\u029b\u029c\7\u010b\2\2\u029c\u029e\5,\27\2\u029d\u0297")
        buf.write("\3\2\2\2\u029d\u029a\3\2\2\2\u029e\u02a1\3\2\2\2\u029f")
        buf.write("\u029d\3\2\2\2\u029f\u02a0\3\2\2\2\u02a0+\3\2\2\2\u02a1")
        buf.write("\u029f\3\2\2\2\u02a2\u02a3\b\27\1\2\u02a3\u02a4\5\u0120")
        buf.write("\u0091\2\u02a4\u02aa\3\2\2\2\u02a5\u02a6\f\3\2\2\u02a6")
        buf.write("\u02a7\7\u010b\2\2\u02a7\u02a9\5\u0120\u0091\2\u02a8\u02a5")
        buf.write("\3\2\2\2\u02a9\u02ac\3\2\2\2\u02aa\u02a8\3\2\2\2\u02aa")
        buf.write("\u02ab\3\2\2\2\u02ab-\3\2\2\2\u02ac\u02aa\3\2\2\2\u02ad")
        buf.write("\u02b3\5\f\7\2\u02ae\u02b3\5*\26\2\u02af\u02b0\7\u010e")
        buf.write("\2\2\u02b0\u02b1\7\u010b\2\2\u02b1\u02b3\5*\26\2\u02b2")
        buf.write("\u02ad\3\2\2\2\u02b2\u02ae\3\2\2\2\u02b2\u02af\3\2\2\2")
        buf.write("\u02b3/\3\2\2\2\u02b4\u02b5\5\f\7\2\u02b5\u02b6\7\u010b")
        buf.write("\2\2\u02b6\u02b7\5\u011c\u008f\2\u02b7\61\3\2\2\2\u02b8")
        buf.write("\u031e\5\64\33\2\u02b9\u031e\5\66\34\2\u02ba\u031e\58")
        buf.write("\35\2\u02bb\u031e\5:\36\2\u02bc\u031e\5<\37\2\u02bd\u031e")
        buf.write("\5> \2\u02be\u031e\5@!\2\u02bf\u031e\5B\"\2\u02c0\u031e")
        buf.write("\5D#\2\u02c1\u031e\5F$\2\u02c2\u031e\5H%\2\u02c3\u031e")
        buf.write("\5J&\2\u02c4\u031e\5L\'\2\u02c5\u031e\5N(\2\u02c6\u031e")
        buf.write("\5P)\2\u02c7\u031e\5R*\2\u02c8\u031e\5T+\2\u02c9\u031e")
        buf.write("\5V,\2\u02ca\u031e\5X-\2\u02cb\u031e\5Z.\2\u02cc\u031e")
        buf.write("\5\\/\2\u02cd\u031e\5^\60\2\u02ce\u031e\5`\61\2\u02cf")
        buf.write("\u031e\5b\62\2\u02d0\u031e\5d\63\2\u02d1\u031e\5f\64\2")
        buf.write("\u02d2\u031e\5h\65\2\u02d3\u031e\5j\66\2\u02d4\u031e\5")
        buf.write("l\67\2\u02d5\u031e\5n8\2\u02d6\u031e\5p9\2\u02d7\u031e")
        buf.write("\5r:\2\u02d8\u031e\5t;\2\u02d9\u031e\5v<\2\u02da\u031e")
        buf.write("\5x=\2\u02db\u031e\5z>\2\u02dc\u031e\5|?\2\u02dd\u031e")
        buf.write("\5~@\2\u02de\u031e\5\u0080A\2\u02df\u031e\5\u0082B\2\u02e0")
        buf.write("\u031e\5\u0084C\2\u02e1\u031e\5\u0086D\2\u02e2\u031e\5")
        buf.write("\u0088E\2\u02e3\u031e\5\u008aF\2\u02e4\u031e\5\u008cG")
        buf.write("\2\u02e5\u031e\5\u008eH\2\u02e6\u031e\5\u0090I\2\u02e7")
        buf.write("\u031e\5\u0092J\2\u02e8\u031e\5\u0094K\2\u02e9\u031e\5")
        buf.write("\u0096L\2\u02ea\u031e\5\u0098M\2\u02eb\u031e\5\u009aN")
        buf.write("\2\u02ec\u031e\5\u009cO\2\u02ed\u031e\5\u009eP\2\u02ee")
        buf.write("\u031e\5\u00a0Q\2\u02ef\u031e\5\u00a2R\2\u02f0\u031e\5")
        buf.write("\u00a4S\2\u02f1\u031e\5\u00a6T\2\u02f2\u031e\5\u00a8U")
        buf.write("\2\u02f3\u031e\5\u00aaV\2\u02f4\u031e\5\u00acW\2\u02f5")
        buf.write("\u031e\5\u00aeX\2\u02f6\u031e\5\u00b0Y\2\u02f7\u031e\5")
        buf.write("\u00b2Z\2\u02f8\u031e\5\u00b4[\2\u02f9\u031e\5\u00b6\\")
        buf.write("\2\u02fa\u031e\5\u00b8]\2\u02fb\u031e\5\u00ba^\2\u02fc")
        buf.write("\u031e\5\u00bc_\2\u02fd\u031e\5\u00be`\2\u02fe\u031e\5")
        buf.write("\u00c0a\2\u02ff\u031e\5\u00c2b\2\u0300\u031e\5\u00c4c")
        buf.write("\2\u0301\u031e\5\u00c6d\2\u0302\u031e\5\u00c8e\2\u0303")
        buf.write("\u031e\5\u00caf\2\u0304\u031e\5\u00ccg\2\u0305\u031e\5")
        buf.write("\u00ceh\2\u0306\u031e\5\u00d0i\2\u0307\u031e\5\u00d2j")
        buf.write("\2\u0308\u031e\5\u00d4k\2\u0309\u031e\5\u00d6l\2\u030a")
        buf.write("\u031e\5\u00d8m\2\u030b\u031e\5\u00dan\2\u030c\u031e\5")
        buf.write("\u00dco\2\u030d\u031e\5\u00dep\2\u030e\u031e\5\u00e0q")
        buf.write("\2\u030f\u031e\5\u00e2r\2\u0310\u031e\5\u00e4s\2\u0311")
        buf.write("\u031e\5\u00e6t\2\u0312\u031e\5\u00e8u\2\u0313\u031e\5")
        buf.write("\u00eav\2\u0314\u031e\5\u00ecw\2\u0315\u031e\5\u00eex")
        buf.write("\2\u0316\u031e\5\u00f0y\2\u0317\u031e\5\u00f2z\2\u0318")
        buf.write("\u031e\5\u00f4{\2\u0319\u031e\5\u00f6|\2\u031a\u031e\5")
        buf.write("\u00f8}\2\u031b\u031e\5\u00fa~\2\u031c\u031e\5\u00fc\177")
        buf.write("\2\u031d\u02b8\3\2\2\2\u031d\u02b9\3\2\2\2\u031d\u02ba")
        buf.write("\3\2\2\2\u031d\u02bb\3\2\2\2\u031d\u02bc\3\2\2\2\u031d")
        buf.write("\u02bd\3\2\2\2\u031d\u02be\3\2\2\2\u031d\u02bf\3\2\2\2")
        buf.write("\u031d\u02c0\3\2\2\2\u031d\u02c1\3\2\2\2\u031d\u02c2\3")
        buf.write("\2\2\2\u031d\u02c3\3\2\2\2\u031d\u02c4\3\2\2\2\u031d\u02c5")
        buf.write("\3\2\2\2\u031d\u02c6\3\2\2\2\u031d\u02c7\3\2\2\2\u031d")
        buf.write("\u02c8\3\2\2\2\u031d\u02c9\3\2\2\2\u031d\u02ca\3\2\2\2")
        buf.write("\u031d\u02cb\3\2\2\2\u031d\u02cc\3\2\2\2\u031d\u02cd\3")
        buf.write("\2\2\2\u031d\u02ce\3\2\2\2\u031d\u02cf\3\2\2\2\u031d\u02d0")
        buf.write("\3\2\2\2\u031d\u02d1\3\2\2\2\u031d\u02d2\3\2\2\2\u031d")
        buf.write("\u02d3\3\2\2\2\u031d\u02d4\3\2\2\2\u031d\u02d5\3\2\2\2")
        buf.write("\u031d\u02d6\3\2\2\2\u031d\u02d7\3\2\2\2\u031d\u02d8\3")
        buf.write("\2\2\2\u031d\u02d9\3\2\2\2\u031d\u02da\3\2\2\2\u031d\u02db")
        buf.write("\3\2\2\2\u031d\u02dc\3\2\2\2\u031d\u02dd\3\2\2\2\u031d")
        buf.write("\u02de\3\2\2\2\u031d\u02df\3\2\2\2\u031d\u02e0\3\2\2\2")
        buf.write("\u031d\u02e1\3\2\2\2\u031d\u02e2\3\2\2\2\u031d\u02e3\3")
        buf.write("\2\2\2\u031d\u02e4\3\2\2\2\u031d\u02e5\3\2\2\2\u031d\u02e6")
        buf.write("\3\2\2\2\u031d\u02e7\3\2\2\2\u031d\u02e8\3\2\2\2\u031d")
        buf.write("\u02e9\3\2\2\2\u031d\u02ea\3\2\2\2\u031d\u02eb\3\2\2\2")
        buf.write("\u031d\u02ec\3\2\2\2\u031d\u02ed\3\2\2\2\u031d\u02ee\3")
        buf.write("\2\2\2\u031d\u02ef\3\2\2\2\u031d\u02f0\3\2\2\2\u031d\u02f1")
        buf.write("\3\2\2\2\u031d\u02f2\3\2\2\2\u031d\u02f3\3\2\2\2\u031d")
        buf.write("\u02f4\3\2\2\2\u031d\u02f5\3\2\2\2\u031d\u02f6\3\2\2\2")
        buf.write("\u031d\u02f7\3\2\2\2\u031d\u02f8\3\2\2\2\u031d\u02f9\3")
        buf.write("\2\2\2\u031d\u02fa\3\2\2\2\u031d\u02fb\3\2\2\2\u031d\u02fc")
        buf.write("\3\2\2\2\u031d\u02fd\3\2\2\2\u031d\u02fe\3\2\2\2\u031d")
        buf.write("\u02ff\3\2\2\2\u031d\u0300\3\2\2\2\u031d\u0301\3\2\2\2")
        buf.write("\u031d\u0302\3\2\2\2\u031d\u0303\3\2\2\2\u031d\u0304\3")
        buf.write("\2\2\2\u031d\u0305\3\2\2\2\u031d\u0306\3\2\2\2\u031d\u0307")
        buf.write("\3\2\2\2\u031d\u0308\3\2\2\2\u031d\u0309\3\2\2\2\u031d")
        buf.write("\u030a\3\2\2\2\u031d\u030b\3\2\2\2\u031d\u030c\3\2\2\2")
        buf.write("\u031d\u030d\3\2\2\2\u031d\u030e\3\2\2\2\u031d\u030f\3")
        buf.write("\2\2\2\u031d\u0310\3\2\2\2\u031d\u0311\3\2\2\2\u031d\u0312")
        buf.write("\3\2\2\2\u031d\u0313\3\2\2\2\u031d\u0314\3\2\2\2\u031d")
        buf.write("\u0315\3\2\2\2\u031d\u0316\3\2\2\2\u031d\u0317\3\2\2\2")
        buf.write("\u031d\u0318\3\2\2\2\u031d\u0319\3\2\2\2\u031d\u031a\3")
        buf.write("\2\2\2\u031d\u031b\3\2\2\2\u031d\u031c\3\2\2\2\u031e\63")
        buf.write("\3\2\2\2\u031f\u0320\7\20\2\2\u0320\u0321\7\u0103\2\2")
        buf.write("\u0321\u0322\5\u01a2\u00d2\2\u0322\u0323\7\u0104\2\2\u0323")
        buf.write("\65\3\2\2\2\u0324\u0325\7\r\2\2\u0325\u0326\7\u0103\2")
        buf.write("\2\u0326\u0327\5\u01b8\u00dd\2\u0327\u0328\7\u0104\2\2")
        buf.write("\u0328\u032f\3\2\2\2\u0329\u032a\7\r\2\2\u032a\u032b\7")
        buf.write("\u0103\2\2\u032b\u032c\5.\30\2\u032c\u032d\7\u0104\2\2")
        buf.write("\u032d\u032f\3\2\2\2\u032e\u0324\3\2\2\2\u032e\u0329\3")
        buf.write("\2\2\2\u032f\67\3\2\2\2\u0330\u0331\7\16\2\2\u0331\u0332")
        buf.write("\7\u0103\2\2\u0332\u0343\7\u0104\2\2\u0333\u0334\7\16")
        buf.write("\2\2\u0334\u0335\7\u0103\2\2\u0335\u0336\5\u01b8\u00dd")
        buf.write("\2\u0336\u0337\7\u0104\2\2\u0337\u0343\3\2\2\2\u0338\u0339")
        buf.write("\7\16\2\2\u0339\u033a\7\u0103\2\2\u033a\u033b\5\u01bc")
        buf.write("\u00df\2\u033b\u033c\7\u0104\2\2\u033c\u0343\3\2\2\2\u033d")
        buf.write("\u033e\7\16\2\2\u033e\u033f\7\u0103\2\2\u033f\u0340\5")
        buf.write(".\30\2\u0340\u0341\7\u0104\2\2\u0341\u0343\3\2\2\2\u0342")
        buf.write("\u0330\3\2\2\2\u0342\u0333\3\2\2\2\u0342\u0338\3\2\2\2")
        buf.write("\u0342\u033d\3\2\2\2\u03439\3\2\2\2\u0344\u0345\7\23\2")
        buf.write("\2\u0345\u0346\7\u0103\2\2\u0346\u0347\5\u0108\u0085\2")
        buf.write("\u0347\u0348\7\u010a\2\2\u0348\u0349\5\u01b8\u00dd\2\u0349")
        buf.write("\u034a\7\u0104\2\2\u034a\u0351\3\2\2\2\u034b\u034c\7\23")
        buf.write("\2\2\u034c\u034d\7\u0103\2\2\u034d\u034e\5\u01b8\u00dd")
        buf.write("\2\u034e\u034f\7\u0104\2\2\u034f\u0351\3\2\2\2\u0350\u0344")
        buf.write("\3\2\2\2\u0350\u034b\3\2\2\2\u0351;\3\2\2\2\u0352\u0353")
        buf.write("\7\24\2\2\u0353\u0354\7\u0103\2\2\u0354\u0355\5\u019e")
        buf.write("\u00d0\2\u0355\u0356\7\u0104\2\2\u0356=\3\2\2\2\u0357")
        buf.write("\u0358\7\25\2\2\u0358\u0359\7\u0103\2\2\u0359\u035c\5")
        buf.write("\u01b8\u00dd\2\u035a\u035b\7\u010a\2\2\u035b\u035d\5\u01aa")
        buf.write("\u00d6\2\u035c\u035a\3\2\2\2\u035c\u035d\3\2\2\2\u035d")
        buf.write("\u035e\3\2\2\2\u035e\u035f\7\u0104\2\2\u035f?\3\2\2\2")
        buf.write("\u0360\u0361\7\26\2\2\u0361\u0362\7\u0103\2\2\u0362\u0363")
        buf.write("\5\u011e\u0090\2\u0363\u0364\7\u0104\2\2\u0364\u036e\3")
        buf.write("\2\2\2\u0365\u0366\7\26\2\2\u0366\u0367\7\u0103\2\2\u0367")
        buf.write("\u036e\7\u0104\2\2\u0368\u0369\7\26\2\2\u0369\u036a\7")
        buf.write("\u0103\2\2\u036a\u036b\5\u01b2\u00da\2\u036b\u036c\7\u0104")
        buf.write("\2\2\u036c\u036e\3\2\2\2\u036d\u0360\3\2\2\2\u036d\u0365")
        buf.write("\3\2\2\2\u036d\u0368\3\2\2\2\u036eA\3\2\2\2\u036f\u0370")
        buf.write("\7\27\2\2\u0370\u0371\7\u0103\2\2\u0371\u0372\5\u01aa")
        buf.write("\u00d6\2\u0372\u0373\7\u0104\2\2\u0373C\3\2\2\2\u0374")
        buf.write("\u0375\7\30\2\2\u0375\u0376\7\u0103\2\2\u0376\u0377\5")
        buf.write("\u01aa\u00d6\2\u0377\u0378\7\u0104\2\2\u0378E\3\2\2\2")
        buf.write("\u0379\u037a\7\31\2\2\u037a\u037b\7\u0103\2\2\u037b\u037c")
        buf.write("\7\u0104\2\2\u037cG\3\2\2\2\u037d\u037e\7\32\2\2\u037e")
        buf.write("\u037f\7\u0103\2\2\u037f\u0380\5.\30\2\u0380\u0381\7\u0104")
        buf.write("\2\2\u0381I\3\2\2\2\u0382\u0383\7\33\2\2\u0383\u0384\7")
        buf.write("\u0103\2\2\u0384\u0385\5\u0122\u0092\2\u0385\u0386\7\u0104")
        buf.write("\2\2\u0386\u03b9\3\2\2\2\u0387\u0388\7\33\2\2\u0388\u0389")
        buf.write("\7\u0103\2\2\u0389\u03b9\7\u0104\2\2\u038a\u038b\7\33")
        buf.write("\2\2\u038b\u038c\7\u0103\2\2\u038c\u038d\5\u0124\u0093")
        buf.write("\2\u038d\u038e\7\u0104\2\2\u038e\u03b9\3\2\2\2\u038f\u0390")
        buf.write("\7\33\2\2\u0390\u0391\7\u0103\2\2\u0391\u0392\5\u0124")
        buf.write("\u0093\2\u0392\u0393\7\u010a\2\2\u0393\u0394\5\u0122\u0092")
        buf.write("\2\u0394\u0395\7\u0104\2\2\u0395\u03b9\3\2\2\2\u0396\u0397")
        buf.write("\7\33\2\2\u0397\u0398\7\u0103\2\2\u0398\u0399\5\u010c")
        buf.write("\u0087\2\u0399\u039a\7\u0104\2\2\u039a\u03b9\3\2\2\2\u039b")
        buf.write("\u039c\7\33\2\2\u039c\u039d\7\u0103\2\2\u039d\u039e\5")
        buf.write("\u01b8\u00dd\2\u039e\u039f\7\u0104\2\2\u039f\u03b9\3\2")
        buf.write("\2\2\u03a0\u03a1\7\33\2\2\u03a1\u03a2\7\u0103\2\2\u03a2")
        buf.write("\u03a3\5\u01b8\u00dd\2\u03a3\u03a4\7\u010a\2\2\u03a4\u03a5")
        buf.write("\5\u0122\u0092\2\u03a5\u03a6\7\u0104\2\2\u03a6\u03b9\3")
        buf.write("\2\2\2\u03a7\u03a8\7\33\2\2\u03a8\u03a9\7\u0103\2\2\u03a9")
        buf.write("\u03aa\5\u010a\u0086\2\u03aa\u03ab\7\u0104\2\2\u03ab\u03b9")
        buf.write("\3\2\2\2\u03ac\u03ad\7\33\2\2\u03ad\u03ae\7\u0103\2\2")
        buf.write("\u03ae\u03af\5.\30\2\u03af\u03b0\7\u0104\2\2\u03b0\u03b9")
        buf.write("\3\2\2\2\u03b1\u03b2\7\33\2\2\u03b2\u03b3\7\u0103\2\2")
        buf.write("\u03b3\u03b4\5.\30\2\u03b4\u03b5\7\u010a\2\2\u03b5\u03b6")
        buf.write("\5\u0122\u0092\2\u03b6\u03b7\7\u0104\2\2\u03b7\u03b9\3")
        buf.write("\2\2\2\u03b8\u0382\3\2\2\2\u03b8\u0387\3\2\2\2\u03b8\u038a")
        buf.write("\3\2\2\2\u03b8\u038f\3\2\2\2\u03b8\u0396\3\2\2\2\u03b8")
        buf.write("\u039b\3\2\2\2\u03b8\u03a0\3\2\2\2\u03b8\u03a7\3\2\2\2")
        buf.write("\u03b8\u03ac\3\2\2\2\u03b8\u03b1\3\2\2\2\u03b9K\3\2\2")
        buf.write("\2\u03ba\u03bb\7\34\2\2\u03bb\u03bc\7\u0103\2\2\u03bc")
        buf.write("\u03bf\5\u01b8\u00dd\2\u03bd\u03be\7\u010a\2\2\u03be\u03c0")
        buf.write("\5\u01aa\u00d6\2\u03bf\u03bd\3\2\2\2\u03bf\u03c0\3\2\2")
        buf.write("\2\u03c0\u03c1\3\2\2\2\u03c1\u03c2\7\u0104\2\2\u03c2M")
        buf.write("\3\2\2\2\u03c3\u03c4\7\35\2\2\u03c4\u03c5\7\u0103\2\2")
        buf.write("\u03c5\u03c6\5\u0124\u0093\2\u03c6\u03c7\7\u0104\2\2\u03c7")
        buf.write("\u03ee\3\2\2\2\u03c8\u03c9\7\35\2\2\u03c9\u03ca\7\u0103")
        buf.write("\2\2\u03ca\u03cb\5\u011a\u008e\2\u03cb\u03cc\7\u010a\2")
        buf.write("\2\u03cc\u03cd\5.\30\2\u03cd\u03ce\7\u0104\2\2\u03ce\u03ee")
        buf.write("\3\2\2\2\u03cf\u03d0\7\35\2\2\u03d0\u03d1\7\u0103\2\2")
        buf.write("\u03d1\u03d2\5\u011a\u008e\2\u03d2\u03d3\7\u010a\2\2\u03d3")
        buf.write("\u03d4\5.\30\2\u03d4\u03d5\7\u010a\2\2\u03d5\u03d6\5.")
        buf.write("\30\2\u03d6\u03d7\7\u0104\2\2\u03d7\u03ee\3\2\2\2\u03d8")
        buf.write("\u03d9\7\35\2\2\u03d9\u03da\7\u0103\2\2\u03da\u03db\5")
        buf.write(".\30\2\u03db\u03dc\7\u0104\2\2\u03dc\u03ee\3\2\2\2\u03dd")
        buf.write("\u03de\7\35\2\2\u03de\u03df\7\u0103\2\2\u03df\u03e0\5")
        buf.write(".\30\2\u03e0\u03e1\7\u010a\2\2\u03e1\u03e2\5.\30\2\u03e2")
        buf.write("\u03e3\7\u0104\2\2\u03e3\u03ee\3\2\2\2\u03e4\u03e5\7\35")
        buf.write("\2\2\u03e5\u03e6\7\u0103\2\2\u03e6\u03e7\5.\30\2\u03e7")
        buf.write("\u03e8\7\u010a\2\2\u03e8\u03e9\5.\30\2\u03e9\u03ea\7\u010a")
        buf.write("\2\2\u03ea\u03eb\5.\30\2\u03eb\u03ec\7\u0104\2\2\u03ec")
        buf.write("\u03ee\3\2\2\2\u03ed\u03c3\3\2\2\2\u03ed\u03c8\3\2\2\2")
        buf.write("\u03ed\u03cf\3\2\2\2\u03ed\u03d8\3\2\2\2\u03ed\u03dd\3")
        buf.write("\2\2\2\u03ed\u03e4\3\2\2\2\u03eeO\3\2\2\2\u03ef\u03f0")
        buf.write("\7\36\2\2\u03f0\u03f1\7\u0103\2\2\u03f1\u03f2\5\u019e")
        buf.write("\u00d0\2\u03f2\u03f3\7\u0104\2\2\u03f3Q\3\2\2\2\u03f4")
        buf.write("\u03f5\7\37\2\2\u03f5\u03f6\7\u0103\2\2\u03f6\u03f7\5")
        buf.write("\u01b4\u00db\2\u03f7\u03f8\7\u0104\2\2\u03f8S\3\2\2\2")
        buf.write("\u03f9\u03fa\7 \2\2\u03fa\u03fb\7\u0103\2\2\u03fb\u03fc")
        buf.write("\7\u0104\2\2\u03fcU\3\2\2\2\u03fd\u03fe\7!\2\2\u03fe\u03ff")
        buf.write("\7\u0103\2\2\u03ff\u0400\5\u01ae\u00d8\2\u0400\u0401\7")
        buf.write("\u0104\2\2\u0401W\3\2\2\2\u0402\u0403\7\"\2\2\u0403\u0404")
        buf.write("\7\u0103\2\2\u0404\u040b\7\u0104\2\2\u0405\u0406\7\"\2")
        buf.write("\2\u0406\u0407\7\u0103\2\2\u0407\u0408\5\u0108\u0085\2")
        buf.write("\u0408\u0409\7\u0104\2\2\u0409\u040b\3\2\2\2\u040a\u0402")
        buf.write("\3\2\2\2\u040a\u0405\3\2\2\2\u040bY\3\2\2\2\u040c\u040d")
        buf.write("\7#\2\2\u040d\u040e\7\u0103\2\2\u040e\u040f\7\u0104\2")
        buf.write("\2\u040f[\3\2\2\2\u0410\u0411\7$\2\2\u0411\u0412\7\u0103")
        buf.write("\2\2\u0412\u0415\5\u0108\u0085\2\u0413\u0414\7\u010a\2")
        buf.write("\2\u0414\u0416\5\u01aa\u00d6\2\u0415\u0413\3\2\2\2\u0415")
        buf.write("\u0416\3\2\2\2\u0416\u0417\3\2\2\2\u0417\u0418\7\u0104")
        buf.write("\2\2\u0418\u041f\3\2\2\2\u0419\u041a\7$\2\2\u041a\u041b")
        buf.write("\7\u0103\2\2\u041b\u041c\5\u01aa\u00d6\2\u041c\u041d\7")
        buf.write("\u0104\2\2\u041d\u041f\3\2\2\2\u041e\u0410\3\2\2\2\u041e")
        buf.write("\u0419\3\2\2\2\u041f]\3\2\2\2\u0420\u0421\7%\2\2\u0421")
        buf.write("\u0422\7\u0103\2\2\u0422\u0423\7\u0104\2\2\u0423_\3\2")
        buf.write("\2\2\u0424\u0425\7&\2\2\u0425\u0426\7\u0103\2\2\u0426")
        buf.write("\u0427\5\u01aa\u00d6\2\u0427\u0428\7\u0104\2\2\u0428a")
        buf.write("\3\2\2\2\u0429\u042a\7\'\2\2\u042a\u042b\7\u0103\2\2\u042b")
        buf.write("\u0437\7\u0104\2\2\u042c\u042d\7\'\2\2\u042d\u042e\7\u0103")
        buf.write("\2\2\u042e\u042f\5\u011a\u008e\2\u042f\u0430\7\u0104\2")
        buf.write("\2\u0430\u0437\3\2\2\2\u0431\u0432\7\'\2\2\u0432\u0433")
        buf.write("\7\u0103\2\2\u0433\u0434\5.\30\2\u0434\u0435\7\u0104\2")
        buf.write("\2\u0435\u0437\3\2\2\2\u0436\u0429\3\2\2\2\u0436\u042c")
        buf.write("\3\2\2\2\u0436\u0431\3\2\2\2\u0437c\3\2\2\2\u0438\u0439")
        buf.write("\7(\2\2\u0439\u043a\7\u0103\2\2\u043a\u043b\5\u011a\u008e")
        buf.write("\2\u043b\u043c\7\u0104\2\2\u043c\u0443\3\2\2\2\u043d\u043e")
        buf.write("\7(\2\2\u043e\u043f\7\u0103\2\2\u043f\u0440\5.\30\2\u0440")
        buf.write("\u0441\7\u0104\2\2\u0441\u0443\3\2\2\2\u0442\u0438\3\2")
        buf.write("\2\2\u0442\u043d\3\2\2\2\u0443e\3\2\2\2\u0444\u0445\7")
        buf.write(")\2\2\u0445\u0446\7\u0103\2\2\u0446\u0447\5.\30\2\u0447")
        buf.write("\u0448\7\u0104\2\2\u0448g\3\2\2\2\u0449\u044a\7*\2\2\u044a")
        buf.write("\u044b\7\u0103\2\2\u044b\u0454\7\u0104\2\2\u044c\u044d")
        buf.write("\7*\2\2\u044d\u044e\7\u0103\2\2\u044e\u044f\5\u01ae\u00d8")
        buf.write("\2\u044f\u0450\7\u010a\2\2\u0450\u0451\5\u0126\u0094\2")
        buf.write("\u0451\u0452\7\u0104\2\2\u0452\u0454\3\2\2\2\u0453\u0449")
        buf.write("\3\2\2\2\u0453\u044c\3\2\2\2\u0454i\3\2\2\2\u0455\u0456")
        buf.write("\7+\2\2\u0456\u0457\7\u0103\2\2\u0457\u0458\5\u01b8\u00dd")
        buf.write("\2\u0458\u0459\7\u0104\2\2\u0459\u0460\3\2\2\2\u045a\u045b")
        buf.write("\7+\2\2\u045b\u045c\7\u0103\2\2\u045c\u045d\5.\30\2\u045d")
        buf.write("\u045e\7\u0104\2\2\u045e\u0460\3\2\2\2\u045f\u0455\3\2")
        buf.write("\2\2\u045f\u045a\3\2\2\2\u0460k\3\2\2\2\u0461\u0462\7")
        buf.write(",\2\2\u0462\u0463\7\u0103\2\2\u0463\u046a\7\u0104\2\2")
        buf.write("\u0464\u0465\7,\2\2\u0465\u0466\7\u0103\2\2\u0466\u0467")
        buf.write("\5\u01b8\u00dd\2\u0467\u0468\7\u0104\2\2\u0468\u046a\3")
        buf.write("\2\2\2\u0469\u0461\3\2\2\2\u0469\u0464\3\2\2\2\u046am")
        buf.write("\3\2\2\2\u046b\u046c\7-\2\2\u046c\u046d\7\u0103\2\2\u046d")
        buf.write("\u0474\7\u0104\2\2\u046e\u046f\7-\2\2\u046f\u0470\7\u0103")
        buf.write("\2\2\u0470\u0471\5\u01b8\u00dd\2\u0471\u0472\7\u0104\2")
        buf.write("\2\u0472\u0474\3\2\2\2\u0473\u046b\3\2\2\2\u0473\u046e")
        buf.write("\3\2\2\2\u0474o\3\2\2\2\u0475\u0476\7.\2\2\u0476\u0477")
        buf.write("\7\u0103\2\2\u0477\u0478\5\u01b8\u00dd\2\u0478\u0479\7")
        buf.write("\u0104\2\2\u0479\u04b7\3\2\2\2\u047a\u047b\7.\2\2\u047b")
        buf.write("\u047c\7\u0103\2\2\u047c\u047d\5\u01b8\u00dd\2\u047d\u047e")
        buf.write("\7\u010a\2\2\u047e\u047f\5\u01ae\u00d8\2\u047f\u0480\7")
        buf.write("\u0104\2\2\u0480\u04b7\3\2\2\2\u0481\u0482\7.\2\2\u0482")
        buf.write("\u0483\7\u0103\2\2\u0483\u0484\5\u01b8\u00dd\2\u0484\u0485")
        buf.write("\7\u010a\2\2\u0485\u0486\5\u011a\u008e\2\u0486\u0487\7")
        buf.write("\u0104\2\2\u0487\u04b7\3\2\2\2\u0488\u0489\7.\2\2\u0489")
        buf.write("\u048a\7\u0103\2\2\u048a\u048b\5\u01b8\u00dd\2\u048b\u048c")
        buf.write("\7\u010a\2\2\u048c\u048d\5\u01b8\u00dd\2\u048d\u048e\7")
        buf.write("\u010a\2\2\u048e\u048f\5\u01ae\u00d8\2\u048f\u0490\7\u0104")
        buf.write("\2\2\u0490\u04b7\3\2\2\2\u0491\u0492\7.\2\2\u0492\u0493")
        buf.write("\7\u0103\2\2\u0493\u0494\5\u01b8\u00dd\2\u0494\u0495\7")
        buf.write("\u010a\2\2\u0495\u0496\5\u01b8\u00dd\2\u0496\u0497\7\u010a")
        buf.write("\2\2\u0497\u0498\5\u011a\u008e\2\u0498\u0499\7\u0104\2")
        buf.write("\2\u0499\u04b7\3\2\2\2\u049a\u049b\7.\2\2\u049b\u049c")
        buf.write("\7\u0103\2\2\u049c\u049d\5\u01b8\u00dd\2\u049d\u049e\7")
        buf.write("\u010a\2\2\u049e\u049f\5.\30\2\u049f\u04a0\7\u0104\2\2")
        buf.write("\u04a0\u04b7\3\2\2\2\u04a1\u04a2\7.\2\2\u04a2\u04a3\7")
        buf.write("\u0103\2\2\u04a3\u04a4\5\u010a\u0086\2\u04a4\u04a5\7\u010a")
        buf.write("\2\2\u04a5\u04a6\5\u01ae\u00d8\2\u04a6\u04a7\7\u0104\2")
        buf.write("\2\u04a7\u04b7\3\2\2\2\u04a8\u04a9\7.\2\2\u04a9\u04aa")
        buf.write("\7\u0103\2\2\u04aa\u04ab\5\u010a\u0086\2\u04ab\u04ac\7")
        buf.write("\u010a\2\2\u04ac\u04ad\5\u011a\u008e\2\u04ad\u04ae\7\u0104")
        buf.write("\2\2\u04ae\u04b7\3\2\2\2\u04af\u04b0\7.\2\2\u04b0\u04b1")
        buf.write("\7\u0103\2\2\u04b1\u04b2\5\u010a\u0086\2\u04b2\u04b3\7")
        buf.write("\u010a\2\2\u04b3\u04b4\5.\30\2\u04b4\u04b5\7\u0104\2\2")
        buf.write("\u04b5\u04b7\3\2\2\2\u04b6\u0475\3\2\2\2\u04b6\u047a\3")
        buf.write("\2\2\2\u04b6\u0481\3\2\2\2\u04b6\u0488\3\2\2\2\u04b6\u0491")
        buf.write("\3\2\2\2\u04b6\u049a\3\2\2\2\u04b6\u04a1\3\2\2\2\u04b6")
        buf.write("\u04a8\3\2\2\2\u04b6\u04af\3\2\2\2\u04b7q\3\2\2\2\u04b8")
        buf.write("\u04b9\7/\2\2\u04b9\u04ba\7\u0103\2\2\u04ba\u04bd\5\u01ae")
        buf.write("\u00d8\2\u04bb\u04bc\7\u010a\2\2\u04bc\u04be\5\u01a2\u00d2")
        buf.write("\2\u04bd\u04bb\3\2\2\2\u04bd\u04be\3\2\2\2\u04be\u04bf")
        buf.write("\3\2\2\2\u04bf\u04c0\7\u0104\2\2\u04c0\u04c7\3\2\2\2\u04c1")
        buf.write("\u04c2\7/\2\2\u04c2\u04c3\7\u0103\2\2\u04c3\u04c4\5\u011a")
        buf.write("\u008e\2\u04c4\u04c5\7\u0104\2\2\u04c5\u04c7\3\2\2\2\u04c6")
        buf.write("\u04b8\3\2\2\2\u04c6\u04c1\3\2\2\2\u04c7s\3\2\2\2\u04c8")
        buf.write("\u04c9\7\60\2\2\u04c9\u04ca\7\u0103\2\2\u04ca\u04cb\5")
        buf.write("\u011a\u008e\2\u04cb\u04cc\7\u0104\2\2\u04cc\u04d7\3\2")
        buf.write("\2\2\u04cd\u04ce\7\60\2\2\u04ce\u04cf\7\u0103\2\2\u04cf")
        buf.write("\u04d2\5\u01b8\u00dd\2\u04d0\u04d1\7\u010a\2\2\u04d1\u04d3")
        buf.write("\5\u01aa\u00d6\2\u04d2\u04d0\3\2\2\2\u04d2\u04d3\3\2\2")
        buf.write("\2\u04d3\u04d4\3\2\2\2\u04d4\u04d5\7\u0104\2\2\u04d5\u04d7")
        buf.write("\3\2\2\2\u04d6\u04c8\3\2\2\2\u04d6\u04cd\3\2\2\2\u04d7")
        buf.write("u\3\2\2\2\u04d8\u04d9\7\61\2\2\u04d9\u04da\7\u0103\2\2")
        buf.write("\u04da\u04db\5\u011a\u008e\2\u04db\u04dc\7\u0104\2\2\u04dc")
        buf.write("\u04e7\3\2\2\2\u04dd\u04de\7\61\2\2\u04de\u04df\7\u0103")
        buf.write("\2\2\u04df\u04e2\5\u01b8\u00dd\2\u04e0\u04e1\7\u010a\2")
        buf.write("\2\u04e1\u04e3\5\u01aa\u00d6\2\u04e2\u04e0\3\2\2\2\u04e2")
        buf.write("\u04e3\3\2\2\2\u04e3\u04e4\3\2\2\2\u04e4\u04e5\7\u0104")
        buf.write("\2\2\u04e5\u04e7\3\2\2\2\u04e6\u04d8\3\2\2\2\u04e6\u04dd")
        buf.write("\3\2\2\2\u04e7w\3\2\2\2\u04e8\u04e9\7\62\2\2\u04e9\u04ea")
        buf.write("\7\u0103\2\2\u04ea\u04eb\5\u01b8\u00dd\2\u04eb\u04ec\7")
        buf.write("\u0104\2\2\u04ecy\3\2\2\2\u04ed\u04ee\7\63\2\2\u04ee\u04ef")
        buf.write("\7\u0103\2\2\u04ef\u04f2\5\u01ae\u00d8\2\u04f0\u04f1\7")
        buf.write("\u010a\2\2\u04f1\u04f3\5\u01a2\u00d2\2\u04f2\u04f0\3\2")
        buf.write("\2\2\u04f2\u04f3\3\2\2\2\u04f3\u04f4\3\2\2\2\u04f4\u04f5")
        buf.write("\7\u0104\2\2\u04f5\u04fc\3\2\2\2\u04f6\u04f7\7\63\2\2")
        buf.write("\u04f7\u04f8\7\u0103\2\2\u04f8\u04f9\5\u011a\u008e\2\u04f9")
        buf.write("\u04fa\7\u0104\2\2\u04fa\u04fc\3\2\2\2\u04fb\u04ed\3\2")
        buf.write("\2\2\u04fb\u04f6\3\2\2\2\u04fc{\3\2\2\2\u04fd\u04fe\7")
        buf.write("\64\2\2\u04fe\u04ff\7\u0103\2\2\u04ff\u0500\7\u0104\2")
        buf.write("\2\u0500}\3\2\2\2\u0501\u0502\7\65\2\2\u0502\u0503\7\u0103")
        buf.write("\2\2\u0503\u0504\7\u0104\2\2\u0504\177\3\2\2\2\u0505\u0506")
        buf.write("\7\66\2\2\u0506\u0507\7\u0103\2\2\u0507\u0508\5\u01aa")
        buf.write("\u00d6\2\u0508\u0509\7\u0104\2\2\u0509\u0081\3\2\2\2\u050a")
        buf.write("\u050b\7\67\2\2\u050b\u050c\7\u0103\2\2\u050c\u050d\5")
        buf.write("\u01aa\u00d6\2\u050d\u050e\7\u0104\2\2\u050e\u0083\3\2")
        buf.write("\2\2\u050f\u0510\78\2\2\u0510\u0511\7\u0103\2\2\u0511")
        buf.write("\u0512\7\u0104\2\2\u0512\u0085\3\2\2\2\u0513\u0514\79")
        buf.write("\2\2\u0514\u0515\7\u0103\2\2\u0515\u0516\7\u0104\2\2\u0516")
        buf.write("\u0087\3\2\2\2\u0517\u0518\7\21\2\2\u0518\u0519\7\u0103")
        buf.write("\2\2\u0519\u051a\5\u01a2\u00d2\2\u051a\u051b\7\u0104\2")
        buf.write("\2\u051b\u0089\3\2\2\2\u051c\u051d\7:\2\2\u051d\u051e")
        buf.write("\7\u0103\2\2\u051e\u051f\5\u01ae\u00d8\2\u051f\u0520\7")
        buf.write("\u0104\2\2\u0520\u0527\3\2\2\2\u0521\u0522\7:\2\2\u0522")
        buf.write("\u0523\7\u0103\2\2\u0523\u0524\5\u011a\u008e\2\u0524\u0525")
        buf.write("\7\u0104\2\2\u0525\u0527\3\2\2\2\u0526\u051c\3\2\2\2\u0526")
        buf.write("\u0521\3\2\2\2\u0527\u008b\3\2\2\2\u0528\u0529\7;\2\2")
        buf.write("\u0529\u052a\7\u0103\2\2\u052a\u052b\7\u0104\2\2\u052b")
        buf.write("\u008d\3\2\2\2\u052c\u052d\7<\2\2\u052d\u052e\7\u0103")
        buf.write("\2\2\u052e\u052f\7\u0104\2\2\u052f\u008f\3\2\2\2\u0530")
        buf.write("\u0531\7=\2\2\u0531\u0532\7\u0103\2\2\u0532\u0533\5\u0108")
        buf.write("\u0085\2\u0533\u0534\7\u010a\2\2\u0534\u0535\5\u01b2\u00da")
        buf.write("\2\u0535\u0536\7\u0104\2\2\u0536\u053d\3\2\2\2\u0537\u0538")
        buf.write("\7=\2\2\u0538\u0539\7\u0103\2\2\u0539\u053a\5\u01b2\u00da")
        buf.write("\2\u053a\u053b\7\u0104\2\2\u053b\u053d\3\2\2\2\u053c\u0530")
        buf.write("\3\2\2\2\u053c\u0537\3\2\2\2\u053d\u0091\3\2\2\2\u053e")
        buf.write("\u053f\7>\2\2\u053f\u0540\7\u0103\2\2\u0540\u0541\5.\30")
        buf.write("\2\u0541\u0542\7\u0104\2\2\u0542\u0093\3\2\2\2\u0543\u0544")
        buf.write("\7?\2\2\u0544\u0545\7\u0103\2\2\u0545\u054c\7\u0104\2")
        buf.write("\2\u0546\u0547\7?\2\2\u0547\u0548\7\u0103\2\2\u0548\u0549")
        buf.write("\5\u01b8\u00dd\2\u0549\u054a\7\u0104\2\2\u054a\u054c\3")
        buf.write("\2\2\2\u054b\u0543\3\2\2\2\u054b\u0546\3\2\2\2\u054c\u0095")
        buf.write("\3\2\2\2\u054d\u054e\7@\2\2\u054e\u054f\7\u0103\2\2\u054f")
        buf.write("\u0550\5.\30\2\u0550\u0551\7\u0104\2\2\u0551\u0097\3\2")
        buf.write("\2\2\u0552\u0553\7A\2\2\u0553\u0554\7\u0103\2\2\u0554")
        buf.write("\u0555\5\u019e\u00d0\2\u0555\u0556\7\u0104\2\2\u0556\u0099")
        buf.write("\3\2\2\2\u0557\u0558\7B\2\2\u0558\u0559\7\u0103\2\2\u0559")
        buf.write("\u055a\5\u01b8\u00dd\2\u055a\u055b\7\u0104\2\2\u055b\u009b")
        buf.write("\3\2\2\2\u055c\u055d\7C\2\2\u055d\u055e\7\u0103\2\2\u055e")
        buf.write("\u0565\7\u0104\2\2\u055f\u0560\7C\2\2\u0560\u0561\7\u0103")
        buf.write("\2\2\u0561\u0562\5\u0108\u0085\2\u0562\u0563\7\u0104\2")
        buf.write("\2\u0563\u0565\3\2\2\2\u0564\u055c\3\2\2\2\u0564\u055f")
        buf.write("\3\2\2\2\u0565\u009d\3\2\2\2\u0566\u0567\7D\2\2\u0567")
        buf.write("\u0568\7\u0103\2\2\u0568\u056f\7\u0104\2\2\u0569\u056a")
        buf.write("\7D\2\2\u056a\u056b\7\u0103\2\2\u056b\u056c\5\u0108\u0085")
        buf.write("\2\u056c\u056d\7\u0104\2\2\u056d\u056f\3\2\2\2\u056e\u0566")
        buf.write("\3\2\2\2\u056e\u0569\3\2\2\2\u056f\u009f\3\2\2\2\u0570")
        buf.write("\u0571\7E\2\2\u0571\u0572\7\u0103\2\2\u0572\u0579\7\u0104")
        buf.write("\2\2\u0573\u0574\7E\2\2\u0574\u0575\7\u0103\2\2\u0575")
        buf.write("\u0576\5\u0108\u0085\2\u0576\u0577\7\u0104\2\2\u0577\u0579")
        buf.write("\3\2\2\2\u0578\u0570\3\2\2\2\u0578\u0573\3\2\2\2\u0579")
        buf.write("\u00a1\3\2\2\2\u057a\u057b\7F\2\2\u057b\u057c\7\u0103")
        buf.write("\2\2\u057c\u057d\5.\30\2\u057d\u057e\7\u0104\2\2\u057e")
        buf.write("\u00a3\3\2\2\2\u057f\u0580\7G\2\2\u0580\u0581\7\u0103")
        buf.write("\2\2\u0581\u0582\5\u011a\u008e\2\u0582\u0583\7\u010a\2")
        buf.write("\2\u0583\u0584\5.\30\2\u0584\u0585\7\u0104\2\2\u0585\u0593")
        buf.write("\3\2\2\2\u0586\u0587\7G\2\2\u0587\u0588\7\u0103\2\2\u0588")
        buf.write("\u0589\5\u01ae\u00d8\2\u0589\u058a\7\u010a\2\2\u058a\u058b")
        buf.write("\5.\30\2\u058b\u058c\7\u0104\2\2\u058c\u0593\3\2\2\2\u058d")
        buf.write("\u058e\7G\2\2\u058e\u058f\7\u0103\2\2\u058f\u0590\5.\30")
        buf.write("\2\u0590\u0591\7\u0104\2\2\u0591\u0593\3\2\2\2\u0592\u057f")
        buf.write("\3\2\2\2\u0592\u0586\3\2\2\2\u0592\u058d\3\2\2\2\u0593")
        buf.write("\u00a5\3\2\2\2\u0594\u0595\7H\2\2\u0595\u0596\7\u0103")
        buf.write("\2\2\u0596\u0597\5.\30\2\u0597\u0598\7\u0104\2\2\u0598")
        buf.write("\u00a7\3\2\2\2\u0599\u059a\7I\2\2\u059a\u059b\7\u0103")
        buf.write("\2\2\u059b\u059c\5\u019e\u00d0\2\u059c\u059d\7\u0104\2")
        buf.write("\2\u059d\u00a9\3\2\2\2\u059e\u059f\7J\2\2\u059f\u05a0")
        buf.write("\7\u0103\2\2\u05a0\u05a7\7\u0104\2\2\u05a1\u05a2\7J\2")
        buf.write("\2\u05a2\u05a3\7\u0103\2\2\u05a3\u05a4\5\u0108\u0085\2")
        buf.write("\u05a4\u05a5\7\u0104\2\2\u05a5\u05a7\3\2\2\2\u05a6\u059e")
        buf.write("\3\2\2\2\u05a6\u05a1\3\2\2\2\u05a7\u00ab\3\2\2\2\u05a8")
        buf.write("\u05a9\7K\2\2\u05a9\u05aa\7\u0103\2\2\u05aa\u05ab\7\u0104")
        buf.write("\2\2\u05ab\u00ad\3\2\2\2\u05ac\u05ad\7L\2\2\u05ad\u05ae")
        buf.write("\7\u0103\2\2\u05ae\u05af\5\u01aa\u00d6\2\u05af\u05b0\7")
        buf.write("\u0104\2\2\u05b0\u00af\3\2\2\2\u05b1\u05b2\7M\2\2\u05b2")
        buf.write("\u05b3\7\u0103\2\2\u05b3\u05b4\5\u01aa\u00d6\2\u05b4\u05b5")
        buf.write("\7\u0104\2\2\u05b5\u00b1\3\2\2\2\u05b6\u05b7\7N\2\2\u05b7")
        buf.write("\u05b8\7\u0103\2\2\u05b8\u05b9\7\u0104\2\2\u05b9\u00b3")
        buf.write("\3\2\2\2\u05ba\u05bb\7O\2\2\u05bb\u05bc\7\u0103\2\2\u05bc")
        buf.write("\u05c3\7\u0104\2\2\u05bd\u05be\7O\2\2\u05be\u05bf\7\u0103")
        buf.write("\2\2\u05bf\u05c0\5\u01b4\u00db\2\u05c0\u05c1\7\u0104\2")
        buf.write("\2\u05c1\u05c3\3\2\2\2\u05c2\u05ba\3\2\2\2\u05c2\u05bd")
        buf.write("\3\2\2\2\u05c3\u00b5\3\2\2\2\u05c4\u05c5\7P\2\2\u05c5")
        buf.write("\u05c6\7\u0103\2\2\u05c6\u05c7\7\u0104\2\2\u05c7\u00b7")
        buf.write("\3\2\2\2\u05c8\u05c9\7Q\2\2\u05c9\u05ca\7\u0103\2\2\u05ca")
        buf.write("\u05cb\7\u0104\2\2\u05cb\u00b9\3\2\2\2\u05cc\u05cd\7R")
        buf.write("\2\2\u05cd\u05ce\7\u0103\2\2\u05ce\u05d5\7\u0104\2\2\u05cf")
        buf.write("\u05d0\7R\2\2\u05d0\u05d1\7\u0103\2\2\u05d1\u05d2\5\u01b8")
        buf.write("\u00dd\2\u05d2\u05d3\7\u0104\2\2\u05d3\u05d5\3\2\2\2\u05d4")
        buf.write("\u05cc\3\2\2\2\u05d4\u05cf\3\2\2\2\u05d5\u00bb\3\2\2\2")
        buf.write("\u05d6\u05d7\7S\2\2\u05d7\u05d8\7\u0103\2\2\u05d8\u05db")
        buf.write("\5\u01b8\u00dd\2\u05d9\u05da\7\u010a\2\2\u05da\u05dc\5")
        buf.write("\u01aa\u00d6\2\u05db\u05d9\3\2\2\2\u05db\u05dc\3\2\2\2")
        buf.write("\u05dc\u05dd\3\2\2\2\u05dd\u05de\7\u0104\2\2\u05de\u00bd")
        buf.write("\3\2\2\2\u05df\u05e0\7T\2\2\u05e0\u05e1\7\u0103\2\2\u05e1")
        buf.write("\u05e2\5\u01aa\u00d6\2\u05e2\u05e3\7\u0104\2\2\u05e3\u00bf")
        buf.write("\3\2\2\2\u05e4\u05e5\7U\2\2\u05e5\u05e6\7\u0103\2\2\u05e6")
        buf.write("\u05e7\5\u0110\u0089\2\u05e7\u05e8\7\u010a\2\2\u05e8\u05e9")
        buf.write("\5\u01ae\u00d8\2\u05e9\u05ea\7\u010a\2\2\u05ea\u05ed\5")
        buf.write("\u01ae\u00d8\2\u05eb\u05ec\7\u010a\2\2\u05ec\u05ee\5\u01a2")
        buf.write("\u00d2\2\u05ed\u05eb\3\2\2\2\u05ed\u05ee\3\2\2\2\u05ee")
        buf.write("\u05ef\3\2\2\2\u05ef\u05f0\7\u0104\2\2\u05f0\u05fd\3\2")
        buf.write("\2\2\u05f1\u05f2\7U\2\2\u05f2\u05f3\7\u0103\2\2\u05f3")
        buf.write("\u05f4\5\u01ae\u00d8\2\u05f4\u05f5\7\u010a\2\2\u05f5\u05f8")
        buf.write("\5\u01ae\u00d8\2\u05f6\u05f7\7\u010a\2\2\u05f7\u05f9\5")
        buf.write("\u01a2\u00d2\2\u05f8\u05f6\3\2\2\2\u05f8\u05f9\3\2\2\2")
        buf.write("\u05f9\u05fa\3\2\2\2\u05fa\u05fb\7\u0104\2\2\u05fb\u05fd")
        buf.write("\3\2\2\2\u05fc\u05e4\3\2\2\2\u05fc\u05f1\3\2\2\2\u05fd")
        buf.write("\u00c1\3\2\2\2\u05fe\u05ff\7V\2\2\u05ff\u0600\7\u0103")
        buf.write("\2\2\u0600\u0601\5\u01aa\u00d6\2\u0601\u0602\7\u0104\2")
        buf.write("\2\u0602\u00c3\3\2\2\2\u0603\u0604\7W\2\2\u0604\u0605")
        buf.write("\7\u0103\2\2\u0605\u0606\5\u0108\u0085\2\u0606\u0607\7")
        buf.write("\u010a\2\2\u0607\u0608\5\u01b2\u00da\2\u0608\u0609\7\u010a")
        buf.write("\2\2\u0609\u060a\5\u01b2\u00da\2\u060a\u060b\7\u0104\2")
        buf.write("\2\u060b\u0614\3\2\2\2\u060c\u060d\7W\2\2\u060d\u060e")
        buf.write("\7\u0103\2\2\u060e\u060f\5\u01b2\u00da\2\u060f\u0610\7")
        buf.write("\u010a\2\2\u0610\u0611\5\u01b2\u00da\2\u0611\u0612\7\u0104")
        buf.write("\2\2\u0612\u0614\3\2\2\2\u0613\u0603\3\2\2\2\u0613\u060c")
        buf.write("\3\2\2\2\u0614\u00c5\3\2\2\2\u0615\u0616\7X\2\2\u0616")
        buf.write("\u0617\7\u0103\2\2\u0617\u0618\7\u0104\2\2\u0618\u00c7")
        buf.write("\3\2\2\2\u0619\u061a\7Y\2\2\u061a\u061b\7\u0103\2\2\u061b")
        buf.write("\u061c\5\u01b8\u00dd\2\u061c\u061d\7\u010a\2\2\u061d\u061e")
        buf.write("\5.\30\2\u061e\u061f\7\u0104\2\2\u061f\u0626\3\2\2\2\u0620")
        buf.write("\u0621\7Y\2\2\u0621\u0622\7\u0103\2\2\u0622\u0623\5.\30")
        buf.write("\2\u0623\u0624\7\u0104\2\2\u0624\u0626\3\2\2\2\u0625\u0619")
        buf.write("\3\2\2\2\u0625\u0620\3\2\2\2\u0626\u00c9\3\2\2\2\u0627")
        buf.write("\u0628\7Z\2\2\u0628\u0629\7\u0103\2\2\u0629\u062a\5\u0126")
        buf.write("\u0094\2\u062a\u062b\7\u0104\2\2\u062b\u0630\3\2\2\2\u062c")
        buf.write("\u062d\7Z\2\2\u062d\u062e\7\u0103\2\2\u062e\u0630\7\u0104")
        buf.write("\2\2\u062f\u0627\3\2\2\2\u062f\u062c\3\2\2\2\u0630\u00cb")
        buf.write("\3\2\2\2\u0631\u0632\7[\2\2\u0632\u0633\7\u0103\2\2\u0633")
        buf.write("\u0634\5\u0108\u0085\2\u0634\u0635\7\u010a\2\2\u0635\u0636")
        buf.write("\5\u01b2\u00da\2\u0636\u0637\7\u0104\2\2\u0637\u063e\3")
        buf.write("\2\2\2\u0638\u0639\7[\2\2\u0639\u063a\7\u0103\2\2\u063a")
        buf.write("\u063b\5\u01b2\u00da\2\u063b\u063c\7\u0104\2\2\u063c\u063e")
        buf.write("\3\2\2\2\u063d\u0631\3\2\2\2\u063d\u0638\3\2\2\2\u063e")
        buf.write("\u00cd\3\2\2\2\u063f\u0640\7\\\2\2\u0640\u0641\7\u0103")
        buf.write("\2\2\u0641\u0642\5\u0112\u008a\2\u0642\u0643\7\u0104\2")
        buf.write("\2\u0643\u0675\3\2\2\2\u0644\u0645\7\\\2\2\u0645\u0646")
        buf.write("\7\u0103\2\2\u0646\u0647\5\u0114\u008b\2\u0647\u0648\7")
        buf.write("\u010a\2\2\u0648\u0649\5\u01b8\u00dd\2\u0649\u064a\7\u0104")
        buf.write("\2\2\u064a\u0675\3\2\2\2\u064b\u064c\7\\\2\2\u064c\u064d")
        buf.write("\7\u0103\2\2\u064d\u064e\5\u0114\u008b\2\u064e\u064f\7")
        buf.write("\u010a\2\2\u064f\u0650\5\u01b8\u00dd\2\u0650\u0651\7\u010a")
        buf.write("\2\2\u0651\u0654\5\u01b8\u00dd\2\u0652\u0653\7\u010a\2")
        buf.write("\2\u0653\u0655\5\u01aa\u00d6\2\u0654\u0652\3\2\2\2\u0654")
        buf.write("\u0655\3\2\2\2\u0655\u0656\3\2\2\2\u0656\u0657\7\u0104")
        buf.write("\2\2\u0657\u0675\3\2\2\2\u0658\u0659\7\\\2\2\u0659\u065a")
        buf.write("\7\u0103\2\2\u065a\u065b\5\u0114\u008b\2\u065b\u065c\7")
        buf.write("\u010a\2\2\u065c\u065d\5.\30\2\u065d\u065e\7\u0104\2\2")
        buf.write("\u065e\u0675\3\2\2\2\u065f\u0660\7\\\2\2\u0660\u0661\7")
        buf.write("\u0103\2\2\u0661\u0662\5\u01b8\u00dd\2\u0662\u0663\7\u0104")
        buf.write("\2\2\u0663\u0675\3\2\2\2\u0664\u0665\7\\\2\2\u0665\u0666")
        buf.write("\7\u0103\2\2\u0666\u0667\5\u01b8\u00dd\2\u0667\u0668\7")
        buf.write("\u010a\2\2\u0668\u066b\5\u01b8\u00dd\2\u0669\u066a\7\u010a")
        buf.write("\2\2\u066a\u066c\5\u01aa\u00d6\2\u066b\u0669\3\2\2\2\u066b")
        buf.write("\u066c\3\2\2\2\u066c\u066d\3\2\2\2\u066d\u066e\7\u0104")
        buf.write("\2\2\u066e\u0675\3\2\2\2\u066f\u0670\7\\\2\2\u0670\u0671")
        buf.write("\7\u0103\2\2\u0671\u0672\5.\30\2\u0672\u0673\7\u0104\2")
        buf.write("\2\u0673\u0675\3\2\2\2\u0674\u063f\3\2\2\2\u0674\u0644")
        buf.write("\3\2\2\2\u0674\u064b\3\2\2\2\u0674\u0658\3\2\2\2\u0674")
        buf.write("\u065f\3\2\2\2\u0674\u0664\3\2\2\2\u0674\u066f\3\2\2\2")
        buf.write("\u0675\u00cf\3\2\2\2\u0676\u0677\7]\2\2\u0677\u0678\7")
        buf.write("\u0103\2\2\u0678\u0679\7\u0104\2\2\u0679\u00d1\3\2\2\2")
        buf.write("\u067a\u067b\7^\2\2\u067b\u067c\7\u0103\2\2\u067c\u067d")
        buf.write("\5.\30\2\u067d\u067e\7\u0104\2\2\u067e\u00d3\3\2\2\2\u067f")
        buf.write("\u0680\7_\2\2\u0680\u0681\7\u0103\2\2\u0681\u0682\7\u0104")
        buf.write("\2\2\u0682\u00d5\3\2\2\2\u0683\u0684\7`\2\2\u0684\u0685")
        buf.write("\7\u0103\2\2\u0685\u0686\5\u0108\u0085\2\u0686\u0687\7")
        buf.write("\u010a\2\2\u0687\u0688\5\u01b2\u00da\2\u0688\u0689\7\u0104")
        buf.write("\2\2\u0689\u0690\3\2\2\2\u068a\u068b\7`\2\2\u068b\u068c")
        buf.write("\7\u0103\2\2\u068c\u068d\5\u01b2\u00da\2\u068d\u068e\7")
        buf.write("\u0104\2\2\u068e\u0690\3\2\2\2\u068f\u0683\3\2\2\2\u068f")
        buf.write("\u068a\3\2\2\2\u0690\u00d7\3\2\2\2\u0691\u0692\7a\2\2")
        buf.write("\u0692\u0693\7\u0103\2\2\u0693\u0694\5\u01b8\u00dd\2\u0694")
        buf.write("\u0695\7\u0104\2\2\u0695\u00d9\3\2\2\2\u0696\u0697\7b")
        buf.write("\2\2\u0697\u0698\7\u0103\2\2\u0698\u0699\5\u01b8\u00dd")
        buf.write("\2\u0699\u069a\7\u0104\2\2\u069a\u00db\3\2\2\2\u069b\u069c")
        buf.write("\7c\2\2\u069c\u069d\7\u0103\2\2\u069d\u06a4\7\u0104\2")
        buf.write("\2\u069e\u069f\7c\2\2\u069f\u06a0\7\u0103\2\2\u06a0\u06a1")
        buf.write("\5\u0108\u0085\2\u06a1\u06a2\7\u0104\2\2\u06a2\u06a4\3")
        buf.write("\2\2\2\u06a3\u069b\3\2\2\2\u06a3\u069e\3\2\2\2\u06a4\u00dd")
        buf.write("\3\2\2\2\u06a5\u06a6\7d\2\2\u06a6\u06a7\7\u0103\2\2\u06a7")
        buf.write("\u06ba\7\u0104\2\2\u06a8\u06a9\7d\2\2\u06a9\u06aa\7\u0103")
        buf.write("\2\2\u06aa\u06ab\5\u0108\u0085\2\u06ab\u06ac\7\u0104\2")
        buf.write("\2\u06ac\u06ba\3\2\2\2\u06ad\u06ae\7d\2\2\u06ae\u06af")
        buf.write("\7\u0103\2\2\u06af\u06b0\5\u0108\u0085\2\u06b0\u06b1\7")
        buf.write("\u010a\2\2\u06b1\u06b2\5\u01b2\u00da\2\u06b2\u06b3\7\u0104")
        buf.write("\2\2\u06b3\u06ba\3\2\2\2\u06b4\u06b5\7d\2\2\u06b5\u06b6")
        buf.write("\7\u0103\2\2\u06b6\u06b7\5\u01b2\u00da\2\u06b7\u06b8\7")
        buf.write("\u0104\2\2\u06b8\u06ba\3\2\2\2\u06b9\u06a5\3\2\2\2\u06b9")
        buf.write("\u06a8\3\2\2\2\u06b9\u06ad\3\2\2\2\u06b9\u06b4\3\2\2\2")
        buf.write("\u06ba\u00df\3\2\2\2\u06bb\u06bc\7e\2\2\u06bc\u06bd\7")
        buf.write("\u0103\2\2\u06bd\u06be\5\u01b2\u00da\2\u06be\u06bf\7\u0104")
        buf.write("\2\2\u06bf\u00e1\3\2\2\2\u06c0\u06c1\7f\2\2\u06c1\u06c2")
        buf.write("\7\u0103\2\2\u06c2\u06c3\5\u01b2\u00da\2\u06c3\u06c4\7")
        buf.write("\u0104\2\2\u06c4\u00e3\3\2\2\2\u06c5\u06c6\7g\2\2\u06c6")
        buf.write("\u06c7\7\u0103\2\2\u06c7\u06ca\5\u010e\u0088\2\u06c8\u06c9")
        buf.write("\7\u010a\2\2\u06c9\u06cb\5\u01aa\u00d6\2\u06ca\u06c8\3")
        buf.write("\2\2\2\u06ca\u06cb\3\2\2\2\u06cb\u06cc\3\2\2\2\u06cc\u06cd")
        buf.write("\7\u0104\2\2\u06cd\u06d9\3\2\2\2\u06ce\u06cf\7g\2\2\u06cf")
        buf.write("\u06d0\7\u0103\2\2\u06d0\u06d1\5\u01b8\u00dd\2\u06d1\u06d2")
        buf.write("\7\u0104\2\2\u06d2\u06d9\3\2\2\2\u06d3\u06d4\7g\2\2\u06d4")
        buf.write("\u06d5\7\u0103\2\2\u06d5\u06d6\5.\30\2\u06d6\u06d7\7\u0104")
        buf.write("\2\2\u06d7\u06d9\3\2\2\2\u06d8\u06c5\3\2\2\2\u06d8\u06ce")
        buf.write("\3\2\2\2\u06d8\u06d3\3\2\2\2\u06d9\u00e5\3\2\2\2\u06da")
        buf.write("\u06db\7h\2\2\u06db\u06dc\7\u0103\2\2\u06dc\u06df\5\u010e")
        buf.write("\u0088\2\u06dd\u06de\7\u010a\2\2\u06de\u06e0\5\u01aa\u00d6")
        buf.write("\2\u06df\u06dd\3\2\2\2\u06df\u06e0\3\2\2\2\u06e0\u06e1")
        buf.write("\3\2\2\2\u06e1\u06e2\7\u0104\2\2\u06e2\u00e7\3\2\2\2\u06e3")
        buf.write("\u06e4\7i\2\2\u06e4\u06e5\7\u0103\2\2\u06e5\u06e6\5\u010e")
        buf.write("\u0088\2\u06e6\u06e7\7\u0104\2\2\u06e7\u00e9\3\2\2\2\u06e8")
        buf.write("\u06e9\7j\2\2\u06e9\u06ea\7\u0103\2\2\u06ea\u06f1\7\u0104")
        buf.write("\2\2\u06eb\u06ec\7j\2\2\u06ec\u06ed\7\u0103\2\2\u06ed")
        buf.write("\u06ee\5\u01b8\u00dd\2\u06ee\u06ef\7\u0104\2\2\u06ef\u06f1")
        buf.write("\3\2\2\2\u06f0\u06e8\3\2\2\2\u06f0\u06eb\3\2\2\2\u06f1")
        buf.write("\u00eb\3\2\2\2\u06f2\u06f3\7k\2\2\u06f3\u06f4\7\u0103")
        buf.write("\2\2\u06f4\u06f5\7\u0104\2\2\u06f5\u00ed\3\2\2\2\u06f6")
        buf.write("\u06f7\7l\2\2\u06f7\u06f8\7\u0103\2\2\u06f8\u06f9\5\u019e")
        buf.write("\u00d0\2\u06f9\u06fa\7\u0104\2\2\u06fa\u00ef\3\2\2\2\u06fb")
        buf.write("\u06fc\7m\2\2\u06fc\u06fd\7\u0103\2\2\u06fd\u06fe\5\u011a")
        buf.write("\u008e\2\u06fe\u06ff\7\u0104\2\2\u06ff\u0706\3\2\2\2\u0700")
        buf.write("\u0701\7m\2\2\u0701\u0702\7\u0103\2\2\u0702\u0703\5.\30")
        buf.write("\2\u0703\u0704\7\u0104\2\2\u0704\u0706\3\2\2\2\u0705\u06fb")
        buf.write("\3\2\2\2\u0705\u0700\3\2\2\2\u0706\u00f1\3\2\2\2\u0707")
        buf.write("\u0708\7n\2\2\u0708\u0709\7\u0103\2\2\u0709\u070a\7\u0104")
        buf.write("\2\2\u070a\u00f3\3\2\2\2\u070b\u070c\7o\2\2\u070c\u070d")
        buf.write("\7\u0103\2\2\u070d\u070e\5\u01aa\u00d6\2\u070e\u070f\7")
        buf.write("\u0104\2\2\u070f\u071a\3\2\2\2\u0710\u0711\7o\2\2\u0711")
        buf.write("\u0712\7\u0103\2\2\u0712\u0715\5\u01b6\u00dc\2\u0713\u0714")
        buf.write("\7\u010a\2\2\u0714\u0716\5\u01aa\u00d6\2\u0715\u0713\3")
        buf.write("\2\2\2\u0715\u0716\3\2\2\2\u0716\u0717\3\2\2\2\u0717\u0718")
        buf.write("\7\u0104\2\2\u0718\u071a\3\2\2\2\u0719\u070b\3\2\2\2\u0719")
        buf.write("\u0710\3\2\2\2\u071a\u00f5\3\2\2\2\u071b\u071c\7p\2\2")
        buf.write("\u071c\u071d\7\u0103\2\2\u071d\u071e\5\u01aa\u00d6\2\u071e")
        buf.write("\u071f\7\u0104\2\2\u071f\u00f7\3\2\2\2\u0720\u0721\7q")
        buf.write("\2\2\u0721\u0722\7\u0103\2\2\u0722\u0723\5\u011a\u008e")
        buf.write("\2\u0723\u0724\7\u0104\2\2\u0724\u0732\3\2\2\2\u0725\u0726")
        buf.write("\7q\2\2\u0726\u0727\7\u0103\2\2\u0727\u0728\5\u01b8\u00dd")
        buf.write("\2\u0728\u0729\7\u010a\2\2\u0729\u072a\5\u011a\u008e\2")
        buf.write("\u072a\u072b\7\u0104\2\2\u072b\u0732\3\2\2\2\u072c\u072d")
        buf.write("\7q\2\2\u072d\u072e\7\u0103\2\2\u072e\u072f\5.\30\2\u072f")
        buf.write("\u0730\7\u0104\2\2\u0730\u0732\3\2\2\2\u0731\u0720\3\2")
        buf.write("\2\2\u0731\u0725\3\2\2\2\u0731\u072c\3\2\2\2\u0732\u00f9")
        buf.write("\3\2\2\2\u0733\u0734\7\f\2\2\u0734\u0735\7\u0103\2\2\u0735")
        buf.write("\u0736\5\u01b8\u00dd\2\u0736\u0737\7\u0104\2\2\u0737\u0740")
        buf.write("\3\2\2\2\u0738\u0739\7\f\2\2\u0739\u073a\7\u0103\2\2\u073a")
        buf.write("\u073b\5\u01b8\u00dd\2\u073b\u073c\7\u010a\2\2\u073c\u073d")
        buf.write("\5\u01ae\u00d8\2\u073d\u073e\7\u0104\2\2\u073e\u0740\3")
        buf.write("\2\2\2\u073f\u0733\3\2\2\2\u073f\u0738\3\2\2\2\u0740\u00fb")
        buf.write("\3\2\2\2\u0741\u0742\7r\2\2\u0742\u0743\7\u0103\2\2\u0743")
        buf.write("\u0744\7\u0104\2\2\u0744\u00fd\3\2\2\2\u0745\u0746\7\u00fc")
        buf.write("\2\2\u0746\u0747\7s\2\2\u0747\u0749\7\u0103\2\2\u0748")
        buf.write("\u074a\5\u0100\u0081\2\u0749\u0748\3\2\2\2\u0749\u074a")
        buf.write("\3\2\2\2\u074a\u074f\3\2\2\2\u074b\u074c\7\u010a\2\2\u074c")
        buf.write("\u074e\5\u0100\u0081\2\u074d\u074b\3\2\2\2\u074e\u0751")
        buf.write("\3\2\2\2\u074f\u074d\3\2\2\2\u074f\u0750\3\2\2\2\u0750")
        buf.write("\u0752\3\2\2\2\u0751\u074f\3\2\2\2\u0752\u0785\7\u0104")
        buf.write("\2\2\u0753\u0754\7\u00fc\2\2\u0754\u0755\7t\2\2\u0755")
        buf.write("\u0756\7\u0103\2\2\u0756\u0757\5\u01b2\u00da\2\u0757\u0758")
        buf.write("\7\u0104\2\2\u0758\u0785\3\2\2\2\u0759\u075a\7\u00fc\2")
        buf.write("\2\u075a\u075b\7u\2\2\u075b\u075d\7\u0103\2\2\u075c\u075e")
        buf.write("\5\u0102\u0082\2\u075d\u075c\3\2\2\2\u075d\u075e\3\2\2")
        buf.write("\2\u075e\u0763\3\2\2\2\u075f\u0760\7\u010a\2\2\u0760\u0762")
        buf.write("\5\u0102\u0082\2\u0761\u075f\3\2\2\2\u0762\u0765\3\2\2")
        buf.write("\2\u0763\u0761\3\2\2\2\u0763\u0764\3\2\2\2\u0764\u0766")
        buf.write("\3\2\2\2\u0765\u0763\3\2\2\2\u0766\u0785\7\u0104\2\2\u0767")
        buf.write("\u0768\7\u00fc\2\2\u0768\u0769\7v\2\2\u0769\u076b\7\u0103")
        buf.write("\2\2\u076a\u076c\5\u0104\u0083\2\u076b\u076a\3\2\2\2\u076b")
        buf.write("\u076c\3\2\2\2\u076c\u0771\3\2\2\2\u076d\u076e\7\u010a")
        buf.write("\2\2\u076e\u0770\5\u0104\u0083\2\u076f\u076d\3\2\2\2\u0770")
        buf.write("\u0773\3\2\2\2\u0771\u076f\3\2\2\2\u0771\u0772\3\2\2\2")
        buf.write("\u0772\u0774\3\2\2\2\u0773\u0771\3\2\2\2\u0774\u0785\7")
        buf.write("\u0104\2\2\u0775\u0785\7w\2\2\u0776\u0777\7\u00fc\2\2")
        buf.write("\u0777\u0778\7x\2\2\u0778\u077a\7\u0103\2\2\u0779\u077b")
        buf.write("\5\u0106\u0084\2\u077a\u0779\3\2\2\2\u077a\u077b\3\2\2")
        buf.write("\2\u077b\u0780\3\2\2\2\u077c\u077d\7\u010a\2\2\u077d\u077f")
        buf.write("\5\u0106\u0084\2\u077e\u077c\3\2\2\2\u077f\u0782\3\2\2")
        buf.write("\2\u0780\u077e\3\2\2\2\u0780\u0781\3\2\2\2\u0781\u0783")
        buf.write("\3\2\2\2\u0782\u0780\3\2\2\2\u0783\u0785\7\u0104\2\2\u0784")
        buf.write("\u0745\3\2\2\2\u0784\u0753\3\2\2\2\u0784\u0759\3\2\2\2")
        buf.write("\u0784\u0767\3\2\2\2\u0784\u0775\3\2\2\2\u0784\u0776\3")
        buf.write("\2\2\2\u0785\u00ff\3\2\2\2\u0786\u0787\7y\2\2\u0787\u0788")
        buf.write("\7\u010c\2\2\u0788\u0793\5\u01b6\u00dc\2\u0789\u078a\7")
        buf.write("z\2\2\u078a\u078b\7\u010c\2\2\u078b\u0793\5\u01b8\u00dd")
        buf.write("\2\u078c\u078d\7{\2\2\u078d\u078e\7\u010c\2\2\u078e\u0793")
        buf.write("\5\u01b8\u00dd\2\u078f\u0790\7|\2\2\u0790\u0791\7\u010c")
        buf.write("\2\2\u0791\u0793\5\u01aa\u00d6\2\u0792\u0786\3\2\2\2\u0792")
        buf.write("\u0789\3\2\2\2\u0792\u078c\3\2\2\2\u0792\u078f\3\2\2\2")
        buf.write("\u0793\u0101\3\2\2\2\u0794\u0795\7}\2\2\u0795\u0796\7")
        buf.write("\u010c\2\2\u0796\u07a1\5.\30\2\u0797\u0798\7~\2\2\u0798")
        buf.write("\u0799\7\u010c\2\2\u0799\u07a1\5.\30\2\u079a\u079b\7\177")
        buf.write("\2\2\u079b\u079c\7\u010c\2\2\u079c\u07a1\5.\30\2\u079d")
        buf.write("\u079e\7\u0080\2\2\u079e\u079f\7\u010c\2\2\u079f\u07a1")
        buf.write("\5\u01b6\u00dc\2\u07a0\u0794\3\2\2\2\u07a0\u0797\3\2\2")
        buf.write("\2\u07a0\u079a\3\2\2\2\u07a0\u079d\3\2\2\2\u07a1\u0103")
        buf.write("\3\2\2\2\u07a2\u07a3\7\u0081\2\2\u07a3\u07a4\7\u010c\2")
        buf.write("\2\u07a4\u07a9\5\u01b6\u00dc\2\u07a5\u07a6\7\u0082\2\2")
        buf.write("\u07a6\u07a7\7\u010c\2\2\u07a7\u07a9\5\u01b6\u00dc\2\u07a8")
        buf.write("\u07a2\3\2\2\2\u07a8\u07a5\3\2\2\2\u07a9\u0105\3\2\2\2")
        buf.write("\u07aa\u07ab\7\u0083\2\2\u07ab\u07ac\7\u010c\2\2\u07ac")
        buf.write("\u07b4\5\u01aa\u00d6\2\u07ad\u07ae\7\u0081\2\2\u07ae\u07af")
        buf.write("\7\u010c\2\2\u07af\u07b4\5\u01b6\u00dc\2\u07b0\u07b1\7")
        buf.write("\u0082\2\2\u07b1\u07b2\7\u010c\2\2\u07b2\u07b4\5\u01b6")
        buf.write("\u00dc\2\u07b3\u07aa\3\2\2\2\u07b3\u07ad\3\2\2\2\u07b3")
        buf.write("\u07b0\3\2\2\2\u07b4\u0107\3\2\2\2\u07b5\u07b6\t\2\2\2")
        buf.write("\u07b6\u0109\3\2\2\2\u07b7\u07b8\t\3\2\2\u07b8\u010b\3")
        buf.write("\2\2\2\u07b9\u07ba\t\4\2\2\u07ba\u010d\3\2\2\2\u07bb\u07bc")
        buf.write("\t\5\2\2\u07bc\u010f\3\2\2\2\u07bd\u07be\t\6\2\2\u07be")
        buf.write("\u0111\3\2\2\2\u07bf\u07c0\t\7\2\2\u07c0\u0113\3\2\2\2")
        buf.write("\u07c1\u07c2\t\b\2\2\u07c2\u0115\3\2\2\2\u07c3\u07c4\t")
        buf.write("\t\2\2\u07c4\u0117\3\2\2\2\u07c5\u07c6\t\n\2\2\u07c6\u0119")
        buf.write("\3\2\2\2\u07c7\u07c8\b\u008e\1\2\u07c8\u07db\5\u0128\u0095")
        buf.write("\2\u07c9\u07db\5\u012a\u0096\2\u07ca\u07db\5\u012c\u0097")
        buf.write("\2\u07cb\u07db\5\u012e\u0098\2\u07cc\u07db\5\u0130\u0099")
        buf.write("\2\u07cd\u07db\5\u0132\u009a\2\u07ce\u07db\5\u0134\u009b")
        buf.write("\2\u07cf\u07db\5\u0136\u009c\2\u07d0\u07db\5\u0138\u009d")
        buf.write("\2\u07d1\u07db\5\u013a\u009e\2\u07d2\u07db\5\u013c\u009f")
        buf.write("\2\u07d3\u07db\5\u013e\u00a0\2\u07d4\u07db\5\u0144\u00a3")
        buf.write("\2\u07d5\u07db\5\u0146\u00a4\2\u07d6\u07db\5\u0148\u00a5")
        buf.write("\2\u07d7\u07db\5\u014a\u00a6\2\u07d8\u07db\5\u0140\u00a1")
        buf.write("\2\u07d9\u07db\5\u0142\u00a2\2\u07da\u07c7\3\2\2\2\u07da")
        buf.write("\u07c9\3\2\2\2\u07da\u07ca\3\2\2\2\u07da\u07cb\3\2\2\2")
        buf.write("\u07da\u07cc\3\2\2\2\u07da\u07cd\3\2\2\2\u07da\u07ce\3")
        buf.write("\2\2\2\u07da\u07cf\3\2\2\2\u07da\u07d0\3\2\2\2\u07da\u07d1")
        buf.write("\3\2\2\2\u07da\u07d2\3\2\2\2\u07da\u07d3\3\2\2\2\u07da")
        buf.write("\u07d4\3\2\2\2\u07da\u07d5\3\2\2\2\u07da\u07d6\3\2\2\2")
        buf.write("\u07da\u07d7\3\2\2\2\u07da\u07d8\3\2\2\2\u07da\u07d9\3")
        buf.write("\2\2\2\u07db\u07f1\3\2\2\2\u07dc\u07dd\f\5\2\2\u07dd\u07de")
        buf.write("\7\u010b\2\2\u07de\u07df\7\24\2\2\u07df\u07e0\7\u0103")
        buf.write("\2\2\u07e0\u07e1\5\u011a\u008e\2\u07e1\u07e2\7\u0104\2")
        buf.write("\2\u07e2\u07f0\3\2\2\2\u07e3\u07e4\f\4\2\2\u07e4\u07e5")
        buf.write("\7\u010b\2\2\u07e5\u07e6\7I\2\2\u07e6\u07e7\7\u0103\2")
        buf.write("\2\u07e7\u07e8\5\u011a\u008e\2\u07e8\u07e9\7\u0104\2\2")
        buf.write("\u07e9\u07f0\3\2\2\2\u07ea\u07eb\f\3\2\2\u07eb\u07ec\7")
        buf.write("\u010b\2\2\u07ec\u07ed\7\u00c0\2\2\u07ed\u07ee\7\u0103")
        buf.write("\2\2\u07ee\u07f0\7\u0104\2\2\u07ef\u07dc\3\2\2\2\u07ef")
        buf.write("\u07e3\3\2\2\2\u07ef\u07ea\3\2\2\2\u07f0\u07f3\3\2\2\2")
        buf.write("\u07f1\u07ef\3\2\2\2\u07f1\u07f2\3\2\2\2\u07f2\u011b\3")
        buf.write("\2\2\2\u07f3\u07f1\3\2\2\2\u07f4\u07fd\5\u014c\u00a7\2")
        buf.write("\u07f5\u07fd\5\u0150\u00a9\2\u07f6\u07fd\5\u014e\u00a8")
        buf.write("\2\u07f7\u07fd\5\u0152\u00aa\2\u07f8\u07fd\5\u0154\u00ab")
        buf.write("\2\u07f9\u07fd\5\u0156\u00ac\2\u07fa\u07fd\5\u0158\u00ad")
        buf.write("\2\u07fb\u07fd\5\u015a\u00ae\2\u07fc\u07f4\3\2\2\2\u07fc")
        buf.write("\u07f5\3\2\2\2\u07fc\u07f6\3\2\2\2\u07fc\u07f7\3\2\2\2")
        buf.write("\u07fc\u07f8\3\2\2\2\u07fc\u07f9\3\2\2\2\u07fc\u07fa\3")
        buf.write("\2\2\2\u07fc\u07fb\3\2\2\2\u07fd\u011d\3\2\2\2\u07fe\u07ff")
        buf.write("\t\13\2\2\u07ff\u011f\3\2\2\2\u0800\u0801\5\u015c\u00af")
        buf.write("\2\u0801\u0121\3\2\2\2\u0802\u0803\5\u010c\u0087\2\u0803")
        buf.write("\u0123\3\2\2\2\u0804\u0807\5\u010a\u0086\2\u0805\u0807")
        buf.write("\5\u0112\u008a\2\u0806\u0804\3\2\2\2\u0806\u0805\3\2\2")
        buf.write("\2\u0807\u0125\3\2\2\2\u0808\u0809\5\u0116\u008c\2\u0809")
        buf.write("\u0127\3\2\2\2\u080a\u080b\t\f\2\2\u080b\u080c\7\u0103")
        buf.write("\2\2\u080c\u080d\5\u01ae\u00d8\2\u080d\u080e\7\u0104\2")
        buf.write("\2\u080e\u0129\3\2\2\2\u080f\u0810\t\r\2\2\u0810\u0811")
        buf.write("\7\u0103\2\2\u0811\u0812\5\u01ae\u00d8\2\u0812\u0813\7")
        buf.write("\u0104\2\2\u0813\u012b\3\2\2\2\u0814\u0815\t\16\2\2\u0815")
        buf.write("\u0816\7\u0103\2\2\u0816\u0817\5\u01ae\u00d8\2\u0817\u0818")
        buf.write("\7\u0104\2\2\u0818\u012d\3\2\2\2\u0819\u081a\t\17\2\2")
        buf.write("\u081a\u081b\7\u0103\2\2\u081b\u081c\5\u01ae\u00d8\2\u081c")
        buf.write("\u081d\7\u0104\2\2\u081d\u012f\3\2\2\2\u081e\u081f\t\20")
        buf.write("\2\2\u081f\u0820\7\u0103\2\2\u0820\u0821\5\u01ae\u00d8")
        buf.write("\2\u0821\u0822\7\u0104\2\2\u0822\u0131\3\2\2\2\u0823\u0824")
        buf.write("\t\21\2\2\u0824\u0825\7\u0103\2\2\u0825\u0826\5\u01ae")
        buf.write("\u00d8\2\u0826\u0827\7\u0104\2\2\u0827\u0133\3\2\2\2\u0828")
        buf.write("\u0829\t\22\2\2\u0829\u082a\7\u0103\2\2\u082a\u082b\5")
        buf.write("\u01ae\u00d8\2\u082b\u082c\7\u010a\2\2\u082c\u082d\5\u01ae")
        buf.write("\u00d8\2\u082d\u082e\7\u0104\2\2\u082e\u0135\3\2\2\2\u082f")
        buf.write("\u0830\t\23\2\2\u0830\u0831\7\u0103\2\2\u0831\u0832\5")
        buf.write("\u01ae\u00d8\2\u0832\u0833\7\u010a\2\2\u0833\u0834\5\u01ae")
        buf.write("\u00d8\2\u0834\u0835\7\u0104\2\2\u0835\u0137\3\2\2\2\u0836")
        buf.write("\u0837\t\24\2\2\u0837\u0838\7\u0103\2\2\u0838\u0839\5")
        buf.write("\u01ae\u00d8\2\u0839\u083a\7\u010a\2\2\u083a\u083b\5\u01ae")
        buf.write("\u00d8\2\u083b\u083c\7\u0104\2\2\u083c\u0139\3\2\2\2\u083d")
        buf.write("\u083e\t\25\2\2\u083e\u083f\7\u0103\2\2\u083f\u0840\5")
        buf.write("\u01a2\u00d2\2\u0840\u0841\7\u0104\2\2\u0841\u013b\3\2")
        buf.write("\2\2\u0842\u0843\t\26\2\2\u0843\u0844\7\u0103\2\2\u0844")
        buf.write("\u0845\5\u01a2\u00d2\2\u0845\u0846\7\u0104\2\2\u0846\u013d")
        buf.write("\3\2\2\2\u0847\u0848\t\27\2\2\u0848\u0849\7\u0103\2\2")
        buf.write("\u0849\u084a\5\u011a\u008e\2\u084a\u084b\7\u0104\2\2\u084b")
        buf.write("\u013f\3\2\2\2\u084c\u084d\t\30\2\2\u084d\u084e\7\u0103")
        buf.write("\2\2\u084e\u084f\5\u01b8\u00dd\2\u084f\u0850\7\u0104\2")
        buf.write("\2\u0850\u0141\3\2\2\2\u0851\u0852\t\31\2\2\u0852\u0853")
        buf.write("\7\u0103\2\2\u0853\u0854\5\u01b8\u00dd\2\u0854\u0855\7")
        buf.write("\u0104\2\2\u0855\u0143\3\2\2\2\u0856\u0857\t\32\2\2\u0857")
        buf.write("\u0858\7\u0103\2\2\u0858\u0859\5\u01b8\u00dd\2\u0859\u085a")
        buf.write("\7\u0104\2\2\u085a\u0145\3\2\2\2\u085b\u085c\t\33\2\2")
        buf.write("\u085c\u085d\7\u0103\2\2\u085d\u085e\5\u01b8\u00dd\2\u085e")
        buf.write("\u085f\7\u0104\2\2\u085f\u0147\3\2\2\2\u0860\u0861\t\34")
        buf.write("\2\2\u0861\u0862\7\u0103\2\2\u0862\u0863\5\u01b8\u00dd")
        buf.write("\2\u0863\u0864\7\u0104\2\2\u0864\u0149\3\2\2\2\u0865\u0866")
        buf.write("\t\35\2\2\u0866\u0867\7\u0103\2\2\u0867\u0868\5\u01b8")
        buf.write("\u00dd\2\u0868\u0869\7\u0104\2\2\u0869\u014b\3\2\2\2\u086a")
        buf.write("\u086b\7\u00e6\2\2\u086b\u086c\7\u0103\2\2\u086c\u086d")
        buf.write("\7\u0104\2\2\u086d\u014d\3\2\2\2\u086e\u086f\7\u00e7\2")
        buf.write("\2\u086f\u0870\7\u0103\2\2\u0870\u0871\7\u0104\2\2\u0871")
        buf.write("\u014f\3\2\2\2\u0872\u0873\7\u00e8\2\2\u0873\u0874\7\u0103")
        buf.write("\2\2\u0874\u0875\7\u0104\2\2\u0875\u0151\3\2\2\2\u0876")
        buf.write("\u0877\7\u00e9\2\2\u0877\u0878\7\u0103\2\2\u0878\u0879")
        buf.write("\7\u0104\2\2\u0879\u0153\3\2\2\2\u087a\u087b\7\u00ea\2")
        buf.write("\2\u087b\u087c\7\u0103\2\2\u087c\u0883\7\u0104\2\2\u087d")
        buf.write("\u087e\7\u00ea\2\2\u087e\u087f\7\u0103\2\2\u087f\u0880")
        buf.write("\5\u01b2\u00da\2\u0880\u0881\7\u0104\2\2\u0881\u0883\3")
        buf.write("\2\2\2\u0882\u087a\3\2\2\2\u0882\u087d\3\2\2\2\u0883\u0155")
        buf.write("\3\2\2\2\u0884\u0885\7\u00eb\2\2\u0885\u0886\7\u0103\2")
        buf.write("\2\u0886\u0887\7\u0104\2\2\u0887\u0157\3\2\2\2\u0888\u0889")
        buf.write("\7\u00ec\2\2\u0889\u088a\7\u0103\2\2\u088a\u088b\7\u0104")
        buf.write("\2\2\u088b\u0159\3\2\2\2\u088c\u088d\7\u00ed\2\2\u088d")
        buf.write("\u088e\7\u0103\2\2\u088e\u088f\7\u0104\2\2\u088f\u015b")
        buf.write("\3\2\2\2\u0890\u0891\7\u00be\2\2\u0891\u0892\7\u0103\2")
        buf.write("\2\u0892\u0893\7\u0104\2\2\u0893\u015d\3\2\2\2\u0894\u0899")
        buf.write("\5\u0166\u00b4\2\u0895\u0899\5\u0164\u00b3\2\u0896\u0899")
        buf.write("\5\u0160\u00b1\2\u0897\u0899\5\u0162\u00b2\2\u0898\u0894")
        buf.write("\3\2\2\2\u0898\u0895\3\2\2\2\u0898\u0896\3\2\2\2\u0898")
        buf.write("\u0897\3\2\2\2\u0899\u015f\3\2\2\2\u089a\u089e\5\u0168")
        buf.write("\u00b5\2\u089b\u089e\5\u016a\u00b6\2\u089c\u089e\5\u016c")
        buf.write("\u00b7\2\u089d\u089a\3\2\2\2\u089d\u089b\3\2\2\2\u089d")
        buf.write("\u089c\3\2\2\2\u089e\u0161\3\2\2\2\u089f\u08a3\5\u016e")
        buf.write("\u00b8\2\u08a0\u08a3\5\u0170\u00b9\2\u08a1\u08a3\5\u0172")
        buf.write("\u00ba\2\u08a2\u089f\3\2\2\2\u08a2\u08a0\3\2\2\2\u08a2")
        buf.write("\u08a1\3\2\2\2\u08a3\u0163\3\2\2\2\u08a4\u08aa\5\u0174")
        buf.write("\u00bb\2\u08a5\u08aa\5\u0176\u00bc\2\u08a6\u08aa\5\u0178")
        buf.write("\u00bd\2\u08a7\u08aa\5\u017a\u00be\2\u08a8\u08aa\5\u017c")
        buf.write("\u00bf\2\u08a9\u08a4\3\2\2\2\u08a9\u08a5\3\2\2\2\u08a9")
        buf.write("\u08a6\3\2\2\2\u08a9\u08a7\3\2\2\2\u08a9\u08a8\3\2\2\2")
        buf.write("\u08aa\u0165\3\2\2\2\u08ab\u08b6\5\u017e\u00c0\2\u08ac")
        buf.write("\u08b6\5\u0180\u00c1\2\u08ad\u08b6\5\u0182\u00c2\2\u08ae")
        buf.write("\u08b6\5\u0184\u00c3\2\u08af\u08b6\5\u0186\u00c4\2\u08b0")
        buf.write("\u08b6\5\u0188\u00c5\2\u08b1\u08b6\5\u018a\u00c6\2\u08b2")
        buf.write("\u08b6\5\u018c\u00c7\2\u08b3\u08b6\5\u018e\u00c8\2\u08b4")
        buf.write("\u08b6\5\u0190\u00c9\2\u08b5\u08ab\3\2\2\2\u08b5\u08ac")
        buf.write("\3\2\2\2\u08b5\u08ad\3\2\2\2\u08b5\u08ae\3\2\2\2\u08b5")
        buf.write("\u08af\3\2\2\2\u08b5\u08b0\3\2\2\2\u08b5\u08b1\3\2\2\2")
        buf.write("\u08b5\u08b2\3\2\2\2\u08b5\u08b3\3\2\2\2\u08b5\u08b4\3")
        buf.write("\2\2\2\u08b6\u0167\3\2\2\2\u08b7\u08b8\5\u0192\u00ca\2")
        buf.write("\u08b8\u08b9\7\u010b\2\2\u08b9\u08ba\7~\2\2\u08ba\u0169")
        buf.write("\3\2\2\2\u08bb\u08bc\5\u0192\u00ca\2\u08bc\u08bd\7\u010b")
        buf.write("\2\2\u08bd\u08be\7f\2\2\u08be\u016b\3\2\2\2\u08bf\u08c0")
        buf.write("\5\u0192\u00ca\2\u08c0\u08c1\7\u010b\2\2\u08c1\u08c2\7")
        buf.write("\u00ee\2\2\u08c2\u016d\3\2\2\2\u08c3\u08c4\5\u0194\u00cb")
        buf.write("\2\u08c4\u08c5\7\u010b\2\2\u08c5\u08c6\7~\2\2\u08c6\u016f")
        buf.write("\3\2\2\2\u08c7\u08c8\5\u0194\u00cb\2\u08c8\u08c9\7\u010b")
        buf.write("\2\2\u08c9\u08ca\7f\2\2\u08ca\u0171\3\2\2\2\u08cb\u08cc")
        buf.write("\5\u0194\u00cb\2\u08cc\u08cd\7\u010b\2\2\u08cd\u08ce\7")
        buf.write("\u00ee\2\2\u08ce\u0173\3\2\2\2\u08cf\u08d0\5\u0196\u00cc")
        buf.write("\2\u08d0\u08d1\7\u010b\2\2\u08d1\u08d2\7\u00ef\2\2\u08d2")
        buf.write("\u0175\3\2\2\2\u08d3\u08d4\5\u0196\u00cc\2\u08d4\u08d5")
        buf.write("\7\u010b\2\2\u08d5\u08d6\7~\2\2\u08d6\u0177\3\2\2\2\u08d7")
        buf.write("\u08d8\5\u0196\u00cc\2\u08d8\u08d9\7\u010b\2\2\u08d9\u08da")
        buf.write("\7\u00f0\2\2\u08da\u0179\3\2\2\2\u08db\u08dc\5\u0196\u00cc")
        buf.write("\2\u08dc\u08dd\7\u010b\2\2\u08dd\u08de\7\u00f1\2\2\u08de")
        buf.write("\u017b\3\2\2\2\u08df\u08e0\5\u0196\u00cc\2\u08e0\u08e1")
        buf.write("\7\u010b\2\2\u08e1\u08e2\7\u00f2\2\2\u08e2\u017d\3\2\2")
        buf.write("\2\u08e3\u08e4\5\u0198\u00cd\2\u08e4\u08e5\7\u010b\2\2")
        buf.write("\u08e5\u08e6\7\u00f3\2\2\u08e6\u017f\3\2\2\2\u08e7\u08e8")
        buf.write("\5\u0198\u00cd\2\u08e8\u08e9\7\u010b\2\2\u08e9\u08ea\7")
        buf.write("\u00be\2\2\u08ea\u0181\3\2\2\2\u08eb\u08ec\5\u0198\u00cd")
        buf.write("\2\u08ec\u08ed\7\u010b\2\2\u08ed\u08ee\7\u00f4\2\2\u08ee")
        buf.write("\u0183\3\2\2\2\u08ef\u08f0\5\u0198\u00cd\2\u08f0\u08f1")
        buf.write("\7\u010b\2\2\u08f1\u08f2\7\u00f5\2\2\u08f2\u0185\3\2\2")
        buf.write("\2\u08f3\u08f4\5\u0198\u00cd\2\u08f4\u08f5\7\u010b\2\2")
        buf.write("\u08f5\u08f6\7\u0083\2\2\u08f6\u0187\3\2\2\2\u08f7\u08f8")
        buf.write("\5\u0198\u00cd\2\u08f8\u08f9\7\u010b\2\2\u08f9\u08fa\7")
        buf.write("p\2\2\u08fa\u0189\3\2\2\2\u08fb\u08fc\5\u0198\u00cd\2")
        buf.write("\u08fc\u08fd\7\u010b\2\2\u08fd\u08fe\7\u00a7\2\2\u08fe")
        buf.write("\u018b\3\2\2\2\u08ff\u0900\5\u0198\u00cd\2\u0900\u0901")
        buf.write("\7\u010b\2\2\u0901\u0902\7\u00f6\2\2\u0902\u018d\3\2\2")
        buf.write("\2\u0903\u0904\5\u0198\u00cd\2\u0904\u0905\7\u010b\2\2")
        buf.write("\u0905\u0906\7\u009f\2\2\u0906\u018f\3\2\2\2\u0907\u0908")
        buf.write("\5\u0198\u00cd\2\u0908\u0909\7\u010b\2\2\u0909\u090a\7")
        buf.write("@\2\2\u090a\u0191\3\2\2\2\u090b\u090c\7\u00f7\2\2\u090c")
        buf.write("\u0193\3\2\2\2\u090d\u090e\7\u00f8\2\2\u090e\u0195\3\2")
        buf.write("\2\2\u090f\u0910\7\u00f9\2\2\u0910\u0197\3\2\2\2\u0911")
        buf.write("\u0912\7\u00fa\2\2\u0912\u0199\3\2\2\2\u0913\u0915\5\u019c")
        buf.write("\u00cf\2\u0914\u0913\3\2\2\2\u0914\u0915\3\2\2\2\u0915")
        buf.write("\u019b\3\2\2\2\u0916\u091b\5\u00fe\u0080\2\u0917\u0918")
        buf.write("\7\u010a\2\2\u0918\u091a\5\u00fe\u0080\2\u0919\u0917\3")
        buf.write("\2\2\2\u091a\u091d\3\2\2\2\u091b\u0919\3\2\2\2\u091b\u091c")
        buf.write("\3\2\2\2\u091c\u019d\3\2\2\2\u091d\u091b\3\2\2\2\u091e")
        buf.write("\u0920\5\u01a0\u00d1\2\u091f\u091e\3\2\2\2\u091f\u0920")
        buf.write("\3\2\2\2\u0920\u019f\3\2\2\2\u0921\u0926\5.\30\2\u0922")
        buf.write("\u0923\7\u010a\2\2\u0923\u0925\5.\30\2\u0924\u0922\3\2")
        buf.write("\2\2\u0925\u0928\3\2\2\2\u0926\u0924\3\2\2\2\u0926\u0927")
        buf.write("\3\2\2\2\u0927\u01a1\3\2\2\2\u0928\u0926\3\2\2\2\u0929")
        buf.write("\u092b\5\u01a4\u00d3\2\u092a\u0929\3\2\2\2\u092a\u092b")
        buf.write("\3\2\2\2\u092b\u01a3\3\2\2\2\u092c\u0931\5\u01ae\u00d8")
        buf.write("\2\u092d\u092e\7\u010a\2\2\u092e\u0930\5\u01ae\u00d8\2")
        buf.write("\u092f\u092d\3\2\2\2\u0930\u0933\3\2\2\2\u0931\u092f\3")
        buf.write("\2\2\2\u0931\u0932\3\2\2\2\u0932\u01a5\3\2\2\2\u0933\u0931")
        buf.write("\3\2\2\2\u0934\u0935\5\u01b2\u00da\2\u0935\u0936\7\u010b")
        buf.write("\2\2\u0936\u0937\7\u010b\2\2\u0937\u0938\5\u01b2\u00da")
        buf.write("\2\u0938\u093f\3\2\2\2\u0939\u093a\5\u01b8\u00dd\2\u093a")
        buf.write("\u093b\7\u010b\2\2\u093b\u093c\7\u010b\2\2\u093c\u093d")
        buf.write("\5\u01b8\u00dd\2\u093d\u093f\3\2\2\2\u093e\u0934\3\2\2")
        buf.write("\2\u093e\u0939\3\2\2\2\u093f\u01a7\3\2\2\2\u0940\u0949")
        buf.write("\7\u0107\2\2\u0941\u0946\5\u01ae\u00d8\2\u0942\u0943\7")
        buf.write("\u010a\2\2\u0943\u0945\5\u01ae\u00d8\2\u0944\u0942\3\2")
        buf.write("\2\2\u0945\u0948\3\2\2\2\u0946\u0944\3\2\2\2\u0946\u0947")
        buf.write("\3\2\2\2\u0947\u094a\3\2\2\2\u0948\u0946\3\2\2\2\u0949")
        buf.write("\u0941\3\2\2\2\u0949\u094a\3\2\2\2\u094a\u094b\3\2\2\2")
        buf.write("\u094b\u094c\7\u0108\2\2\u094c\u01a9\3\2\2\2\u094d\u094f")
        buf.write("\5\u01ac\u00d7\2\u094e\u094d\3\2\2\2\u094e\u094f\3\2\2")
        buf.write("\2\u094f\u0956\3\2\2\2\u0950\u0952\7\u0107\2\2\u0951\u0953")
        buf.write("\5\u01ac\u00d7\2\u0952\u0951\3\2\2\2\u0952\u0953\3\2\2")
        buf.write("\2\u0953\u0954\3\2\2\2\u0954\u0956\7\u0108\2\2\u0955\u094e")
        buf.write("\3\2\2\2\u0955\u0950\3\2\2\2\u0956\u01ab\3\2\2\2\u0957")
        buf.write("\u095c\5\u01b8\u00dd\2\u0958\u0959\7\u010a\2\2\u0959\u095b")
        buf.write("\5\u01b8\u00dd\2\u095a\u0958\3\2\2\2\u095b\u095e\3\2\2")
        buf.write("\2\u095c\u095a\3\2\2\2\u095c\u095d\3\2\2\2\u095d\u01ad")
        buf.write("\3\2\2\2\u095e\u095c\3\2\2\2\u095f\u096f\5\u01b2\u00da")
        buf.write("\2\u0960\u096f\5\u01b4\u00db\2\u0961\u096f\5\u01b6\u00dc")
        buf.write("\2\u0962\u096f\5\u01b8\u00dd\2\u0963\u096f\5\u01ba\u00de")
        buf.write("\2\u0964\u096f\5\u01bc\u00df\2\u0965\u096f\5\u010a\u0086")
        buf.write("\2\u0966\u096f\5\u0110\u0089\2\u0967\u096f\5\u010e\u0088")
        buf.write("\2\u0968\u096f\5\u0118\u008d\2\u0969\u096f\5\u01a8\u00d5")
        buf.write("\2\u096a\u096f\5\u01a6\u00d4\2\u096b\u096f\5.\30\2\u096c")
        buf.write("\u096f\5\60\31\2\u096d\u096f\5\u01b0\u00d9\2\u096e\u095f")
        buf.write("\3\2\2\2\u096e\u0960\3\2\2\2\u096e\u0961\3\2\2\2\u096e")
        buf.write("\u0962\3\2\2\2\u096e\u0963\3\2\2\2\u096e\u0964\3\2\2\2")
        buf.write("\u096e\u0965\3\2\2\2\u096e\u0966\3\2\2\2\u096e\u0967\3")
        buf.write("\2\2\2\u096e\u0968\3\2\2\2\u096e\u0969\3\2\2\2\u096e\u096a")
        buf.write("\3\2\2\2\u096e\u096b\3\2\2\2\u096e\u096c\3\2\2\2\u096e")
        buf.write("\u096d\3\2\2\2\u096f\u01af\3\2\2\2\u0970\u0972\7\u0107")
        buf.write("\2\2\u0971\u0973\5\u01ae\u00d8\2\u0972\u0971\3\2\2\2\u0972")
        buf.write("\u0973\3\2\2\2\u0973\u0974\3\2\2\2\u0974\u0976\7\u010c")
        buf.write("\2\2\u0975\u0977\5\u01ae\u00d8\2\u0976\u0975\3\2\2\2\u0976")
        buf.write("\u0977\3\2\2\2\u0977\u0982\3\2\2\2\u0978\u097a\7\u010a")
        buf.write("\2\2\u0979\u097b\5\u01ae\u00d8\2\u097a\u0979\3\2\2\2\u097a")
        buf.write("\u097b\3\2\2\2\u097b\u097c\3\2\2\2\u097c\u097e\7\u010c")
        buf.write("\2\2\u097d\u097f\5\u01ae\u00d8\2\u097e\u097d\3\2\2\2\u097e")
        buf.write("\u097f\3\2\2\2\u097f\u0981\3\2\2\2\u0980\u0978\3\2\2\2")
        buf.write("\u0981\u0984\3\2\2\2\u0982\u0980\3\2\2\2\u0982\u0983\3")
        buf.write("\2\2\2\u0983\u0985\3\2\2\2\u0984\u0982\3\2\2\2\u0985\u0986")
        buf.write("\7\u0108\2\2\u0986\u01b1\3\2\2\2\u0987\u0988\7\u00fd\2")
        buf.write("\2\u0988\u01b3\3\2\2\2\u0989\u098a\7\u00fe\2\2\u098a\u01b5")
        buf.write("\3\2\2\2\u098b\u098c\7\u00ff\2\2\u098c\u01b7\3\2\2\2\u098d")
        buf.write("\u0991\7\u0101\2\2\u098e\u0991\7\u0102\2\2\u098f\u0991")
        buf.write("\5\u015e\u00b0\2\u0990\u098d\3\2\2\2\u0990\u098e\3\2\2")
        buf.write("\2\u0990\u098f\3\2\2\2\u0991\u01b9\3\2\2\2\u0992\u0993")
        buf.write("\7\u00fb\2\2\u0993\u0994\7\u0103\2\2\u0994\u0995\5\u01b8")
        buf.write("\u00dd\2\u0995\u0996\7\u0104\2\2\u0996\u01bb\3\2\2\2\u0997")
        buf.write("\u0998\7\u0100\2\2\u0998\u01bd\3\2\2\2~\u01c0\u01c5\u01c9")
        buf.write("\u01d9\u01e2\u01ec\u01f3\u0207\u0219\u0221\u0238\u0246")
        buf.write("\u0256\u025e\u026a\u027e\u029d\u029f\u02aa\u02b2\u031d")
        buf.write("\u032e\u0342\u0350\u035c\u036d\u03b8\u03bf\u03ed\u040a")
        buf.write("\u0415\u041e\u0436\u0442\u0453\u045f\u0469\u0473\u04b6")
        buf.write("\u04bd\u04c6\u04d2\u04d6\u04e2\u04e6\u04f2\u04fb\u0526")
        buf.write("\u053c\u054b\u0564\u056e\u0578\u0592\u05a6\u05c2\u05d4")
        buf.write("\u05db\u05ed\u05f8\u05fc\u0613\u0625\u062f\u063d\u0654")
        buf.write("\u066b\u0674\u068f\u06a3\u06b9\u06ca\u06d8\u06df\u06f0")
        buf.write("\u0705\u0715\u0719\u0731\u073f\u0749\u074f\u075d\u0763")
        buf.write("\u076b\u0771\u077a\u0780\u0784\u0792\u07a0\u07a8\u07b3")
        buf.write("\u07da\u07ef\u07f1\u07fc\u0806\u0882\u0898\u089d\u08a2")
        buf.write("\u08a9\u08b5\u0914\u091b\u091f\u0926\u092a\u0931\u093e")
        buf.write("\u0946\u0949\u094e\u0952\u0955\u095c\u096e\u0972\u0976")
        buf.write("\u097a\u097e\u0982\u0990")
        return buf.getvalue()


class GremlinParser ( Parser ):

    grammarFileName = "Gremlin.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'toString'", "'tx'", "'commit'", "'rollback'", 
                     "'withBulk'", "'withPath'", "'withSack'", "'withSideEffect'", 
                     "'withStrategies'", "'with'", "'addE'", "'addV'", "'E'", 
                     "'V'", "'inject'", "'io'", "'aggregate'", "'and'", 
                     "'as'", "'barrier'", "'both'", "'bothE'", "'bothV'", 
                     "'branch'", "'by'", "'cap'", "'choose'", "'coalesce'", 
                     "'coin'", "'connectedComponent'", "'constant'", "'count'", 
                     "'cyclicPath'", "'dedup'", "'drop'", "'elementMap'", 
                     "'emit'", "'filter'", "'flatMap'", "'fold'", "'from'", 
                     "'group'", "'groupCount'", "'has'", "'hasId'", "'hasKey'", 
                     "'hasLabel'", "'hasNot'", "'hasValue'", "'id'", "'identity'", 
                     "'in'", "'inE'", "'inV'", "'index'", "'is'", "'key'", 
                     "'label'", "'limit'", "'local'", "'loops'", "'map'", 
                     "'match'", "'math'", "'max'", "'mean'", "'min'", "'not'", 
                     "'option'", "'optional'", "'or'", "'order'", "'otherV'", 
                     "'out'", "'outE'", "'outV'", "'pageRank'", "'path'", 
                     "'peerPressure'", "'profile'", "'project'", "'properties'", 
                     "'property'", "'propertyMap'", "'range'", "'read'", 
                     "'repeat'", "'sack'", "'sample'", "'select'", "'shortestPath'", 
                     "'sideEffect'", "'simplePath'", "'skip'", "'store'", 
                     "'subgraph'", "'sum'", "'tail'", "'timeLimit'", "'times'", 
                     "'to'", "'toE'", "'toV'", "'tree'", "'unfold'", "'union'", 
                     "'until'", "'value'", "'valueMap'", "'values'", "'where'", 
                     "'write'", "'PartitionStrategy'", "'SeedStrategy'", 
                     "'SubgraphStrategy'", "'EdgeLabelVerificationStrategy'", 
                     "'ReadOnlyStrategy'", "'ReservedKeysVerificationStrategy'", 
                     "'includeMetaProperties'", "'writePartition'", "'partitionKey'", 
                     "'readPartitions'", "'vertices'", "'edges'", "'vertexProperties'", 
                     "'checkAdjacentVertices'", "'throwException'", "'logWarning'", 
                     "'keys'", "'Scope.local'", "'global'", "'Scope.global'", 
                     "'T.id'", "'T.label'", "'T.key'", "'T.value'", "'incr'", 
                     "'Order.incr'", "'decr'", "'Order.decr'", "'asc'", 
                     "'Order.asc'", "'desc'", "'Order.desc'", "'shuffle'", 
                     "'Order.shuffle'", "'IN'", "'Direction.IN'", "'OUT'", 
                     "'Direction.OUT'", "'BOTH'", "'Direction.BOTH'", "'single'", 
                     "'Cardinality.single'", "'set'", "'Cardinality.set'", 
                     "'list'", "'Cardinality.list'", "'Column.keys'", "'Column.values'", 
                     "'first'", "'Pop.first'", "'last'", "'Pop.last'", "'all'", 
                     "'Pop.all'", "'mixed'", "'Pop.mixed'", "'addAll'", 
                     "'Operator.addAll'", "'Operator.and'", "'assign'", 
                     "'Operator.assign'", "'div'", "'Operator.div'", "'Operator.max'", 
                     "'Operator.min'", "'minus'", "'Operator.minus'", "'mult'", 
                     "'Operator.mult'", "'Operator.or'", "'Operator.sum'", 
                     "'sumLong'", "'Operator.sumLong'", "'any'", "'Pick.any'", 
                     "'none'", "'Pick.none'", "'negate'", "'normSack'", 
                     "'Barrier.normSack'", "'P.eq'", "'eq'", "'P.neq'", 
                     "'neq'", "'P.lt'", "'lt'", "'P.lte'", "'lte'", "'P.gt'", 
                     "'gt'", "'P.gte'", "'gte'", "'P.inside'", "'inside'", 
                     "'P.outside'", "'outside'", "'P.between'", "'between'", 
                     "'P.within'", "'within'", "'P.without'", "'without'", 
                     "'P.not'", "'TextP.containing'", "'containing'", "'TextP.notContaining'", 
                     "'notContaining'", "'TextP.startingWith'", "'startingWith'", 
                     "'TextP.notStartingWith'", "'notStartingWith'", "'TextP.endingWith'", 
                     "'endingWith'", "'TextP.notEndingWith'", "'notEndingWith'", 
                     "'explain'", "'hasNext'", "'iterate'", "'tryNext'", 
                     "'next'", "'toList'", "'toSet'", "'toBulkSet'", "'propertyName'", 
                     "'target'", "'distance'", "'maxDistance'", "'includeEdges'", 
                     "'tokens'", "'ids'", "'labels'", "'indexer'", "'PageRank'", 
                     "'PeerPressure'", "'ShortestPath'", "'WithOptions'", 
                     "'datetime'", "'new'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'null'", "<INVALID>", "<INVALID>", "'('", "')'", "'{'", 
                     "'}'", "'['", "']'", "';'", "','", "'.'", "':'", "'g'", 
                     "'__'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "NEW", "IntegerLiteral", 
                      "FloatingPointLiteral", "BooleanLiteral", "NullLiteral", 
                      "NonEmptyStringLiteral", "EmptyStringLiteral", "LPAREN", 
                      "RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK", 
                      "SEMI", "COMMA", "DOT", "COLON", "TRAVERSAL_ROOT", 
                      "ANON_TRAVERSAL_ROOT", "WS", "LINE_COMMENT" ]

    RULE_queryList = 0
    RULE_query = 1
    RULE_emptyQuery = 2
    RULE_traversalSource = 3
    RULE_transactionPart = 4
    RULE_rootTraversal = 5
    RULE_traversalSourceSelfMethod = 6
    RULE_traversalSourceSelfMethod_withBulk = 7
    RULE_traversalSourceSelfMethod_withPath = 8
    RULE_traversalSourceSelfMethod_withSack = 9
    RULE_traversalSourceSelfMethod_withSideEffect = 10
    RULE_traversalSourceSelfMethod_withStrategies = 11
    RULE_traversalSourceSelfMethod_with = 12
    RULE_traversalSourceSpawnMethod = 13
    RULE_traversalSourceSpawnMethod_addE = 14
    RULE_traversalSourceSpawnMethod_addV = 15
    RULE_traversalSourceSpawnMethod_E = 16
    RULE_traversalSourceSpawnMethod_V = 17
    RULE_traversalSourceSpawnMethod_inject = 18
    RULE_traversalSourceSpawnMethod_io = 19
    RULE_chainedTraversal = 20
    RULE_chainedParentOfGraphTraversal = 21
    RULE_nestedTraversal = 22
    RULE_terminatedTraversal = 23
    RULE_traversalMethod = 24
    RULE_traversalMethod_V = 25
    RULE_traversalMethod_addE = 26
    RULE_traversalMethod_addV = 27
    RULE_traversalMethod_aggregate = 28
    RULE_traversalMethod_and = 29
    RULE_traversalMethod_as = 30
    RULE_traversalMethod_barrier = 31
    RULE_traversalMethod_both = 32
    RULE_traversalMethod_bothE = 33
    RULE_traversalMethod_bothV = 34
    RULE_traversalMethod_branch = 35
    RULE_traversalMethod_by = 36
    RULE_traversalMethod_cap = 37
    RULE_traversalMethod_choose = 38
    RULE_traversalMethod_coalesce = 39
    RULE_traversalMethod_coin = 40
    RULE_traversalMethod_connectedComponent = 41
    RULE_traversalMethod_constant = 42
    RULE_traversalMethod_count = 43
    RULE_traversalMethod_cyclicPath = 44
    RULE_traversalMethod_dedup = 45
    RULE_traversalMethod_drop = 46
    RULE_traversalMethod_elementMap = 47
    RULE_traversalMethod_emit = 48
    RULE_traversalMethod_filter = 49
    RULE_traversalMethod_flatMap = 50
    RULE_traversalMethod_fold = 51
    RULE_traversalMethod_from = 52
    RULE_traversalMethod_group = 53
    RULE_traversalMethod_groupCount = 54
    RULE_traversalMethod_has = 55
    RULE_traversalMethod_hasId = 56
    RULE_traversalMethod_hasKey = 57
    RULE_traversalMethod_hasLabel = 58
    RULE_traversalMethod_hasNot = 59
    RULE_traversalMethod_hasValue = 60
    RULE_traversalMethod_id = 61
    RULE_traversalMethod_identity = 62
    RULE_traversalMethod_in = 63
    RULE_traversalMethod_inE = 64
    RULE_traversalMethod_inV = 65
    RULE_traversalMethod_index = 66
    RULE_traversalMethod_inject = 67
    RULE_traversalMethod_is = 68
    RULE_traversalMethod_key = 69
    RULE_traversalMethod_label = 70
    RULE_traversalMethod_limit = 71
    RULE_traversalMethod_local = 72
    RULE_traversalMethod_loops = 73
    RULE_traversalMethod_map = 74
    RULE_traversalMethod_match = 75
    RULE_traversalMethod_math = 76
    RULE_traversalMethod_max = 77
    RULE_traversalMethod_mean = 78
    RULE_traversalMethod_min = 79
    RULE_traversalMethod_not = 80
    RULE_traversalMethod_option = 81
    RULE_traversalMethod_optional = 82
    RULE_traversalMethod_or = 83
    RULE_traversalMethod_order = 84
    RULE_traversalMethod_otherV = 85
    RULE_traversalMethod_out = 86
    RULE_traversalMethod_outE = 87
    RULE_traversalMethod_outV = 88
    RULE_traversalMethod_pageRank = 89
    RULE_traversalMethod_path = 90
    RULE_traversalMethod_peerPressure = 91
    RULE_traversalMethod_profile = 92
    RULE_traversalMethod_project = 93
    RULE_traversalMethod_properties = 94
    RULE_traversalMethod_property = 95
    RULE_traversalMethod_propertyMap = 96
    RULE_traversalMethod_range = 97
    RULE_traversalMethod_read = 98
    RULE_traversalMethod_repeat = 99
    RULE_traversalMethod_sack = 100
    RULE_traversalMethod_sample = 101
    RULE_traversalMethod_select = 102
    RULE_traversalMethod_shortestPath = 103
    RULE_traversalMethod_sideEffect = 104
    RULE_traversalMethod_simplePath = 105
    RULE_traversalMethod_skip = 106
    RULE_traversalMethod_store = 107
    RULE_traversalMethod_subgraph = 108
    RULE_traversalMethod_sum = 109
    RULE_traversalMethod_tail = 110
    RULE_traversalMethod_timeLimit = 111
    RULE_traversalMethod_times = 112
    RULE_traversalMethod_to = 113
    RULE_traversalMethod_toE = 114
    RULE_traversalMethod_toV = 115
    RULE_traversalMethod_tree = 116
    RULE_traversalMethod_unfold = 117
    RULE_traversalMethod_union = 118
    RULE_traversalMethod_until = 119
    RULE_traversalMethod_value = 120
    RULE_traversalMethod_valueMap = 121
    RULE_traversalMethod_values = 122
    RULE_traversalMethod_where = 123
    RULE_traversalMethod_with = 124
    RULE_traversalMethod_write = 125
    RULE_traversalStrategy = 126
    RULE_traversalStrategyArgs_PartitionStrategy = 127
    RULE_traversalStrategyArgs_SubgraphStrategy = 128
    RULE_traversalStrategyArgs_EdgeLabelVerificationStrategy = 129
    RULE_traversalStrategyArgs_ReservedKeysVerificationStrategy = 130
    RULE_traversalScope = 131
    RULE_traversalToken = 132
    RULE_traversalOrder = 133
    RULE_traversalDirection = 134
    RULE_traversalCardinality = 135
    RULE_traversalColumn = 136
    RULE_traversalPop = 137
    RULE_traversalOperator = 138
    RULE_traversalOptionParent = 139
    RULE_traversalPredicate = 140
    RULE_traversalTerminalMethod = 141
    RULE_traversalSackMethod = 142
    RULE_traversalSelfMethod = 143
    RULE_traversalComparator = 144
    RULE_traversalFunction = 145
    RULE_traversalBiFunction = 146
    RULE_traversalPredicate_eq = 147
    RULE_traversalPredicate_neq = 148
    RULE_traversalPredicate_lt = 149
    RULE_traversalPredicate_lte = 150
    RULE_traversalPredicate_gt = 151
    RULE_traversalPredicate_gte = 152
    RULE_traversalPredicate_inside = 153
    RULE_traversalPredicate_outside = 154
    RULE_traversalPredicate_between = 155
    RULE_traversalPredicate_within = 156
    RULE_traversalPredicate_without = 157
    RULE_traversalPredicate_not = 158
    RULE_traversalPredicate_containing = 159
    RULE_traversalPredicate_notContaining = 160
    RULE_traversalPredicate_startingWith = 161
    RULE_traversalPredicate_notStartingWith = 162
    RULE_traversalPredicate_endingWith = 163
    RULE_traversalPredicate_notEndingWith = 164
    RULE_traversalTerminalMethod_explain = 165
    RULE_traversalTerminalMethod_hasNext = 166
    RULE_traversalTerminalMethod_iterate = 167
    RULE_traversalTerminalMethod_tryNext = 168
    RULE_traversalTerminalMethod_next = 169
    RULE_traversalTerminalMethod_toList = 170
    RULE_traversalTerminalMethod_toSet = 171
    RULE_traversalTerminalMethod_toBulkSet = 172
    RULE_traversalSelfMethod_none = 173
    RULE_gremlinStringConstants = 174
    RULE_pageRankStringConstants = 175
    RULE_peerPressureStringConstants = 176
    RULE_shortestPathStringConstants = 177
    RULE_withOptionsStringConstants = 178
    RULE_gremlinStringConstants_pageRankStringConstants_edges = 179
    RULE_gremlinStringConstants_pageRankStringConstants_times = 180
    RULE_gremlinStringConstants_pageRankStringConstants_propertyName = 181
    RULE_gremlinStringConstants_peerPressureStringConstants_edges = 182
    RULE_gremlinStringConstants_peerPressureStringConstants_times = 183
    RULE_gremlinStringConstants_peerPressureStringConstants_propertyName = 184
    RULE_gremlinStringConstants_shortestPathStringConstants_target = 185
    RULE_gremlinStringConstants_shortestPathStringConstants_edges = 186
    RULE_gremlinStringConstants_shortestPathStringConstants_distance = 187
    RULE_gremlinStringConstants_shortestPathStringConstants_maxDistance = 188
    RULE_gremlinStringConstants_shortestPathStringConstants_includeEdges = 189
    RULE_gremlinStringConstants_withOptionsStringConstants_tokens = 190
    RULE_gremlinStringConstants_withOptionsStringConstants_none = 191
    RULE_gremlinStringConstants_withOptionsStringConstants_ids = 192
    RULE_gremlinStringConstants_withOptionsStringConstants_labels = 193
    RULE_gremlinStringConstants_withOptionsStringConstants_keys = 194
    RULE_gremlinStringConstants_withOptionsStringConstants_values = 195
    RULE_gremlinStringConstants_withOptionsStringConstants_all = 196
    RULE_gremlinStringConstants_withOptionsStringConstants_indexer = 197
    RULE_gremlinStringConstants_withOptionsStringConstants_list = 198
    RULE_gremlinStringConstants_withOptionsStringConstants_map = 199
    RULE_pageRankStringConstant = 200
    RULE_peerPressureStringConstant = 201
    RULE_shortestPathStringConstant = 202
    RULE_withOptionsStringConstant = 203
    RULE_traversalStrategyList = 204
    RULE_traversalStrategyExpr = 205
    RULE_nestedTraversalList = 206
    RULE_nestedTraversalExpr = 207
    RULE_genericLiteralList = 208
    RULE_genericLiteralExpr = 209
    RULE_genericLiteralRange = 210
    RULE_genericLiteralCollection = 211
    RULE_stringLiteralList = 212
    RULE_stringLiteralExpr = 213
    RULE_genericLiteral = 214
    RULE_genericLiteralMap = 215
    RULE_integerLiteral = 216
    RULE_floatLiteral = 217
    RULE_booleanLiteral = 218
    RULE_stringLiteral = 219
    RULE_dateLiteral = 220
    RULE_nullLiteral = 221

    ruleNames =  [ "queryList", "query", "emptyQuery", "traversalSource", 
                   "transactionPart", "rootTraversal", "traversalSourceSelfMethod", 
                   "traversalSourceSelfMethod_withBulk", "traversalSourceSelfMethod_withPath", 
                   "traversalSourceSelfMethod_withSack", "traversalSourceSelfMethod_withSideEffect", 
                   "traversalSourceSelfMethod_withStrategies", "traversalSourceSelfMethod_with", 
                   "traversalSourceSpawnMethod", "traversalSourceSpawnMethod_addE", 
                   "traversalSourceSpawnMethod_addV", "traversalSourceSpawnMethod_E", 
                   "traversalSourceSpawnMethod_V", "traversalSourceSpawnMethod_inject", 
                   "traversalSourceSpawnMethod_io", "chainedTraversal", 
                   "chainedParentOfGraphTraversal", "nestedTraversal", "terminatedTraversal", 
                   "traversalMethod", "traversalMethod_V", "traversalMethod_addE", 
                   "traversalMethod_addV", "traversalMethod_aggregate", 
                   "traversalMethod_and", "traversalMethod_as", "traversalMethod_barrier", 
                   "traversalMethod_both", "traversalMethod_bothE", "traversalMethod_bothV", 
                   "traversalMethod_branch", "traversalMethod_by", "traversalMethod_cap", 
                   "traversalMethod_choose", "traversalMethod_coalesce", 
                   "traversalMethod_coin", "traversalMethod_connectedComponent", 
                   "traversalMethod_constant", "traversalMethod_count", 
                   "traversalMethod_cyclicPath", "traversalMethod_dedup", 
                   "traversalMethod_drop", "traversalMethod_elementMap", 
                   "traversalMethod_emit", "traversalMethod_filter", "traversalMethod_flatMap", 
                   "traversalMethod_fold", "traversalMethod_from", "traversalMethod_group", 
                   "traversalMethod_groupCount", "traversalMethod_has", 
                   "traversalMethod_hasId", "traversalMethod_hasKey", "traversalMethod_hasLabel", 
                   "traversalMethod_hasNot", "traversalMethod_hasValue", 
                   "traversalMethod_id", "traversalMethod_identity", "traversalMethod_in", 
                   "traversalMethod_inE", "traversalMethod_inV", "traversalMethod_index", 
                   "traversalMethod_inject", "traversalMethod_is", "traversalMethod_key", 
                   "traversalMethod_label", "traversalMethod_limit", "traversalMethod_local", 
                   "traversalMethod_loops", "traversalMethod_map", "traversalMethod_match", 
                   "traversalMethod_math", "traversalMethod_max", "traversalMethod_mean", 
                   "traversalMethod_min", "traversalMethod_not", "traversalMethod_option", 
                   "traversalMethod_optional", "traversalMethod_or", "traversalMethod_order", 
                   "traversalMethod_otherV", "traversalMethod_out", "traversalMethod_outE", 
                   "traversalMethod_outV", "traversalMethod_pageRank", "traversalMethod_path", 
                   "traversalMethod_peerPressure", "traversalMethod_profile", 
                   "traversalMethod_project", "traversalMethod_properties", 
                   "traversalMethod_property", "traversalMethod_propertyMap", 
                   "traversalMethod_range", "traversalMethod_read", "traversalMethod_repeat", 
                   "traversalMethod_sack", "traversalMethod_sample", "traversalMethod_select", 
                   "traversalMethod_shortestPath", "traversalMethod_sideEffect", 
                   "traversalMethod_simplePath", "traversalMethod_skip", 
                   "traversalMethod_store", "traversalMethod_subgraph", 
                   "traversalMethod_sum", "traversalMethod_tail", "traversalMethod_timeLimit", 
                   "traversalMethod_times", "traversalMethod_to", "traversalMethod_toE", 
                   "traversalMethod_toV", "traversalMethod_tree", "traversalMethod_unfold", 
                   "traversalMethod_union", "traversalMethod_until", "traversalMethod_value", 
                   "traversalMethod_valueMap", "traversalMethod_values", 
                   "traversalMethod_where", "traversalMethod_with", "traversalMethod_write", 
                   "traversalStrategy", "traversalStrategyArgs_PartitionStrategy", 
                   "traversalStrategyArgs_SubgraphStrategy", "traversalStrategyArgs_EdgeLabelVerificationStrategy", 
                   "traversalStrategyArgs_ReservedKeysVerificationStrategy", 
                   "traversalScope", "traversalToken", "traversalOrder", 
                   "traversalDirection", "traversalCardinality", "traversalColumn", 
                   "traversalPop", "traversalOperator", "traversalOptionParent", 
                   "traversalPredicate", "traversalTerminalMethod", "traversalSackMethod", 
                   "traversalSelfMethod", "traversalComparator", "traversalFunction", 
                   "traversalBiFunction", "traversalPredicate_eq", "traversalPredicate_neq", 
                   "traversalPredicate_lt", "traversalPredicate_lte", "traversalPredicate_gt", 
                   "traversalPredicate_gte", "traversalPredicate_inside", 
                   "traversalPredicate_outside", "traversalPredicate_between", 
                   "traversalPredicate_within", "traversalPredicate_without", 
                   "traversalPredicate_not", "traversalPredicate_containing", 
                   "traversalPredicate_notContaining", "traversalPredicate_startingWith", 
                   "traversalPredicate_notStartingWith", "traversalPredicate_endingWith", 
                   "traversalPredicate_notEndingWith", "traversalTerminalMethod_explain", 
                   "traversalTerminalMethod_hasNext", "traversalTerminalMethod_iterate", 
                   "traversalTerminalMethod_tryNext", "traversalTerminalMethod_next", 
                   "traversalTerminalMethod_toList", "traversalTerminalMethod_toSet", 
                   "traversalTerminalMethod_toBulkSet", "traversalSelfMethod_none", 
                   "gremlinStringConstants", "pageRankStringConstants", 
                   "peerPressureStringConstants", "shortestPathStringConstants", 
                   "withOptionsStringConstants", "gremlinStringConstants_pageRankStringConstants_edges", 
                   "gremlinStringConstants_pageRankStringConstants_times", 
                   "gremlinStringConstants_pageRankStringConstants_propertyName", 
                   "gremlinStringConstants_peerPressureStringConstants_edges", 
                   "gremlinStringConstants_peerPressureStringConstants_times", 
                   "gremlinStringConstants_peerPressureStringConstants_propertyName", 
                   "gremlinStringConstants_shortestPathStringConstants_target", 
                   "gremlinStringConstants_shortestPathStringConstants_edges", 
                   "gremlinStringConstants_shortestPathStringConstants_distance", 
                   "gremlinStringConstants_shortestPathStringConstants_maxDistance", 
                   "gremlinStringConstants_shortestPathStringConstants_includeEdges", 
                   "gremlinStringConstants_withOptionsStringConstants_tokens", 
                   "gremlinStringConstants_withOptionsStringConstants_none", 
                   "gremlinStringConstants_withOptionsStringConstants_ids", 
                   "gremlinStringConstants_withOptionsStringConstants_labels", 
                   "gremlinStringConstants_withOptionsStringConstants_keys", 
                   "gremlinStringConstants_withOptionsStringConstants_values", 
                   "gremlinStringConstants_withOptionsStringConstants_all", 
                   "gremlinStringConstants_withOptionsStringConstants_indexer", 
                   "gremlinStringConstants_withOptionsStringConstants_list", 
                   "gremlinStringConstants_withOptionsStringConstants_map", 
                   "pageRankStringConstant", "peerPressureStringConstant", 
                   "shortestPathStringConstant", "withOptionsStringConstant", 
                   "traversalStrategyList", "traversalStrategyExpr", "nestedTraversalList", 
                   "nestedTraversalExpr", "genericLiteralList", "genericLiteralExpr", 
                   "genericLiteralRange", "genericLiteralCollection", "stringLiteralList", 
                   "stringLiteralExpr", "genericLiteral", "genericLiteralMap", 
                   "integerLiteral", "floatLiteral", "booleanLiteral", "stringLiteral", 
                   "dateLiteral", "nullLiteral" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    T__86=87
    T__87=88
    T__88=89
    T__89=90
    T__90=91
    T__91=92
    T__92=93
    T__93=94
    T__94=95
    T__95=96
    T__96=97
    T__97=98
    T__98=99
    T__99=100
    T__100=101
    T__101=102
    T__102=103
    T__103=104
    T__104=105
    T__105=106
    T__106=107
    T__107=108
    T__108=109
    T__109=110
    T__110=111
    T__111=112
    T__112=113
    T__113=114
    T__114=115
    T__115=116
    T__116=117
    T__117=118
    T__118=119
    T__119=120
    T__120=121
    T__121=122
    T__122=123
    T__123=124
    T__124=125
    T__125=126
    T__126=127
    T__127=128
    T__128=129
    T__129=130
    T__130=131
    T__131=132
    T__132=133
    T__133=134
    T__134=135
    T__135=136
    T__136=137
    T__137=138
    T__138=139
    T__139=140
    T__140=141
    T__141=142
    T__142=143
    T__143=144
    T__144=145
    T__145=146
    T__146=147
    T__147=148
    T__148=149
    T__149=150
    T__150=151
    T__151=152
    T__152=153
    T__153=154
    T__154=155
    T__155=156
    T__156=157
    T__157=158
    T__158=159
    T__159=160
    T__160=161
    T__161=162
    T__162=163
    T__163=164
    T__164=165
    T__165=166
    T__166=167
    T__167=168
    T__168=169
    T__169=170
    T__170=171
    T__171=172
    T__172=173
    T__173=174
    T__174=175
    T__175=176
    T__176=177
    T__177=178
    T__178=179
    T__179=180
    T__180=181
    T__181=182
    T__182=183
    T__183=184
    T__184=185
    T__185=186
    T__186=187
    T__187=188
    T__188=189
    T__189=190
    T__190=191
    T__191=192
    T__192=193
    T__193=194
    T__194=195
    T__195=196
    T__196=197
    T__197=198
    T__198=199
    T__199=200
    T__200=201
    T__201=202
    T__202=203
    T__203=204
    T__204=205
    T__205=206
    T__206=207
    T__207=208
    T__208=209
    T__209=210
    T__210=211
    T__211=212
    T__212=213
    T__213=214
    T__214=215
    T__215=216
    T__216=217
    T__217=218
    T__218=219
    T__219=220
    T__220=221
    T__221=222
    T__222=223
    T__223=224
    T__224=225
    T__225=226
    T__226=227
    T__227=228
    T__228=229
    T__229=230
    T__230=231
    T__231=232
    T__232=233
    T__233=234
    T__234=235
    T__235=236
    T__236=237
    T__237=238
    T__238=239
    T__239=240
    T__240=241
    T__241=242
    T__242=243
    T__243=244
    T__244=245
    T__245=246
    T__246=247
    T__247=248
    T__248=249
    NEW=250
    IntegerLiteral=251
    FloatingPointLiteral=252
    BooleanLiteral=253
    NullLiteral=254
    NonEmptyStringLiteral=255
    EmptyStringLiteral=256
    LPAREN=257
    RPAREN=258
    LBRACE=259
    RBRACE=260
    LBRACK=261
    RBRACK=262
    SEMI=263
    COMMA=264
    DOT=265
    COLON=266
    TRAVERSAL_ROOT=267
    ANON_TRAVERSAL_ROOT=268
    WS=269
    LINE_COMMENT=270

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class QueryListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def query(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.QueryContext)
            else:
                return self.getTypedRuleContext(GremlinParser.QueryContext,i)


        def EOF(self):
            return self.getToken(GremlinParser.EOF, 0)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.SEMI)
            else:
                return self.getToken(GremlinParser.SEMI, i)

        def getRuleIndex(self):
            return GremlinParser.RULE_queryList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryList" ):
                listener.enterQueryList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryList" ):
                listener.exitQueryList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryList" ):
                return visitor.visitQueryList(self)
            else:
                return visitor.visitChildren(self)




    def queryList(self):

        localctx = GremlinParser.QueryListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_queryList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 444
            self.query(0)
            self.state = 451
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 446
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GremlinParser.SEMI:
                        self.state = 445
                        self.match(GremlinParser.SEMI)


                    self.state = 448
                    self.query(0) 
                self.state = 453
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

            self.state = 455
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GremlinParser.SEMI:
                self.state = 454
                self.match(GremlinParser.SEMI)


            self.state = 457
            self.match(GremlinParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalSource(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def transactionPart(self):
            return self.getTypedRuleContext(GremlinParser.TransactionPartContext,0)


        def rootTraversal(self):
            return self.getTypedRuleContext(GremlinParser.RootTraversalContext,0)


        def traversalTerminalMethod(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTerminalMethodContext,0)


        def emptyQuery(self):
            return self.getTypedRuleContext(GremlinParser.EmptyQueryContext,0)


        def query(self):
            return self.getTypedRuleContext(GremlinParser.QueryContext,0)


        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery" ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery" ):
                listener.exitQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuery" ):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)



    def query(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = GremlinParser.QueryContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 2
        self.enterRecursionRule(localctx, 2, self.RULE_query, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 460
                self.traversalSource(0)
                pass

            elif la_ == 2:
                self.state = 461
                self.traversalSource(0)
                self.state = 462
                self.match(GremlinParser.DOT)
                self.state = 463
                self.transactionPart()
                pass

            elif la_ == 3:
                self.state = 465
                self.rootTraversal()
                pass

            elif la_ == 4:
                self.state = 466
                self.rootTraversal()
                self.state = 467
                self.match(GremlinParser.DOT)
                self.state = 468
                self.traversalTerminalMethod()
                pass

            elif la_ == 5:
                self.state = 470
                self.emptyQuery()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 480
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = GremlinParser.QueryContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_query)
                    self.state = 473
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 474
                    self.match(GremlinParser.DOT)
                    self.state = 475
                    self.match(GremlinParser.T__0)
                    self.state = 476
                    self.match(GremlinParser.LPAREN)
                    self.state = 477
                    self.match(GremlinParser.RPAREN) 
                self.state = 482
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class EmptyQueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EmptyStringLiteral(self):
            return self.getToken(GremlinParser.EmptyStringLiteral, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_emptyQuery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmptyQuery" ):
                listener.enterEmptyQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmptyQuery" ):
                listener.exitEmptyQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEmptyQuery" ):
                return visitor.visitEmptyQuery(self)
            else:
                return visitor.visitChildren(self)




    def emptyQuery(self):

        localctx = GremlinParser.EmptyQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_emptyQuery)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 483
            self.match(GremlinParser.EmptyStringLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRAVERSAL_ROOT(self):
            return self.getToken(GremlinParser.TRAVERSAL_ROOT, 0)

        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def traversalSourceSelfMethod(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSelfMethodContext,0)


        def traversalSource(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSource

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSource" ):
                listener.enterTraversalSource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSource" ):
                listener.exitTraversalSource(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSource" ):
                return visitor.visitTraversalSource(self)
            else:
                return visitor.visitChildren(self)



    def traversalSource(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = GremlinParser.TraversalSourceContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 6
        self.enterRecursionRule(localctx, 6, self.RULE_traversalSource, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 490
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 486
                self.match(GremlinParser.TRAVERSAL_ROOT)
                pass

            elif la_ == 2:
                self.state = 487
                self.match(GremlinParser.TRAVERSAL_ROOT)
                self.state = 488
                self.match(GremlinParser.DOT)
                self.state = 489
                self.traversalSourceSelfMethod()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 497
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = GremlinParser.TraversalSourceContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_traversalSource)
                    self.state = 492
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 493
                    self.match(GremlinParser.DOT)
                    self.state = 494
                    self.traversalSourceSelfMethod() 
                self.state = 499
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TransactionPartContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.LPAREN)
            else:
                return self.getToken(GremlinParser.LPAREN, i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.RPAREN)
            else:
                return self.getToken(GremlinParser.RPAREN, i)

        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_transactionPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTransactionPart" ):
                listener.enterTransactionPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTransactionPart" ):
                listener.exitTransactionPart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTransactionPart" ):
                return visitor.visitTransactionPart(self)
            else:
                return visitor.visitChildren(self)




    def transactionPart(self):

        localctx = GremlinParser.TransactionPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_transactionPart)
        try:
            self.state = 517
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 500
                self.match(GremlinParser.T__1)
                self.state = 501
                self.match(GremlinParser.LPAREN)
                self.state = 502
                self.match(GremlinParser.RPAREN)
                self.state = 503
                self.match(GremlinParser.DOT)
                self.state = 504
                self.match(GremlinParser.T__2)
                self.state = 505
                self.match(GremlinParser.LPAREN)
                self.state = 506
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 507
                self.match(GremlinParser.T__1)
                self.state = 508
                self.match(GremlinParser.LPAREN)
                self.state = 509
                self.match(GremlinParser.RPAREN)
                self.state = 510
                self.match(GremlinParser.DOT)
                self.state = 511
                self.match(GremlinParser.T__3)
                self.state = 512
                self.match(GremlinParser.LPAREN)
                self.state = 513
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 514
                self.match(GremlinParser.T__1)
                self.state = 515
                self.match(GremlinParser.LPAREN)
                self.state = 516
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RootTraversalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalSource(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.DOT)
            else:
                return self.getToken(GremlinParser.DOT, i)

        def traversalSourceSpawnMethod(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSpawnMethodContext,0)


        def chainedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.ChainedTraversalContext,0)


        def chainedParentOfGraphTraversal(self):
            return self.getTypedRuleContext(GremlinParser.ChainedParentOfGraphTraversalContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_rootTraversal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRootTraversal" ):
                listener.enterRootTraversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRootTraversal" ):
                listener.exitRootTraversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRootTraversal" ):
                return visitor.visitRootTraversal(self)
            else:
                return visitor.visitChildren(self)




    def rootTraversal(self):

        localctx = GremlinParser.RootTraversalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_rootTraversal)
        try:
            self.state = 535
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 519
                self.traversalSource(0)
                self.state = 520
                self.match(GremlinParser.DOT)
                self.state = 521
                self.traversalSourceSpawnMethod()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 523
                self.traversalSource(0)
                self.state = 524
                self.match(GremlinParser.DOT)
                self.state = 525
                self.traversalSourceSpawnMethod()
                self.state = 526
                self.match(GremlinParser.DOT)
                self.state = 527
                self.chainedTraversal(0)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 529
                self.traversalSource(0)
                self.state = 530
                self.match(GremlinParser.DOT)
                self.state = 531
                self.traversalSourceSpawnMethod()
                self.state = 532
                self.match(GremlinParser.DOT)
                self.state = 533
                self.chainedParentOfGraphTraversal(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSelfMethodContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalSourceSelfMethod_withBulk(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSelfMethod_withBulkContext,0)


        def traversalSourceSelfMethod_withPath(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSelfMethod_withPathContext,0)


        def traversalSourceSelfMethod_withSack(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSelfMethod_withSackContext,0)


        def traversalSourceSelfMethod_withSideEffect(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSelfMethod_withSideEffectContext,0)


        def traversalSourceSelfMethod_withStrategies(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSelfMethod_withStrategiesContext,0)


        def traversalSourceSelfMethod_with(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSelfMethod_withContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSelfMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSelfMethod" ):
                listener.enterTraversalSourceSelfMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSelfMethod" ):
                listener.exitTraversalSourceSelfMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSelfMethod" ):
                return visitor.visitTraversalSourceSelfMethod(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSelfMethod(self):

        localctx = GremlinParser.TraversalSourceSelfMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_traversalSourceSelfMethod)
        try:
            self.state = 543
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__4]:
                self.enterOuterAlt(localctx, 1)
                self.state = 537
                self.traversalSourceSelfMethod_withBulk()
                pass
            elif token in [GremlinParser.T__5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 538
                self.traversalSourceSelfMethod_withPath()
                pass
            elif token in [GremlinParser.T__6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 539
                self.traversalSourceSelfMethod_withSack()
                pass
            elif token in [GremlinParser.T__7]:
                self.enterOuterAlt(localctx, 4)
                self.state = 540
                self.traversalSourceSelfMethod_withSideEffect()
                pass
            elif token in [GremlinParser.T__8]:
                self.enterOuterAlt(localctx, 5)
                self.state = 541
                self.traversalSourceSelfMethod_withStrategies()
                pass
            elif token in [GremlinParser.T__9]:
                self.enterOuterAlt(localctx, 6)
                self.state = 542
                self.traversalSourceSelfMethod_with()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSelfMethod_withBulkContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def booleanLiteral(self):
            return self.getTypedRuleContext(GremlinParser.BooleanLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSelfMethod_withBulk

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSelfMethod_withBulk" ):
                listener.enterTraversalSourceSelfMethod_withBulk(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSelfMethod_withBulk" ):
                listener.exitTraversalSourceSelfMethod_withBulk(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSelfMethod_withBulk" ):
                return visitor.visitTraversalSourceSelfMethod_withBulk(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSelfMethod_withBulk(self):

        localctx = GremlinParser.TraversalSourceSelfMethod_withBulkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_traversalSourceSelfMethod_withBulk)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 545
            self.match(GremlinParser.T__4)
            self.state = 546
            self.match(GremlinParser.LPAREN)
            self.state = 547
            self.booleanLiteral()
            self.state = 548
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSelfMethod_withPathContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSelfMethod_withPath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSelfMethod_withPath" ):
                listener.enterTraversalSourceSelfMethod_withPath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSelfMethod_withPath" ):
                listener.exitTraversalSourceSelfMethod_withPath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSelfMethod_withPath" ):
                return visitor.visitTraversalSourceSelfMethod_withPath(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSelfMethod_withPath(self):

        localctx = GremlinParser.TraversalSourceSelfMethod_withPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_traversalSourceSelfMethod_withPath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 550
            self.match(GremlinParser.T__5)
            self.state = 551
            self.match(GremlinParser.LPAREN)
            self.state = 552
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSelfMethod_withSackContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)

        def traversalOperator(self):
            return self.getTypedRuleContext(GremlinParser.TraversalOperatorContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSelfMethod_withSack

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSelfMethod_withSack" ):
                listener.enterTraversalSourceSelfMethod_withSack(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSelfMethod_withSack" ):
                listener.exitTraversalSourceSelfMethod_withSack(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSelfMethod_withSack" ):
                return visitor.visitTraversalSourceSelfMethod_withSack(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSelfMethod_withSack(self):

        localctx = GremlinParser.TraversalSourceSelfMethod_withSackContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_traversalSourceSelfMethod_withSack)
        try:
            self.state = 566
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 554
                self.match(GremlinParser.T__6)
                self.state = 555
                self.match(GremlinParser.LPAREN)
                self.state = 556
                self.genericLiteral()
                self.state = 557
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 559
                self.match(GremlinParser.T__6)
                self.state = 560
                self.match(GremlinParser.LPAREN)
                self.state = 561
                self.genericLiteral()
                self.state = 562
                self.match(GremlinParser.COMMA)
                self.state = 563
                self.traversalOperator()
                self.state = 564
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSelfMethod_withSideEffectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)

        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSelfMethod_withSideEffect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSelfMethod_withSideEffect" ):
                listener.enterTraversalSourceSelfMethod_withSideEffect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSelfMethod_withSideEffect" ):
                listener.exitTraversalSourceSelfMethod_withSideEffect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSelfMethod_withSideEffect" ):
                return visitor.visitTraversalSourceSelfMethod_withSideEffect(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSelfMethod_withSideEffect(self):

        localctx = GremlinParser.TraversalSourceSelfMethod_withSideEffectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_traversalSourceSelfMethod_withSideEffect)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 568
            self.match(GremlinParser.T__7)
            self.state = 569
            self.match(GremlinParser.LPAREN)
            self.state = 570
            self.stringLiteral()
            self.state = 571
            self.match(GremlinParser.COMMA)
            self.state = 572
            self.genericLiteral()
            self.state = 573
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSelfMethod_withStrategiesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def traversalStrategy(self):
            return self.getTypedRuleContext(GremlinParser.TraversalStrategyContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)

        def traversalStrategyList(self):
            return self.getTypedRuleContext(GremlinParser.TraversalStrategyListContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSelfMethod_withStrategies

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSelfMethod_withStrategies" ):
                listener.enterTraversalSourceSelfMethod_withStrategies(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSelfMethod_withStrategies" ):
                listener.exitTraversalSourceSelfMethod_withStrategies(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSelfMethod_withStrategies" ):
                return visitor.visitTraversalSourceSelfMethod_withStrategies(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSelfMethod_withStrategies(self):

        localctx = GremlinParser.TraversalSourceSelfMethod_withStrategiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_traversalSourceSelfMethod_withStrategies)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 575
            self.match(GremlinParser.T__8)
            self.state = 576
            self.match(GremlinParser.LPAREN)
            self.state = 577
            self.traversalStrategy()
            self.state = 580
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GremlinParser.COMMA:
                self.state = 578
                self.match(GremlinParser.COMMA)
                self.state = 579
                self.traversalStrategyList()


            self.state = 582
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSelfMethod_withContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)

        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSelfMethod_with

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSelfMethod_with" ):
                listener.enterTraversalSourceSelfMethod_with(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSelfMethod_with" ):
                listener.exitTraversalSourceSelfMethod_with(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSelfMethod_with" ):
                return visitor.visitTraversalSourceSelfMethod_with(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSelfMethod_with(self):

        localctx = GremlinParser.TraversalSourceSelfMethod_withContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_traversalSourceSelfMethod_with)
        try:
            self.state = 596
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 584
                self.match(GremlinParser.T__9)
                self.state = 585
                self.match(GremlinParser.LPAREN)
                self.state = 586
                self.stringLiteral()
                self.state = 587
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 589
                self.match(GremlinParser.T__9)
                self.state = 590
                self.match(GremlinParser.LPAREN)
                self.state = 591
                self.stringLiteral()
                self.state = 592
                self.match(GremlinParser.COMMA)
                self.state = 593
                self.genericLiteral()
                self.state = 594
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSpawnMethodContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalSourceSpawnMethod_addE(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSpawnMethod_addEContext,0)


        def traversalSourceSpawnMethod_addV(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSpawnMethod_addVContext,0)


        def traversalSourceSpawnMethod_E(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSpawnMethod_EContext,0)


        def traversalSourceSpawnMethod_V(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSpawnMethod_VContext,0)


        def traversalSourceSpawnMethod_inject(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSpawnMethod_injectContext,0)


        def traversalSourceSpawnMethod_io(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSourceSpawnMethod_ioContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSpawnMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSpawnMethod" ):
                listener.enterTraversalSourceSpawnMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSpawnMethod" ):
                listener.exitTraversalSourceSpawnMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSpawnMethod" ):
                return visitor.visitTraversalSourceSpawnMethod(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSpawnMethod(self):

        localctx = GremlinParser.TraversalSourceSpawnMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_traversalSourceSpawnMethod)
        try:
            self.state = 604
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__10]:
                self.enterOuterAlt(localctx, 1)
                self.state = 598
                self.traversalSourceSpawnMethod_addE()
                pass
            elif token in [GremlinParser.T__11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 599
                self.traversalSourceSpawnMethod_addV()
                pass
            elif token in [GremlinParser.T__12]:
                self.enterOuterAlt(localctx, 3)
                self.state = 600
                self.traversalSourceSpawnMethod_E()
                pass
            elif token in [GremlinParser.T__13]:
                self.enterOuterAlt(localctx, 4)
                self.state = 601
                self.traversalSourceSpawnMethod_V()
                pass
            elif token in [GremlinParser.T__14]:
                self.enterOuterAlt(localctx, 5)
                self.state = 602
                self.traversalSourceSpawnMethod_inject()
                pass
            elif token in [GremlinParser.T__15]:
                self.enterOuterAlt(localctx, 6)
                self.state = 603
                self.traversalSourceSpawnMethod_io()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSpawnMethod_addEContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSpawnMethod_addE

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSpawnMethod_addE" ):
                listener.enterTraversalSourceSpawnMethod_addE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSpawnMethod_addE" ):
                listener.exitTraversalSourceSpawnMethod_addE(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSpawnMethod_addE" ):
                return visitor.visitTraversalSourceSpawnMethod_addE(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSpawnMethod_addE(self):

        localctx = GremlinParser.TraversalSourceSpawnMethod_addEContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_traversalSourceSpawnMethod_addE)
        try:
            self.state = 616
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 606
                self.match(GremlinParser.T__10)
                self.state = 607
                self.match(GremlinParser.LPAREN)
                self.state = 608
                self.stringLiteral()
                self.state = 609
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 611
                self.match(GremlinParser.T__10)
                self.state = 612
                self.match(GremlinParser.LPAREN)
                self.state = 613
                self.nestedTraversal()
                self.state = 614
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSpawnMethod_addVContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def nullLiteral(self):
            return self.getTypedRuleContext(GremlinParser.NullLiteralContext,0)


        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSpawnMethod_addV

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSpawnMethod_addV" ):
                listener.enterTraversalSourceSpawnMethod_addV(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSpawnMethod_addV" ):
                listener.exitTraversalSourceSpawnMethod_addV(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSpawnMethod_addV" ):
                return visitor.visitTraversalSourceSpawnMethod_addV(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSpawnMethod_addV(self):

        localctx = GremlinParser.TraversalSourceSpawnMethod_addVContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_traversalSourceSpawnMethod_addV)
        try:
            self.state = 636
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 618
                self.match(GremlinParser.T__11)
                self.state = 619
                self.match(GremlinParser.LPAREN)
                self.state = 620
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 621
                self.match(GremlinParser.T__11)
                self.state = 622
                self.match(GremlinParser.LPAREN)
                self.state = 623
                self.stringLiteral()
                self.state = 624
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 626
                self.match(GremlinParser.T__11)
                self.state = 627
                self.match(GremlinParser.LPAREN)
                self.state = 628
                self.nullLiteral()
                self.state = 629
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 631
                self.match(GremlinParser.T__11)
                self.state = 632
                self.match(GremlinParser.LPAREN)
                self.state = 633
                self.nestedTraversal()
                self.state = 634
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSpawnMethod_EContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSpawnMethod_E

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSpawnMethod_E" ):
                listener.enterTraversalSourceSpawnMethod_E(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSpawnMethod_E" ):
                listener.exitTraversalSourceSpawnMethod_E(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSpawnMethod_E" ):
                return visitor.visitTraversalSourceSpawnMethod_E(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSpawnMethod_E(self):

        localctx = GremlinParser.TraversalSourceSpawnMethod_EContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_traversalSourceSpawnMethod_E)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 638
            self.match(GremlinParser.T__12)
            self.state = 639
            self.match(GremlinParser.LPAREN)
            self.state = 640
            self.genericLiteralList()
            self.state = 641
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSpawnMethod_VContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSpawnMethod_V

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSpawnMethod_V" ):
                listener.enterTraversalSourceSpawnMethod_V(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSpawnMethod_V" ):
                listener.exitTraversalSourceSpawnMethod_V(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSpawnMethod_V" ):
                return visitor.visitTraversalSourceSpawnMethod_V(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSpawnMethod_V(self):

        localctx = GremlinParser.TraversalSourceSpawnMethod_VContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_traversalSourceSpawnMethod_V)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 643
            self.match(GremlinParser.T__13)
            self.state = 644
            self.match(GremlinParser.LPAREN)
            self.state = 645
            self.genericLiteralList()
            self.state = 646
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSpawnMethod_injectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSpawnMethod_inject

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSpawnMethod_inject" ):
                listener.enterTraversalSourceSpawnMethod_inject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSpawnMethod_inject" ):
                listener.exitTraversalSourceSpawnMethod_inject(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSpawnMethod_inject" ):
                return visitor.visitTraversalSourceSpawnMethod_inject(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSpawnMethod_inject(self):

        localctx = GremlinParser.TraversalSourceSpawnMethod_injectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_traversalSourceSpawnMethod_inject)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 648
            self.match(GremlinParser.T__14)
            self.state = 649
            self.match(GremlinParser.LPAREN)
            self.state = 650
            self.genericLiteralList()
            self.state = 651
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSourceSpawnMethod_ioContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSourceSpawnMethod_io

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSourceSpawnMethod_io" ):
                listener.enterTraversalSourceSpawnMethod_io(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSourceSpawnMethod_io" ):
                listener.exitTraversalSourceSpawnMethod_io(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSourceSpawnMethod_io" ):
                return visitor.visitTraversalSourceSpawnMethod_io(self)
            else:
                return visitor.visitChildren(self)




    def traversalSourceSpawnMethod_io(self):

        localctx = GremlinParser.TraversalSourceSpawnMethod_ioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_traversalSourceSpawnMethod_io)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 653
            self.match(GremlinParser.T__15)
            self.state = 654
            self.match(GremlinParser.LPAREN)
            self.state = 655
            self.stringLiteral()
            self.state = 656
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChainedTraversalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalMethod(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethodContext,0)


        def chainedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.ChainedTraversalContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def chainedParentOfGraphTraversal(self):
            return self.getTypedRuleContext(GremlinParser.ChainedParentOfGraphTraversalContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_chainedTraversal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChainedTraversal" ):
                listener.enterChainedTraversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChainedTraversal" ):
                listener.exitChainedTraversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChainedTraversal" ):
                return visitor.visitChainedTraversal(self)
            else:
                return visitor.visitChildren(self)



    def chainedTraversal(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = GremlinParser.ChainedTraversalContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 40
        self.enterRecursionRule(localctx, 40, self.RULE_chainedTraversal, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 659
            self.traversalMethod()
            self._ctx.stop = self._input.LT(-1)
            self.state = 669
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,17,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 667
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
                    if la_ == 1:
                        localctx = GremlinParser.ChainedTraversalContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_chainedTraversal)
                        self.state = 661
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 662
                        self.match(GremlinParser.DOT)
                        self.state = 663
                        self.traversalMethod()
                        pass

                    elif la_ == 2:
                        localctx = GremlinParser.ChainedTraversalContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_chainedTraversal)
                        self.state = 664
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 665
                        self.match(GremlinParser.DOT)
                        self.state = 666
                        self.chainedParentOfGraphTraversal(0)
                        pass

             
                self.state = 671
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ChainedParentOfGraphTraversalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalSelfMethod(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSelfMethodContext,0)


        def chainedParentOfGraphTraversal(self):
            return self.getTypedRuleContext(GremlinParser.ChainedParentOfGraphTraversalContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_chainedParentOfGraphTraversal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChainedParentOfGraphTraversal" ):
                listener.enterChainedParentOfGraphTraversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChainedParentOfGraphTraversal" ):
                listener.exitChainedParentOfGraphTraversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChainedParentOfGraphTraversal" ):
                return visitor.visitChainedParentOfGraphTraversal(self)
            else:
                return visitor.visitChildren(self)



    def chainedParentOfGraphTraversal(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = GremlinParser.ChainedParentOfGraphTraversalContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 42
        self.enterRecursionRule(localctx, 42, self.RULE_chainedParentOfGraphTraversal, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 673
            self.traversalSelfMethod()
            self._ctx.stop = self._input.LT(-1)
            self.state = 680
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = GremlinParser.ChainedParentOfGraphTraversalContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_chainedParentOfGraphTraversal)
                    self.state = 675
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 676
                    self.match(GremlinParser.DOT)
                    self.state = 677
                    self.traversalSelfMethod() 
                self.state = 682
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class NestedTraversalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rootTraversal(self):
            return self.getTypedRuleContext(GremlinParser.RootTraversalContext,0)


        def chainedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.ChainedTraversalContext,0)


        def ANON_TRAVERSAL_ROOT(self):
            return self.getToken(GremlinParser.ANON_TRAVERSAL_ROOT, 0)

        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_nestedTraversal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedTraversal" ):
                listener.enterNestedTraversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedTraversal" ):
                listener.exitNestedTraversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNestedTraversal" ):
                return visitor.visitNestedTraversal(self)
            else:
                return visitor.visitChildren(self)




    def nestedTraversal(self):

        localctx = GremlinParser.NestedTraversalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_nestedTraversal)
        try:
            self.state = 688
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.TRAVERSAL_ROOT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 683
                self.rootTraversal()
                pass
            elif token in [GremlinParser.T__9, GremlinParser.T__10, GremlinParser.T__11, GremlinParser.T__13, GremlinParser.T__14, GremlinParser.T__16, GremlinParser.T__17, GremlinParser.T__18, GremlinParser.T__19, GremlinParser.T__20, GremlinParser.T__21, GremlinParser.T__22, GremlinParser.T__23, GremlinParser.T__24, GremlinParser.T__25, GremlinParser.T__26, GremlinParser.T__27, GremlinParser.T__28, GremlinParser.T__29, GremlinParser.T__30, GremlinParser.T__31, GremlinParser.T__32, GremlinParser.T__33, GremlinParser.T__34, GremlinParser.T__35, GremlinParser.T__36, GremlinParser.T__37, GremlinParser.T__38, GremlinParser.T__39, GremlinParser.T__40, GremlinParser.T__41, GremlinParser.T__42, GremlinParser.T__43, GremlinParser.T__44, GremlinParser.T__45, GremlinParser.T__46, GremlinParser.T__47, GremlinParser.T__48, GremlinParser.T__49, GremlinParser.T__50, GremlinParser.T__51, GremlinParser.T__52, GremlinParser.T__53, GremlinParser.T__54, GremlinParser.T__55, GremlinParser.T__56, GremlinParser.T__57, GremlinParser.T__58, GremlinParser.T__59, GremlinParser.T__60, GremlinParser.T__61, GremlinParser.T__62, GremlinParser.T__63, GremlinParser.T__64, GremlinParser.T__65, GremlinParser.T__66, GremlinParser.T__67, GremlinParser.T__68, GremlinParser.T__69, GremlinParser.T__70, GremlinParser.T__71, GremlinParser.T__72, GremlinParser.T__73, GremlinParser.T__74, GremlinParser.T__75, GremlinParser.T__76, GremlinParser.T__77, GremlinParser.T__78, GremlinParser.T__79, GremlinParser.T__80, GremlinParser.T__81, GremlinParser.T__82, GremlinParser.T__83, GremlinParser.T__84, GremlinParser.T__85, GremlinParser.T__86, GremlinParser.T__87, GremlinParser.T__88, GremlinParser.T__89, GremlinParser.T__90, GremlinParser.T__91, GremlinParser.T__92, GremlinParser.T__93, GremlinParser.T__94, GremlinParser.T__95, GremlinParser.T__96, GremlinParser.T__97, GremlinParser.T__98, GremlinParser.T__99, GremlinParser.T__100, GremlinParser.T__101, GremlinParser.T__102, GremlinParser.T__103, GremlinParser.T__104, GremlinParser.T__105, GremlinParser.T__106, GremlinParser.T__107, GremlinParser.T__108, GremlinParser.T__109, GremlinParser.T__110, GremlinParser.T__111]:
                self.enterOuterAlt(localctx, 2)
                self.state = 684
                self.chainedTraversal(0)
                pass
            elif token in [GremlinParser.ANON_TRAVERSAL_ROOT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 685
                self.match(GremlinParser.ANON_TRAVERSAL_ROOT)
                self.state = 686
                self.match(GremlinParser.DOT)
                self.state = 687
                self.chainedTraversal(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TerminatedTraversalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rootTraversal(self):
            return self.getTypedRuleContext(GremlinParser.RootTraversalContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def traversalTerminalMethod(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTerminalMethodContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_terminatedTraversal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerminatedTraversal" ):
                listener.enterTerminatedTraversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerminatedTraversal" ):
                listener.exitTerminatedTraversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerminatedTraversal" ):
                return visitor.visitTerminatedTraversal(self)
            else:
                return visitor.visitChildren(self)




    def terminatedTraversal(self):

        localctx = GremlinParser.TerminatedTraversalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_terminatedTraversal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 690
            self.rootTraversal()
            self.state = 691
            self.match(GremlinParser.DOT)
            self.state = 692
            self.traversalTerminalMethod()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethodContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalMethod_V(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_VContext,0)


        def traversalMethod_addE(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_addEContext,0)


        def traversalMethod_addV(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_addVContext,0)


        def traversalMethod_aggregate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_aggregateContext,0)


        def traversalMethod_and(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_andContext,0)


        def traversalMethod_as(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_asContext,0)


        def traversalMethod_barrier(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_barrierContext,0)


        def traversalMethod_both(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_bothContext,0)


        def traversalMethod_bothE(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_bothEContext,0)


        def traversalMethod_bothV(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_bothVContext,0)


        def traversalMethod_branch(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_branchContext,0)


        def traversalMethod_by(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_byContext,0)


        def traversalMethod_cap(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_capContext,0)


        def traversalMethod_choose(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_chooseContext,0)


        def traversalMethod_coalesce(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_coalesceContext,0)


        def traversalMethod_coin(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_coinContext,0)


        def traversalMethod_connectedComponent(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_connectedComponentContext,0)


        def traversalMethod_constant(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_constantContext,0)


        def traversalMethod_count(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_countContext,0)


        def traversalMethod_cyclicPath(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_cyclicPathContext,0)


        def traversalMethod_dedup(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_dedupContext,0)


        def traversalMethod_drop(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_dropContext,0)


        def traversalMethod_elementMap(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_elementMapContext,0)


        def traversalMethod_emit(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_emitContext,0)


        def traversalMethod_filter(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_filterContext,0)


        def traversalMethod_flatMap(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_flatMapContext,0)


        def traversalMethod_fold(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_foldContext,0)


        def traversalMethod_from(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_fromContext,0)


        def traversalMethod_group(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_groupContext,0)


        def traversalMethod_groupCount(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_groupCountContext,0)


        def traversalMethod_has(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_hasContext,0)


        def traversalMethod_hasId(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_hasIdContext,0)


        def traversalMethod_hasKey(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_hasKeyContext,0)


        def traversalMethod_hasLabel(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_hasLabelContext,0)


        def traversalMethod_hasNot(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_hasNotContext,0)


        def traversalMethod_hasValue(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_hasValueContext,0)


        def traversalMethod_id(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_idContext,0)


        def traversalMethod_identity(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_identityContext,0)


        def traversalMethod_in(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_inContext,0)


        def traversalMethod_inE(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_inEContext,0)


        def traversalMethod_inV(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_inVContext,0)


        def traversalMethod_index(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_indexContext,0)


        def traversalMethod_inject(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_injectContext,0)


        def traversalMethod_is(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_isContext,0)


        def traversalMethod_key(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_keyContext,0)


        def traversalMethod_label(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_labelContext,0)


        def traversalMethod_limit(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_limitContext,0)


        def traversalMethod_local(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_localContext,0)


        def traversalMethod_loops(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_loopsContext,0)


        def traversalMethod_map(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_mapContext,0)


        def traversalMethod_match(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_matchContext,0)


        def traversalMethod_math(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_mathContext,0)


        def traversalMethod_max(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_maxContext,0)


        def traversalMethod_mean(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_meanContext,0)


        def traversalMethod_min(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_minContext,0)


        def traversalMethod_not(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_notContext,0)


        def traversalMethod_option(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_optionContext,0)


        def traversalMethod_optional(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_optionalContext,0)


        def traversalMethod_or(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_orContext,0)


        def traversalMethod_order(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_orderContext,0)


        def traversalMethod_otherV(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_otherVContext,0)


        def traversalMethod_out(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_outContext,0)


        def traversalMethod_outE(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_outEContext,0)


        def traversalMethod_outV(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_outVContext,0)


        def traversalMethod_pageRank(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_pageRankContext,0)


        def traversalMethod_path(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_pathContext,0)


        def traversalMethod_peerPressure(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_peerPressureContext,0)


        def traversalMethod_profile(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_profileContext,0)


        def traversalMethod_project(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_projectContext,0)


        def traversalMethod_properties(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_propertiesContext,0)


        def traversalMethod_property(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_propertyContext,0)


        def traversalMethod_propertyMap(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_propertyMapContext,0)


        def traversalMethod_range(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_rangeContext,0)


        def traversalMethod_read(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_readContext,0)


        def traversalMethod_repeat(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_repeatContext,0)


        def traversalMethod_sack(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_sackContext,0)


        def traversalMethod_sample(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_sampleContext,0)


        def traversalMethod_select(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_selectContext,0)


        def traversalMethod_shortestPath(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_shortestPathContext,0)


        def traversalMethod_sideEffect(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_sideEffectContext,0)


        def traversalMethod_simplePath(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_simplePathContext,0)


        def traversalMethod_skip(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_skipContext,0)


        def traversalMethod_store(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_storeContext,0)


        def traversalMethod_subgraph(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_subgraphContext,0)


        def traversalMethod_sum(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_sumContext,0)


        def traversalMethod_tail(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_tailContext,0)


        def traversalMethod_timeLimit(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_timeLimitContext,0)


        def traversalMethod_times(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_timesContext,0)


        def traversalMethod_to(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_toContext,0)


        def traversalMethod_toE(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_toEContext,0)


        def traversalMethod_toV(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_toVContext,0)


        def traversalMethod_tree(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_treeContext,0)


        def traversalMethod_unfold(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_unfoldContext,0)


        def traversalMethod_union(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_unionContext,0)


        def traversalMethod_until(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_untilContext,0)


        def traversalMethod_value(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_valueContext,0)


        def traversalMethod_valueMap(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_valueMapContext,0)


        def traversalMethod_values(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_valuesContext,0)


        def traversalMethod_where(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_whereContext,0)


        def traversalMethod_with(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_withContext,0)


        def traversalMethod_write(self):
            return self.getTypedRuleContext(GremlinParser.TraversalMethod_writeContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod" ):
                listener.enterTraversalMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod" ):
                listener.exitTraversalMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod" ):
                return visitor.visitTraversalMethod(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod(self):

        localctx = GremlinParser.TraversalMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_traversalMethod)
        try:
            self.state = 795
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__13]:
                self.enterOuterAlt(localctx, 1)
                self.state = 694
                self.traversalMethod_V()
                pass
            elif token in [GremlinParser.T__10]:
                self.enterOuterAlt(localctx, 2)
                self.state = 695
                self.traversalMethod_addE()
                pass
            elif token in [GremlinParser.T__11]:
                self.enterOuterAlt(localctx, 3)
                self.state = 696
                self.traversalMethod_addV()
                pass
            elif token in [GremlinParser.T__16]:
                self.enterOuterAlt(localctx, 4)
                self.state = 697
                self.traversalMethod_aggregate()
                pass
            elif token in [GremlinParser.T__17]:
                self.enterOuterAlt(localctx, 5)
                self.state = 698
                self.traversalMethod_and()
                pass
            elif token in [GremlinParser.T__18]:
                self.enterOuterAlt(localctx, 6)
                self.state = 699
                self.traversalMethod_as()
                pass
            elif token in [GremlinParser.T__19]:
                self.enterOuterAlt(localctx, 7)
                self.state = 700
                self.traversalMethod_barrier()
                pass
            elif token in [GremlinParser.T__20]:
                self.enterOuterAlt(localctx, 8)
                self.state = 701
                self.traversalMethod_both()
                pass
            elif token in [GremlinParser.T__21]:
                self.enterOuterAlt(localctx, 9)
                self.state = 702
                self.traversalMethod_bothE()
                pass
            elif token in [GremlinParser.T__22]:
                self.enterOuterAlt(localctx, 10)
                self.state = 703
                self.traversalMethod_bothV()
                pass
            elif token in [GremlinParser.T__23]:
                self.enterOuterAlt(localctx, 11)
                self.state = 704
                self.traversalMethod_branch()
                pass
            elif token in [GremlinParser.T__24]:
                self.enterOuterAlt(localctx, 12)
                self.state = 705
                self.traversalMethod_by()
                pass
            elif token in [GremlinParser.T__25]:
                self.enterOuterAlt(localctx, 13)
                self.state = 706
                self.traversalMethod_cap()
                pass
            elif token in [GremlinParser.T__26]:
                self.enterOuterAlt(localctx, 14)
                self.state = 707
                self.traversalMethod_choose()
                pass
            elif token in [GremlinParser.T__27]:
                self.enterOuterAlt(localctx, 15)
                self.state = 708
                self.traversalMethod_coalesce()
                pass
            elif token in [GremlinParser.T__28]:
                self.enterOuterAlt(localctx, 16)
                self.state = 709
                self.traversalMethod_coin()
                pass
            elif token in [GremlinParser.T__29]:
                self.enterOuterAlt(localctx, 17)
                self.state = 710
                self.traversalMethod_connectedComponent()
                pass
            elif token in [GremlinParser.T__30]:
                self.enterOuterAlt(localctx, 18)
                self.state = 711
                self.traversalMethod_constant()
                pass
            elif token in [GremlinParser.T__31]:
                self.enterOuterAlt(localctx, 19)
                self.state = 712
                self.traversalMethod_count()
                pass
            elif token in [GremlinParser.T__32]:
                self.enterOuterAlt(localctx, 20)
                self.state = 713
                self.traversalMethod_cyclicPath()
                pass
            elif token in [GremlinParser.T__33]:
                self.enterOuterAlt(localctx, 21)
                self.state = 714
                self.traversalMethod_dedup()
                pass
            elif token in [GremlinParser.T__34]:
                self.enterOuterAlt(localctx, 22)
                self.state = 715
                self.traversalMethod_drop()
                pass
            elif token in [GremlinParser.T__35]:
                self.enterOuterAlt(localctx, 23)
                self.state = 716
                self.traversalMethod_elementMap()
                pass
            elif token in [GremlinParser.T__36]:
                self.enterOuterAlt(localctx, 24)
                self.state = 717
                self.traversalMethod_emit()
                pass
            elif token in [GremlinParser.T__37]:
                self.enterOuterAlt(localctx, 25)
                self.state = 718
                self.traversalMethod_filter()
                pass
            elif token in [GremlinParser.T__38]:
                self.enterOuterAlt(localctx, 26)
                self.state = 719
                self.traversalMethod_flatMap()
                pass
            elif token in [GremlinParser.T__39]:
                self.enterOuterAlt(localctx, 27)
                self.state = 720
                self.traversalMethod_fold()
                pass
            elif token in [GremlinParser.T__40]:
                self.enterOuterAlt(localctx, 28)
                self.state = 721
                self.traversalMethod_from()
                pass
            elif token in [GremlinParser.T__41]:
                self.enterOuterAlt(localctx, 29)
                self.state = 722
                self.traversalMethod_group()
                pass
            elif token in [GremlinParser.T__42]:
                self.enterOuterAlt(localctx, 30)
                self.state = 723
                self.traversalMethod_groupCount()
                pass
            elif token in [GremlinParser.T__43]:
                self.enterOuterAlt(localctx, 31)
                self.state = 724
                self.traversalMethod_has()
                pass
            elif token in [GremlinParser.T__44]:
                self.enterOuterAlt(localctx, 32)
                self.state = 725
                self.traversalMethod_hasId()
                pass
            elif token in [GremlinParser.T__45]:
                self.enterOuterAlt(localctx, 33)
                self.state = 726
                self.traversalMethod_hasKey()
                pass
            elif token in [GremlinParser.T__46]:
                self.enterOuterAlt(localctx, 34)
                self.state = 727
                self.traversalMethod_hasLabel()
                pass
            elif token in [GremlinParser.T__47]:
                self.enterOuterAlt(localctx, 35)
                self.state = 728
                self.traversalMethod_hasNot()
                pass
            elif token in [GremlinParser.T__48]:
                self.enterOuterAlt(localctx, 36)
                self.state = 729
                self.traversalMethod_hasValue()
                pass
            elif token in [GremlinParser.T__49]:
                self.enterOuterAlt(localctx, 37)
                self.state = 730
                self.traversalMethod_id()
                pass
            elif token in [GremlinParser.T__50]:
                self.enterOuterAlt(localctx, 38)
                self.state = 731
                self.traversalMethod_identity()
                pass
            elif token in [GremlinParser.T__51]:
                self.enterOuterAlt(localctx, 39)
                self.state = 732
                self.traversalMethod_in()
                pass
            elif token in [GremlinParser.T__52]:
                self.enterOuterAlt(localctx, 40)
                self.state = 733
                self.traversalMethod_inE()
                pass
            elif token in [GremlinParser.T__53]:
                self.enterOuterAlt(localctx, 41)
                self.state = 734
                self.traversalMethod_inV()
                pass
            elif token in [GremlinParser.T__54]:
                self.enterOuterAlt(localctx, 42)
                self.state = 735
                self.traversalMethod_index()
                pass
            elif token in [GremlinParser.T__14]:
                self.enterOuterAlt(localctx, 43)
                self.state = 736
                self.traversalMethod_inject()
                pass
            elif token in [GremlinParser.T__55]:
                self.enterOuterAlt(localctx, 44)
                self.state = 737
                self.traversalMethod_is()
                pass
            elif token in [GremlinParser.T__56]:
                self.enterOuterAlt(localctx, 45)
                self.state = 738
                self.traversalMethod_key()
                pass
            elif token in [GremlinParser.T__57]:
                self.enterOuterAlt(localctx, 46)
                self.state = 739
                self.traversalMethod_label()
                pass
            elif token in [GremlinParser.T__58]:
                self.enterOuterAlt(localctx, 47)
                self.state = 740
                self.traversalMethod_limit()
                pass
            elif token in [GremlinParser.T__59]:
                self.enterOuterAlt(localctx, 48)
                self.state = 741
                self.traversalMethod_local()
                pass
            elif token in [GremlinParser.T__60]:
                self.enterOuterAlt(localctx, 49)
                self.state = 742
                self.traversalMethod_loops()
                pass
            elif token in [GremlinParser.T__61]:
                self.enterOuterAlt(localctx, 50)
                self.state = 743
                self.traversalMethod_map()
                pass
            elif token in [GremlinParser.T__62]:
                self.enterOuterAlt(localctx, 51)
                self.state = 744
                self.traversalMethod_match()
                pass
            elif token in [GremlinParser.T__63]:
                self.enterOuterAlt(localctx, 52)
                self.state = 745
                self.traversalMethod_math()
                pass
            elif token in [GremlinParser.T__64]:
                self.enterOuterAlt(localctx, 53)
                self.state = 746
                self.traversalMethod_max()
                pass
            elif token in [GremlinParser.T__65]:
                self.enterOuterAlt(localctx, 54)
                self.state = 747
                self.traversalMethod_mean()
                pass
            elif token in [GremlinParser.T__66]:
                self.enterOuterAlt(localctx, 55)
                self.state = 748
                self.traversalMethod_min()
                pass
            elif token in [GremlinParser.T__67]:
                self.enterOuterAlt(localctx, 56)
                self.state = 749
                self.traversalMethod_not()
                pass
            elif token in [GremlinParser.T__68]:
                self.enterOuterAlt(localctx, 57)
                self.state = 750
                self.traversalMethod_option()
                pass
            elif token in [GremlinParser.T__69]:
                self.enterOuterAlt(localctx, 58)
                self.state = 751
                self.traversalMethod_optional()
                pass
            elif token in [GremlinParser.T__70]:
                self.enterOuterAlt(localctx, 59)
                self.state = 752
                self.traversalMethod_or()
                pass
            elif token in [GremlinParser.T__71]:
                self.enterOuterAlt(localctx, 60)
                self.state = 753
                self.traversalMethod_order()
                pass
            elif token in [GremlinParser.T__72]:
                self.enterOuterAlt(localctx, 61)
                self.state = 754
                self.traversalMethod_otherV()
                pass
            elif token in [GremlinParser.T__73]:
                self.enterOuterAlt(localctx, 62)
                self.state = 755
                self.traversalMethod_out()
                pass
            elif token in [GremlinParser.T__74]:
                self.enterOuterAlt(localctx, 63)
                self.state = 756
                self.traversalMethod_outE()
                pass
            elif token in [GremlinParser.T__75]:
                self.enterOuterAlt(localctx, 64)
                self.state = 757
                self.traversalMethod_outV()
                pass
            elif token in [GremlinParser.T__76]:
                self.enterOuterAlt(localctx, 65)
                self.state = 758
                self.traversalMethod_pageRank()
                pass
            elif token in [GremlinParser.T__77]:
                self.enterOuterAlt(localctx, 66)
                self.state = 759
                self.traversalMethod_path()
                pass
            elif token in [GremlinParser.T__78]:
                self.enterOuterAlt(localctx, 67)
                self.state = 760
                self.traversalMethod_peerPressure()
                pass
            elif token in [GremlinParser.T__79]:
                self.enterOuterAlt(localctx, 68)
                self.state = 761
                self.traversalMethod_profile()
                pass
            elif token in [GremlinParser.T__80]:
                self.enterOuterAlt(localctx, 69)
                self.state = 762
                self.traversalMethod_project()
                pass
            elif token in [GremlinParser.T__81]:
                self.enterOuterAlt(localctx, 70)
                self.state = 763
                self.traversalMethod_properties()
                pass
            elif token in [GremlinParser.T__82]:
                self.enterOuterAlt(localctx, 71)
                self.state = 764
                self.traversalMethod_property()
                pass
            elif token in [GremlinParser.T__83]:
                self.enterOuterAlt(localctx, 72)
                self.state = 765
                self.traversalMethod_propertyMap()
                pass
            elif token in [GremlinParser.T__84]:
                self.enterOuterAlt(localctx, 73)
                self.state = 766
                self.traversalMethod_range()
                pass
            elif token in [GremlinParser.T__85]:
                self.enterOuterAlt(localctx, 74)
                self.state = 767
                self.traversalMethod_read()
                pass
            elif token in [GremlinParser.T__86]:
                self.enterOuterAlt(localctx, 75)
                self.state = 768
                self.traversalMethod_repeat()
                pass
            elif token in [GremlinParser.T__87]:
                self.enterOuterAlt(localctx, 76)
                self.state = 769
                self.traversalMethod_sack()
                pass
            elif token in [GremlinParser.T__88]:
                self.enterOuterAlt(localctx, 77)
                self.state = 770
                self.traversalMethod_sample()
                pass
            elif token in [GremlinParser.T__89]:
                self.enterOuterAlt(localctx, 78)
                self.state = 771
                self.traversalMethod_select()
                pass
            elif token in [GremlinParser.T__90]:
                self.enterOuterAlt(localctx, 79)
                self.state = 772
                self.traversalMethod_shortestPath()
                pass
            elif token in [GremlinParser.T__91]:
                self.enterOuterAlt(localctx, 80)
                self.state = 773
                self.traversalMethod_sideEffect()
                pass
            elif token in [GremlinParser.T__92]:
                self.enterOuterAlt(localctx, 81)
                self.state = 774
                self.traversalMethod_simplePath()
                pass
            elif token in [GremlinParser.T__93]:
                self.enterOuterAlt(localctx, 82)
                self.state = 775
                self.traversalMethod_skip()
                pass
            elif token in [GremlinParser.T__94]:
                self.enterOuterAlt(localctx, 83)
                self.state = 776
                self.traversalMethod_store()
                pass
            elif token in [GremlinParser.T__95]:
                self.enterOuterAlt(localctx, 84)
                self.state = 777
                self.traversalMethod_subgraph()
                pass
            elif token in [GremlinParser.T__96]:
                self.enterOuterAlt(localctx, 85)
                self.state = 778
                self.traversalMethod_sum()
                pass
            elif token in [GremlinParser.T__97]:
                self.enterOuterAlt(localctx, 86)
                self.state = 779
                self.traversalMethod_tail()
                pass
            elif token in [GremlinParser.T__98]:
                self.enterOuterAlt(localctx, 87)
                self.state = 780
                self.traversalMethod_timeLimit()
                pass
            elif token in [GremlinParser.T__99]:
                self.enterOuterAlt(localctx, 88)
                self.state = 781
                self.traversalMethod_times()
                pass
            elif token in [GremlinParser.T__100]:
                self.enterOuterAlt(localctx, 89)
                self.state = 782
                self.traversalMethod_to()
                pass
            elif token in [GremlinParser.T__101]:
                self.enterOuterAlt(localctx, 90)
                self.state = 783
                self.traversalMethod_toE()
                pass
            elif token in [GremlinParser.T__102]:
                self.enterOuterAlt(localctx, 91)
                self.state = 784
                self.traversalMethod_toV()
                pass
            elif token in [GremlinParser.T__103]:
                self.enterOuterAlt(localctx, 92)
                self.state = 785
                self.traversalMethod_tree()
                pass
            elif token in [GremlinParser.T__104]:
                self.enterOuterAlt(localctx, 93)
                self.state = 786
                self.traversalMethod_unfold()
                pass
            elif token in [GremlinParser.T__105]:
                self.enterOuterAlt(localctx, 94)
                self.state = 787
                self.traversalMethod_union()
                pass
            elif token in [GremlinParser.T__106]:
                self.enterOuterAlt(localctx, 95)
                self.state = 788
                self.traversalMethod_until()
                pass
            elif token in [GremlinParser.T__107]:
                self.enterOuterAlt(localctx, 96)
                self.state = 789
                self.traversalMethod_value()
                pass
            elif token in [GremlinParser.T__108]:
                self.enterOuterAlt(localctx, 97)
                self.state = 790
                self.traversalMethod_valueMap()
                pass
            elif token in [GremlinParser.T__109]:
                self.enterOuterAlt(localctx, 98)
                self.state = 791
                self.traversalMethod_values()
                pass
            elif token in [GremlinParser.T__110]:
                self.enterOuterAlt(localctx, 99)
                self.state = 792
                self.traversalMethod_where()
                pass
            elif token in [GremlinParser.T__9]:
                self.enterOuterAlt(localctx, 100)
                self.state = 793
                self.traversalMethod_with()
                pass
            elif token in [GremlinParser.T__111]:
                self.enterOuterAlt(localctx, 101)
                self.state = 794
                self.traversalMethod_write()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_VContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_V

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_V" ):
                listener.enterTraversalMethod_V(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_V" ):
                listener.exitTraversalMethod_V(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_V" ):
                return visitor.visitTraversalMethod_V(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_V(self):

        localctx = GremlinParser.TraversalMethod_VContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_traversalMethod_V)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 797
            self.match(GremlinParser.T__13)
            self.state = 798
            self.match(GremlinParser.LPAREN)
            self.state = 799
            self.genericLiteralList()
            self.state = 800
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_addEContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_addE

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_addE_TraversalContext(TraversalMethod_addEContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_addEContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_addE_Traversal" ):
                listener.enterTraversalMethod_addE_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_addE_Traversal" ):
                listener.exitTraversalMethod_addE_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_addE_Traversal" ):
                return visitor.visitTraversalMethod_addE_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_addE_StringContext(TraversalMethod_addEContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_addEContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_addE_String" ):
                listener.enterTraversalMethod_addE_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_addE_String" ):
                listener.exitTraversalMethod_addE_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_addE_String" ):
                return visitor.visitTraversalMethod_addE_String(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_addE(self):

        localctx = GremlinParser.TraversalMethod_addEContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_traversalMethod_addE)
        try:
            self.state = 812
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_addE_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 802
                self.match(GremlinParser.T__10)
                self.state = 803
                self.match(GremlinParser.LPAREN)
                self.state = 804
                self.stringLiteral()
                self.state = 805
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_addE_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 807
                self.match(GremlinParser.T__10)
                self.state = 808
                self.match(GremlinParser.LPAREN)
                self.state = 809
                self.nestedTraversal()
                self.state = 810
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_addVContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_addV

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_addV_TraversalContext(TraversalMethod_addVContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_addVContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_addV_Traversal" ):
                listener.enterTraversalMethod_addV_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_addV_Traversal" ):
                listener.exitTraversalMethod_addV_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_addV_Traversal" ):
                return visitor.visitTraversalMethod_addV_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_addV_EmptyContext(TraversalMethod_addVContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_addVContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_addV_Empty" ):
                listener.enterTraversalMethod_addV_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_addV_Empty" ):
                listener.exitTraversalMethod_addV_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_addV_Empty" ):
                return visitor.visitTraversalMethod_addV_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_addV_StringContext(TraversalMethod_addVContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_addVContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def nullLiteral(self):
            return self.getTypedRuleContext(GremlinParser.NullLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_addV_String" ):
                listener.enterTraversalMethod_addV_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_addV_String" ):
                listener.exitTraversalMethod_addV_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_addV_String" ):
                return visitor.visitTraversalMethod_addV_String(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_addV(self):

        localctx = GremlinParser.TraversalMethod_addVContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_traversalMethod_addV)
        try:
            self.state = 832
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_addV_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 814
                self.match(GremlinParser.T__11)
                self.state = 815
                self.match(GremlinParser.LPAREN)
                self.state = 816
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_addV_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 817
                self.match(GremlinParser.T__11)
                self.state = 818
                self.match(GremlinParser.LPAREN)
                self.state = 819
                self.stringLiteral()
                self.state = 820
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = GremlinParser.TraversalMethod_addV_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 822
                self.match(GremlinParser.T__11)
                self.state = 823
                self.match(GremlinParser.LPAREN)
                self.state = 824
                self.nullLiteral()
                self.state = 825
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 4:
                localctx = GremlinParser.TraversalMethod_addV_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 827
                self.match(GremlinParser.T__11)
                self.state = 828
                self.match(GremlinParser.LPAREN)
                self.state = 829
                self.nestedTraversal()
                self.state = 830
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_aggregateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_aggregate

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_aggregate_StringContext(TraversalMethod_aggregateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_aggregateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_aggregate_String" ):
                listener.enterTraversalMethod_aggregate_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_aggregate_String" ):
                listener.exitTraversalMethod_aggregate_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_aggregate_String" ):
                return visitor.visitTraversalMethod_aggregate_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_aggregate_Scope_StringContext(TraversalMethod_aggregateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_aggregateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_aggregate_Scope_String" ):
                listener.enterTraversalMethod_aggregate_Scope_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_aggregate_Scope_String" ):
                listener.exitTraversalMethod_aggregate_Scope_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_aggregate_Scope_String" ):
                return visitor.visitTraversalMethod_aggregate_Scope_String(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_aggregate(self):

        localctx = GremlinParser.TraversalMethod_aggregateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_traversalMethod_aggregate)
        try:
            self.state = 846
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_aggregate_Scope_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 834
                self.match(GremlinParser.T__16)
                self.state = 835
                self.match(GremlinParser.LPAREN)
                self.state = 836
                self.traversalScope()
                self.state = 837
                self.match(GremlinParser.COMMA)
                self.state = 838
                self.stringLiteral()
                self.state = 839
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_aggregate_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 841
                self.match(GremlinParser.T__16)
                self.state = 842
                self.match(GremlinParser.LPAREN)
                self.state = 843
                self.stringLiteral()
                self.state = 844
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_andContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversalList(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_and

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_and" ):
                listener.enterTraversalMethod_and(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_and" ):
                listener.exitTraversalMethod_and(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_and" ):
                return visitor.visitTraversalMethod_and(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_and(self):

        localctx = GremlinParser.TraversalMethod_andContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_traversalMethod_and)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 848
            self.match(GremlinParser.T__17)
            self.state = 849
            self.match(GremlinParser.LPAREN)
            self.state = 850
            self.nestedTraversalList()
            self.state = 851
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_asContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_as

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_as" ):
                listener.enterTraversalMethod_as(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_as" ):
                listener.exitTraversalMethod_as(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_as" ):
                return visitor.visitTraversalMethod_as(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_as(self):

        localctx = GremlinParser.TraversalMethod_asContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_traversalMethod_as)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 853
            self.match(GremlinParser.T__18)
            self.state = 854
            self.match(GremlinParser.LPAREN)
            self.state = 855
            self.stringLiteral()
            self.state = 858
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GremlinParser.COMMA:
                self.state = 856
                self.match(GremlinParser.COMMA)
                self.state = 857
                self.stringLiteralList()


            self.state = 860
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_barrierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_barrier

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_barrier_EmptyContext(TraversalMethod_barrierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_barrierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_barrier_Empty" ):
                listener.enterTraversalMethod_barrier_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_barrier_Empty" ):
                listener.exitTraversalMethod_barrier_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_barrier_Empty" ):
                return visitor.visitTraversalMethod_barrier_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_barrier_intContext(TraversalMethod_barrierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_barrierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_barrier_int" ):
                listener.enterTraversalMethod_barrier_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_barrier_int" ):
                listener.exitTraversalMethod_barrier_int(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_barrier_int" ):
                return visitor.visitTraversalMethod_barrier_int(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_barrier_ConsumerContext(TraversalMethod_barrierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_barrierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalSackMethod(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSackMethodContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_barrier_Consumer" ):
                listener.enterTraversalMethod_barrier_Consumer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_barrier_Consumer" ):
                listener.exitTraversalMethod_barrier_Consumer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_barrier_Consumer" ):
                return visitor.visitTraversalMethod_barrier_Consumer(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_barrier(self):

        localctx = GremlinParser.TraversalMethod_barrierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_traversalMethod_barrier)
        try:
            self.state = 875
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_barrier_ConsumerContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 862
                self.match(GremlinParser.T__19)
                self.state = 863
                self.match(GremlinParser.LPAREN)
                self.state = 864
                self.traversalSackMethod()
                self.state = 865
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_barrier_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 867
                self.match(GremlinParser.T__19)
                self.state = 868
                self.match(GremlinParser.LPAREN)
                self.state = 869
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = GremlinParser.TraversalMethod_barrier_intContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 870
                self.match(GremlinParser.T__19)
                self.state = 871
                self.match(GremlinParser.LPAREN)
                self.state = 872
                self.integerLiteral()
                self.state = 873
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_bothContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_both

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_both" ):
                listener.enterTraversalMethod_both(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_both" ):
                listener.exitTraversalMethod_both(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_both" ):
                return visitor.visitTraversalMethod_both(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_both(self):

        localctx = GremlinParser.TraversalMethod_bothContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_traversalMethod_both)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 877
            self.match(GremlinParser.T__20)
            self.state = 878
            self.match(GremlinParser.LPAREN)
            self.state = 879
            self.stringLiteralList()
            self.state = 880
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_bothEContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_bothE

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_bothE" ):
                listener.enterTraversalMethod_bothE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_bothE" ):
                listener.exitTraversalMethod_bothE(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_bothE" ):
                return visitor.visitTraversalMethod_bothE(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_bothE(self):

        localctx = GremlinParser.TraversalMethod_bothEContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_traversalMethod_bothE)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 882
            self.match(GremlinParser.T__21)
            self.state = 883
            self.match(GremlinParser.LPAREN)
            self.state = 884
            self.stringLiteralList()
            self.state = 885
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_bothVContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_bothV

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_bothV" ):
                listener.enterTraversalMethod_bothV(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_bothV" ):
                listener.exitTraversalMethod_bothV(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_bothV" ):
                return visitor.visitTraversalMethod_bothV(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_bothV(self):

        localctx = GremlinParser.TraversalMethod_bothVContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_traversalMethod_bothV)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 887
            self.match(GremlinParser.T__22)
            self.state = 888
            self.match(GremlinParser.LPAREN)
            self.state = 889
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_branchContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_branch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_branch" ):
                listener.enterTraversalMethod_branch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_branch" ):
                listener.exitTraversalMethod_branch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_branch" ):
                return visitor.visitTraversalMethod_branch(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_branch(self):

        localctx = GremlinParser.TraversalMethod_branchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_traversalMethod_branch)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 891
            self.match(GremlinParser.T__23)
            self.state = 892
            self.match(GremlinParser.LPAREN)
            self.state = 893
            self.nestedTraversal()
            self.state = 894
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_byContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_by

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_by_TContext(TraversalMethod_byContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_byContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalToken(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTokenContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_by_T" ):
                listener.enterTraversalMethod_by_T(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_by_T" ):
                listener.exitTraversalMethod_by_T(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_by_T" ):
                return visitor.visitTraversalMethod_by_T(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_by_ComparatorContext(TraversalMethod_byContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_byContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalComparator(self):
            return self.getTypedRuleContext(GremlinParser.TraversalComparatorContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_by_Comparator" ):
                listener.enterTraversalMethod_by_Comparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_by_Comparator" ):
                listener.exitTraversalMethod_by_Comparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_by_Comparator" ):
                return visitor.visitTraversalMethod_by_Comparator(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_by_FunctionContext(TraversalMethod_byContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_byContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalFunction(self):
            return self.getTypedRuleContext(GremlinParser.TraversalFunctionContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_by_Function" ):
                listener.enterTraversalMethod_by_Function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_by_Function" ):
                listener.exitTraversalMethod_by_Function(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_by_Function" ):
                return visitor.visitTraversalMethod_by_Function(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_by_EmptyContext(TraversalMethod_byContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_byContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_by_Empty" ):
                listener.enterTraversalMethod_by_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_by_Empty" ):
                listener.exitTraversalMethod_by_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_by_Empty" ):
                return visitor.visitTraversalMethod_by_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_by_Function_ComparatorContext(TraversalMethod_byContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_byContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalFunction(self):
            return self.getTypedRuleContext(GremlinParser.TraversalFunctionContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def traversalComparator(self):
            return self.getTypedRuleContext(GremlinParser.TraversalComparatorContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_by_Function_Comparator" ):
                listener.enterTraversalMethod_by_Function_Comparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_by_Function_Comparator" ):
                listener.exitTraversalMethod_by_Function_Comparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_by_Function_Comparator" ):
                return visitor.visitTraversalMethod_by_Function_Comparator(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_by_String_ComparatorContext(TraversalMethod_byContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_byContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def traversalComparator(self):
            return self.getTypedRuleContext(GremlinParser.TraversalComparatorContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_by_String_Comparator" ):
                listener.enterTraversalMethod_by_String_Comparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_by_String_Comparator" ):
                listener.exitTraversalMethod_by_String_Comparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_by_String_Comparator" ):
                return visitor.visitTraversalMethod_by_String_Comparator(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_by_TraversalContext(TraversalMethod_byContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_byContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_by_Traversal" ):
                listener.enterTraversalMethod_by_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_by_Traversal" ):
                listener.exitTraversalMethod_by_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_by_Traversal" ):
                return visitor.visitTraversalMethod_by_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_by_StringContext(TraversalMethod_byContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_byContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_by_String" ):
                listener.enterTraversalMethod_by_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_by_String" ):
                listener.exitTraversalMethod_by_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_by_String" ):
                return visitor.visitTraversalMethod_by_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_by_OrderContext(TraversalMethod_byContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_byContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalOrder(self):
            return self.getTypedRuleContext(GremlinParser.TraversalOrderContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_by_Order" ):
                listener.enterTraversalMethod_by_Order(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_by_Order" ):
                listener.exitTraversalMethod_by_Order(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_by_Order" ):
                return visitor.visitTraversalMethod_by_Order(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_by_Traversal_ComparatorContext(TraversalMethod_byContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_byContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def traversalComparator(self):
            return self.getTypedRuleContext(GremlinParser.TraversalComparatorContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_by_Traversal_Comparator" ):
                listener.enterTraversalMethod_by_Traversal_Comparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_by_Traversal_Comparator" ):
                listener.exitTraversalMethod_by_Traversal_Comparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_by_Traversal_Comparator" ):
                return visitor.visitTraversalMethod_by_Traversal_Comparator(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_by(self):

        localctx = GremlinParser.TraversalMethod_byContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_traversalMethod_by)
        try:
            self.state = 950
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_by_ComparatorContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 896
                self.match(GremlinParser.T__24)
                self.state = 897
                self.match(GremlinParser.LPAREN)
                self.state = 898
                self.traversalComparator()
                self.state = 899
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_by_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 901
                self.match(GremlinParser.T__24)
                self.state = 902
                self.match(GremlinParser.LPAREN)
                self.state = 903
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = GremlinParser.TraversalMethod_by_FunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 904
                self.match(GremlinParser.T__24)
                self.state = 905
                self.match(GremlinParser.LPAREN)
                self.state = 906
                self.traversalFunction()
                self.state = 907
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 4:
                localctx = GremlinParser.TraversalMethod_by_Function_ComparatorContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 909
                self.match(GremlinParser.T__24)
                self.state = 910
                self.match(GremlinParser.LPAREN)
                self.state = 911
                self.traversalFunction()
                self.state = 912
                self.match(GremlinParser.COMMA)
                self.state = 913
                self.traversalComparator()
                self.state = 914
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 5:
                localctx = GremlinParser.TraversalMethod_by_OrderContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 916
                self.match(GremlinParser.T__24)
                self.state = 917
                self.match(GremlinParser.LPAREN)
                self.state = 918
                self.traversalOrder()
                self.state = 919
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 6:
                localctx = GremlinParser.TraversalMethod_by_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 921
                self.match(GremlinParser.T__24)
                self.state = 922
                self.match(GremlinParser.LPAREN)
                self.state = 923
                self.stringLiteral()
                self.state = 924
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 7:
                localctx = GremlinParser.TraversalMethod_by_String_ComparatorContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 926
                self.match(GremlinParser.T__24)
                self.state = 927
                self.match(GremlinParser.LPAREN)
                self.state = 928
                self.stringLiteral()
                self.state = 929
                self.match(GremlinParser.COMMA)
                self.state = 930
                self.traversalComparator()
                self.state = 931
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 8:
                localctx = GremlinParser.TraversalMethod_by_TContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 933
                self.match(GremlinParser.T__24)
                self.state = 934
                self.match(GremlinParser.LPAREN)
                self.state = 935
                self.traversalToken()
                self.state = 936
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 9:
                localctx = GremlinParser.TraversalMethod_by_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 938
                self.match(GremlinParser.T__24)
                self.state = 939
                self.match(GremlinParser.LPAREN)
                self.state = 940
                self.nestedTraversal()
                self.state = 941
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 10:
                localctx = GremlinParser.TraversalMethod_by_Traversal_ComparatorContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 943
                self.match(GremlinParser.T__24)
                self.state = 944
                self.match(GremlinParser.LPAREN)
                self.state = 945
                self.nestedTraversal()
                self.state = 946
                self.match(GremlinParser.COMMA)
                self.state = 947
                self.traversalComparator()
                self.state = 948
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_capContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_cap

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_cap" ):
                listener.enterTraversalMethod_cap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_cap" ):
                listener.exitTraversalMethod_cap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_cap" ):
                return visitor.visitTraversalMethod_cap(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_cap(self):

        localctx = GremlinParser.TraversalMethod_capContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_traversalMethod_cap)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 952
            self.match(GremlinParser.T__25)
            self.state = 953
            self.match(GremlinParser.LPAREN)
            self.state = 954
            self.stringLiteral()
            self.state = 957
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GremlinParser.COMMA:
                self.state = 955
                self.match(GremlinParser.COMMA)
                self.state = 956
                self.stringLiteralList()


            self.state = 959
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_chooseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_choose

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_choose_Traversal_TraversalContext(TraversalMethod_chooseContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_chooseContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.NestedTraversalContext)
            else:
                return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,i)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_choose_Traversal_Traversal" ):
                listener.enterTraversalMethod_choose_Traversal_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_choose_Traversal_Traversal" ):
                listener.exitTraversalMethod_choose_Traversal_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_choose_Traversal_Traversal" ):
                return visitor.visitTraversalMethod_choose_Traversal_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_choose_TraversalContext(TraversalMethod_chooseContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_chooseContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_choose_Traversal" ):
                listener.enterTraversalMethod_choose_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_choose_Traversal" ):
                listener.exitTraversalMethod_choose_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_choose_Traversal" ):
                return visitor.visitTraversalMethod_choose_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_choose_Predicate_Traversal_TraversalContext(TraversalMethod_chooseContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_chooseContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)
        def nestedTraversal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.NestedTraversalContext)
            else:
                return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,i)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_choose_Predicate_Traversal_Traversal" ):
                listener.enterTraversalMethod_choose_Predicate_Traversal_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_choose_Predicate_Traversal_Traversal" ):
                listener.exitTraversalMethod_choose_Predicate_Traversal_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_choose_Predicate_Traversal_Traversal" ):
                return visitor.visitTraversalMethod_choose_Predicate_Traversal_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_choose_FunctionContext(TraversalMethod_chooseContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_chooseContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalFunction(self):
            return self.getTypedRuleContext(GremlinParser.TraversalFunctionContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_choose_Function" ):
                listener.enterTraversalMethod_choose_Function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_choose_Function" ):
                listener.exitTraversalMethod_choose_Function(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_choose_Function" ):
                return visitor.visitTraversalMethod_choose_Function(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_choose_Predicate_TraversalContext(TraversalMethod_chooseContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_chooseContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_choose_Predicate_Traversal" ):
                listener.enterTraversalMethod_choose_Predicate_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_choose_Predicate_Traversal" ):
                listener.exitTraversalMethod_choose_Predicate_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_choose_Predicate_Traversal" ):
                return visitor.visitTraversalMethod_choose_Predicate_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_choose_Traversal_Traversal_TraversalContext(TraversalMethod_chooseContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_chooseContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.NestedTraversalContext)
            else:
                return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_choose_Traversal_Traversal_Traversal" ):
                listener.enterTraversalMethod_choose_Traversal_Traversal_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_choose_Traversal_Traversal_Traversal" ):
                listener.exitTraversalMethod_choose_Traversal_Traversal_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_choose_Traversal_Traversal_Traversal" ):
                return visitor.visitTraversalMethod_choose_Traversal_Traversal_Traversal(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_choose(self):

        localctx = GremlinParser.TraversalMethod_chooseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_traversalMethod_choose)
        try:
            self.state = 1003
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_choose_FunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 961
                self.match(GremlinParser.T__26)
                self.state = 962
                self.match(GremlinParser.LPAREN)
                self.state = 963
                self.traversalFunction()
                self.state = 964
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_choose_Predicate_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 966
                self.match(GremlinParser.T__26)
                self.state = 967
                self.match(GremlinParser.LPAREN)
                self.state = 968
                self.traversalPredicate(0)
                self.state = 969
                self.match(GremlinParser.COMMA)
                self.state = 970
                self.nestedTraversal()
                self.state = 971
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = GremlinParser.TraversalMethod_choose_Predicate_Traversal_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 973
                self.match(GremlinParser.T__26)
                self.state = 974
                self.match(GremlinParser.LPAREN)
                self.state = 975
                self.traversalPredicate(0)
                self.state = 976
                self.match(GremlinParser.COMMA)
                self.state = 977
                self.nestedTraversal()
                self.state = 978
                self.match(GremlinParser.COMMA)
                self.state = 979
                self.nestedTraversal()
                self.state = 980
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 4:
                localctx = GremlinParser.TraversalMethod_choose_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 982
                self.match(GremlinParser.T__26)
                self.state = 983
                self.match(GremlinParser.LPAREN)
                self.state = 984
                self.nestedTraversal()
                self.state = 985
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 5:
                localctx = GremlinParser.TraversalMethod_choose_Traversal_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 987
                self.match(GremlinParser.T__26)
                self.state = 988
                self.match(GremlinParser.LPAREN)
                self.state = 989
                self.nestedTraversal()
                self.state = 990
                self.match(GremlinParser.COMMA)
                self.state = 991
                self.nestedTraversal()
                self.state = 992
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 6:
                localctx = GremlinParser.TraversalMethod_choose_Traversal_Traversal_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 994
                self.match(GremlinParser.T__26)
                self.state = 995
                self.match(GremlinParser.LPAREN)
                self.state = 996
                self.nestedTraversal()
                self.state = 997
                self.match(GremlinParser.COMMA)
                self.state = 998
                self.nestedTraversal()
                self.state = 999
                self.match(GremlinParser.COMMA)
                self.state = 1000
                self.nestedTraversal()
                self.state = 1001
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_coalesceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversalList(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_coalesce

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_coalesce" ):
                listener.enterTraversalMethod_coalesce(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_coalesce" ):
                listener.exitTraversalMethod_coalesce(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_coalesce" ):
                return visitor.visitTraversalMethod_coalesce(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_coalesce(self):

        localctx = GremlinParser.TraversalMethod_coalesceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_traversalMethod_coalesce)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1005
            self.match(GremlinParser.T__27)
            self.state = 1006
            self.match(GremlinParser.LPAREN)
            self.state = 1007
            self.nestedTraversalList()
            self.state = 1008
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_coinContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def floatLiteral(self):
            return self.getTypedRuleContext(GremlinParser.FloatLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_coin

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_coin" ):
                listener.enterTraversalMethod_coin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_coin" ):
                listener.exitTraversalMethod_coin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_coin" ):
                return visitor.visitTraversalMethod_coin(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_coin(self):

        localctx = GremlinParser.TraversalMethod_coinContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_traversalMethod_coin)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1010
            self.match(GremlinParser.T__28)
            self.state = 1011
            self.match(GremlinParser.LPAREN)
            self.state = 1012
            self.floatLiteral()
            self.state = 1013
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_connectedComponentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_connectedComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_connectedComponent" ):
                listener.enterTraversalMethod_connectedComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_connectedComponent" ):
                listener.exitTraversalMethod_connectedComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_connectedComponent" ):
                return visitor.visitTraversalMethod_connectedComponent(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_connectedComponent(self):

        localctx = GremlinParser.TraversalMethod_connectedComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_traversalMethod_connectedComponent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1015
            self.match(GremlinParser.T__29)
            self.state = 1016
            self.match(GremlinParser.LPAREN)
            self.state = 1017
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_constantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_constant" ):
                listener.enterTraversalMethod_constant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_constant" ):
                listener.exitTraversalMethod_constant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_constant" ):
                return visitor.visitTraversalMethod_constant(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_constant(self):

        localctx = GremlinParser.TraversalMethod_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_traversalMethod_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1019
            self.match(GremlinParser.T__30)
            self.state = 1020
            self.match(GremlinParser.LPAREN)
            self.state = 1021
            self.genericLiteral()
            self.state = 1022
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_countContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_count

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_count_ScopeContext(TraversalMethod_countContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_countContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_count_Scope" ):
                listener.enterTraversalMethod_count_Scope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_count_Scope" ):
                listener.exitTraversalMethod_count_Scope(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_count_Scope" ):
                return visitor.visitTraversalMethod_count_Scope(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_count_EmptyContext(TraversalMethod_countContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_countContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_count_Empty" ):
                listener.enterTraversalMethod_count_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_count_Empty" ):
                listener.exitTraversalMethod_count_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_count_Empty" ):
                return visitor.visitTraversalMethod_count_Empty(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_count(self):

        localctx = GremlinParser.TraversalMethod_countContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_traversalMethod_count)
        try:
            self.state = 1032
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_count_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1024
                self.match(GremlinParser.T__31)
                self.state = 1025
                self.match(GremlinParser.LPAREN)
                self.state = 1026
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_count_ScopeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1027
                self.match(GremlinParser.T__31)
                self.state = 1028
                self.match(GremlinParser.LPAREN)
                self.state = 1029
                self.traversalScope()
                self.state = 1030
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_cyclicPathContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_cyclicPath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_cyclicPath" ):
                listener.enterTraversalMethod_cyclicPath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_cyclicPath" ):
                listener.exitTraversalMethod_cyclicPath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_cyclicPath" ):
                return visitor.visitTraversalMethod_cyclicPath(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_cyclicPath(self):

        localctx = GremlinParser.TraversalMethod_cyclicPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_traversalMethod_cyclicPath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1034
            self.match(GremlinParser.T__32)
            self.state = 1035
            self.match(GremlinParser.LPAREN)
            self.state = 1036
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_dedupContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_dedup

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_dedup_Scope_StringContext(TraversalMethod_dedupContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_dedupContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_dedup_Scope_String" ):
                listener.enterTraversalMethod_dedup_Scope_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_dedup_Scope_String" ):
                listener.exitTraversalMethod_dedup_Scope_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_dedup_Scope_String" ):
                return visitor.visitTraversalMethod_dedup_Scope_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_dedup_StringContext(TraversalMethod_dedupContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_dedupContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_dedup_String" ):
                listener.enterTraversalMethod_dedup_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_dedup_String" ):
                listener.exitTraversalMethod_dedup_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_dedup_String" ):
                return visitor.visitTraversalMethod_dedup_String(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_dedup(self):

        localctx = GremlinParser.TraversalMethod_dedupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_traversalMethod_dedup)
        self._la = 0 # Token type
        try:
            self.state = 1052
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_dedup_Scope_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1038
                self.match(GremlinParser.T__33)
                self.state = 1039
                self.match(GremlinParser.LPAREN)
                self.state = 1040
                self.traversalScope()
                self.state = 1043
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.COMMA:
                    self.state = 1041
                    self.match(GremlinParser.COMMA)
                    self.state = 1042
                    self.stringLiteralList()


                self.state = 1045
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_dedup_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1047
                self.match(GremlinParser.T__33)
                self.state = 1048
                self.match(GremlinParser.LPAREN)
                self.state = 1049
                self.stringLiteralList()
                self.state = 1050
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_dropContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_drop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_drop" ):
                listener.enterTraversalMethod_drop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_drop" ):
                listener.exitTraversalMethod_drop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_drop" ):
                return visitor.visitTraversalMethod_drop(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_drop(self):

        localctx = GremlinParser.TraversalMethod_dropContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_traversalMethod_drop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1054
            self.match(GremlinParser.T__34)
            self.state = 1055
            self.match(GremlinParser.LPAREN)
            self.state = 1056
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_elementMapContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_elementMap

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_elementMap" ):
                listener.enterTraversalMethod_elementMap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_elementMap" ):
                listener.exitTraversalMethod_elementMap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_elementMap" ):
                return visitor.visitTraversalMethod_elementMap(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_elementMap(self):

        localctx = GremlinParser.TraversalMethod_elementMapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_traversalMethod_elementMap)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1058
            self.match(GremlinParser.T__35)
            self.state = 1059
            self.match(GremlinParser.LPAREN)
            self.state = 1060
            self.stringLiteralList()
            self.state = 1061
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_emitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_emit

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_emit_PredicateContext(TraversalMethod_emitContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_emitContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_emit_Predicate" ):
                listener.enterTraversalMethod_emit_Predicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_emit_Predicate" ):
                listener.exitTraversalMethod_emit_Predicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_emit_Predicate" ):
                return visitor.visitTraversalMethod_emit_Predicate(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_emit_EmptyContext(TraversalMethod_emitContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_emitContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_emit_Empty" ):
                listener.enterTraversalMethod_emit_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_emit_Empty" ):
                listener.exitTraversalMethod_emit_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_emit_Empty" ):
                return visitor.visitTraversalMethod_emit_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_emit_TraversalContext(TraversalMethod_emitContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_emitContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_emit_Traversal" ):
                listener.enterTraversalMethod_emit_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_emit_Traversal" ):
                listener.exitTraversalMethod_emit_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_emit_Traversal" ):
                return visitor.visitTraversalMethod_emit_Traversal(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_emit(self):

        localctx = GremlinParser.TraversalMethod_emitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_traversalMethod_emit)
        try:
            self.state = 1076
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_emit_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1063
                self.match(GremlinParser.T__36)
                self.state = 1064
                self.match(GremlinParser.LPAREN)
                self.state = 1065
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_emit_PredicateContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1066
                self.match(GremlinParser.T__36)
                self.state = 1067
                self.match(GremlinParser.LPAREN)
                self.state = 1068
                self.traversalPredicate(0)
                self.state = 1069
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = GremlinParser.TraversalMethod_emit_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1071
                self.match(GremlinParser.T__36)
                self.state = 1072
                self.match(GremlinParser.LPAREN)
                self.state = 1073
                self.nestedTraversal()
                self.state = 1074
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_filterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_filter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_filter_TraversalContext(TraversalMethod_filterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_filterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_filter_Traversal" ):
                listener.enterTraversalMethod_filter_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_filter_Traversal" ):
                listener.exitTraversalMethod_filter_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_filter_Traversal" ):
                return visitor.visitTraversalMethod_filter_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_filter_PredicateContext(TraversalMethod_filterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_filterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_filter_Predicate" ):
                listener.enterTraversalMethod_filter_Predicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_filter_Predicate" ):
                listener.exitTraversalMethod_filter_Predicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_filter_Predicate" ):
                return visitor.visitTraversalMethod_filter_Predicate(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_filter(self):

        localctx = GremlinParser.TraversalMethod_filterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_traversalMethod_filter)
        try:
            self.state = 1088
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_filter_PredicateContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1078
                self.match(GremlinParser.T__37)
                self.state = 1079
                self.match(GremlinParser.LPAREN)
                self.state = 1080
                self.traversalPredicate(0)
                self.state = 1081
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_filter_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1083
                self.match(GremlinParser.T__37)
                self.state = 1084
                self.match(GremlinParser.LPAREN)
                self.state = 1085
                self.nestedTraversal()
                self.state = 1086
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_flatMapContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_flatMap

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_flatMap" ):
                listener.enterTraversalMethod_flatMap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_flatMap" ):
                listener.exitTraversalMethod_flatMap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_flatMap" ):
                return visitor.visitTraversalMethod_flatMap(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_flatMap(self):

        localctx = GremlinParser.TraversalMethod_flatMapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_traversalMethod_flatMap)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1090
            self.match(GremlinParser.T__38)
            self.state = 1091
            self.match(GremlinParser.LPAREN)
            self.state = 1092
            self.nestedTraversal()
            self.state = 1093
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_foldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_fold

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_fold_EmptyContext(TraversalMethod_foldContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_foldContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_fold_Empty" ):
                listener.enterTraversalMethod_fold_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_fold_Empty" ):
                listener.exitTraversalMethod_fold_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_fold_Empty" ):
                return visitor.visitTraversalMethod_fold_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_fold_Object_BiFunctionContext(TraversalMethod_foldContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_foldContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def traversalBiFunction(self):
            return self.getTypedRuleContext(GremlinParser.TraversalBiFunctionContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_fold_Object_BiFunction" ):
                listener.enterTraversalMethod_fold_Object_BiFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_fold_Object_BiFunction" ):
                listener.exitTraversalMethod_fold_Object_BiFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_fold_Object_BiFunction" ):
                return visitor.visitTraversalMethod_fold_Object_BiFunction(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_fold(self):

        localctx = GremlinParser.TraversalMethod_foldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_traversalMethod_fold)
        try:
            self.state = 1105
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_fold_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1095
                self.match(GremlinParser.T__39)
                self.state = 1096
                self.match(GremlinParser.LPAREN)
                self.state = 1097
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_fold_Object_BiFunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1098
                self.match(GremlinParser.T__39)
                self.state = 1099
                self.match(GremlinParser.LPAREN)
                self.state = 1100
                self.genericLiteral()
                self.state = 1101
                self.match(GremlinParser.COMMA)
                self.state = 1102
                self.traversalBiFunction()
                self.state = 1103
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_fromContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_from

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_from_StringContext(TraversalMethod_fromContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_fromContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_from_String" ):
                listener.enterTraversalMethod_from_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_from_String" ):
                listener.exitTraversalMethod_from_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_from_String" ):
                return visitor.visitTraversalMethod_from_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_from_TraversalContext(TraversalMethod_fromContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_fromContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_from_Traversal" ):
                listener.enterTraversalMethod_from_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_from_Traversal" ):
                listener.exitTraversalMethod_from_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_from_Traversal" ):
                return visitor.visitTraversalMethod_from_Traversal(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_from(self):

        localctx = GremlinParser.TraversalMethod_fromContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_traversalMethod_from)
        try:
            self.state = 1117
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_from_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1107
                self.match(GremlinParser.T__40)
                self.state = 1108
                self.match(GremlinParser.LPAREN)
                self.state = 1109
                self.stringLiteral()
                self.state = 1110
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_from_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1112
                self.match(GremlinParser.T__40)
                self.state = 1113
                self.match(GremlinParser.LPAREN)
                self.state = 1114
                self.nestedTraversal()
                self.state = 1115
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_groupContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_group

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_group_StringContext(TraversalMethod_groupContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_groupContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_group_String" ):
                listener.enterTraversalMethod_group_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_group_String" ):
                listener.exitTraversalMethod_group_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_group_String" ):
                return visitor.visitTraversalMethod_group_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_group_EmptyContext(TraversalMethod_groupContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_groupContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_group_Empty" ):
                listener.enterTraversalMethod_group_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_group_Empty" ):
                listener.exitTraversalMethod_group_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_group_Empty" ):
                return visitor.visitTraversalMethod_group_Empty(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_group(self):

        localctx = GremlinParser.TraversalMethod_groupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_traversalMethod_group)
        try:
            self.state = 1127
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_group_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1119
                self.match(GremlinParser.T__41)
                self.state = 1120
                self.match(GremlinParser.LPAREN)
                self.state = 1121
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_group_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1122
                self.match(GremlinParser.T__41)
                self.state = 1123
                self.match(GremlinParser.LPAREN)
                self.state = 1124
                self.stringLiteral()
                self.state = 1125
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_groupCountContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_groupCount

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_groupCount_StringContext(TraversalMethod_groupCountContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_groupCountContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_groupCount_String" ):
                listener.enterTraversalMethod_groupCount_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_groupCount_String" ):
                listener.exitTraversalMethod_groupCount_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_groupCount_String" ):
                return visitor.visitTraversalMethod_groupCount_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_groupCount_EmptyContext(TraversalMethod_groupCountContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_groupCountContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_groupCount_Empty" ):
                listener.enterTraversalMethod_groupCount_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_groupCount_Empty" ):
                listener.exitTraversalMethod_groupCount_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_groupCount_Empty" ):
                return visitor.visitTraversalMethod_groupCount_Empty(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_groupCount(self):

        localctx = GremlinParser.TraversalMethod_groupCountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_traversalMethod_groupCount)
        try:
            self.state = 1137
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_groupCount_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1129
                self.match(GremlinParser.T__42)
                self.state = 1130
                self.match(GremlinParser.LPAREN)
                self.state = 1131
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_groupCount_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1132
                self.match(GremlinParser.T__42)
                self.state = 1133
                self.match(GremlinParser.LPAREN)
                self.state = 1134
                self.stringLiteral()
                self.state = 1135
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_hasContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_has

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_has_T_TraversalContext(TraversalMethod_hasContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalToken(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTokenContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_has_T_Traversal" ):
                listener.enterTraversalMethod_has_T_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_has_T_Traversal" ):
                listener.exitTraversalMethod_has_T_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_has_T_Traversal" ):
                return visitor.visitTraversalMethod_has_T_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_has_String_String_PContext(TraversalMethod_hasContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.StringLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.StringLiteralContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_has_String_String_P" ):
                listener.enterTraversalMethod_has_String_String_P(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_has_String_String_P" ):
                listener.exitTraversalMethod_has_String_String_P(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_has_String_String_P" ):
                return visitor.visitTraversalMethod_has_String_String_P(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_has_StringContext(TraversalMethod_hasContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_has_String" ):
                listener.enterTraversalMethod_has_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_has_String" ):
                listener.exitTraversalMethod_has_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_has_String" ):
                return visitor.visitTraversalMethod_has_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_has_String_ObjectContext(TraversalMethod_hasContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_has_String_Object" ):
                listener.enterTraversalMethod_has_String_Object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_has_String_Object" ):
                listener.exitTraversalMethod_has_String_Object(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_has_String_Object" ):
                return visitor.visitTraversalMethod_has_String_Object(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_has_T_PContext(TraversalMethod_hasContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalToken(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTokenContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_has_T_P" ):
                listener.enterTraversalMethod_has_T_P(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_has_T_P" ):
                listener.exitTraversalMethod_has_T_P(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_has_T_P" ):
                return visitor.visitTraversalMethod_has_T_P(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_has_String_String_ObjectContext(TraversalMethod_hasContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.StringLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.StringLiteralContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)
        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_has_String_String_Object" ):
                listener.enterTraversalMethod_has_String_String_Object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_has_String_String_Object" ):
                listener.exitTraversalMethod_has_String_String_Object(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_has_String_String_Object" ):
                return visitor.visitTraversalMethod_has_String_String_Object(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_has_String_TraversalContext(TraversalMethod_hasContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_has_String_Traversal" ):
                listener.enterTraversalMethod_has_String_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_has_String_Traversal" ):
                listener.exitTraversalMethod_has_String_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_has_String_Traversal" ):
                return visitor.visitTraversalMethod_has_String_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_has_String_PContext(TraversalMethod_hasContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_has_String_P" ):
                listener.enterTraversalMethod_has_String_P(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_has_String_P" ):
                listener.exitTraversalMethod_has_String_P(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_has_String_P" ):
                return visitor.visitTraversalMethod_has_String_P(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_has_T_ObjectContext(TraversalMethod_hasContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalToken(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTokenContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_has_T_Object" ):
                listener.enterTraversalMethod_has_T_Object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_has_T_Object" ):
                listener.exitTraversalMethod_has_T_Object(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_has_T_Object" ):
                return visitor.visitTraversalMethod_has_T_Object(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_has(self):

        localctx = GremlinParser.TraversalMethod_hasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_traversalMethod_has)
        try:
            self.state = 1204
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_has_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1139
                self.match(GremlinParser.T__43)
                self.state = 1140
                self.match(GremlinParser.LPAREN)
                self.state = 1141
                self.stringLiteral()
                self.state = 1142
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_has_String_ObjectContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1144
                self.match(GremlinParser.T__43)
                self.state = 1145
                self.match(GremlinParser.LPAREN)
                self.state = 1146
                self.stringLiteral()
                self.state = 1147
                self.match(GremlinParser.COMMA)
                self.state = 1148
                self.genericLiteral()
                self.state = 1149
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = GremlinParser.TraversalMethod_has_String_PContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1151
                self.match(GremlinParser.T__43)
                self.state = 1152
                self.match(GremlinParser.LPAREN)
                self.state = 1153
                self.stringLiteral()
                self.state = 1154
                self.match(GremlinParser.COMMA)
                self.state = 1155
                self.traversalPredicate(0)
                self.state = 1156
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 4:
                localctx = GremlinParser.TraversalMethod_has_String_String_ObjectContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1158
                self.match(GremlinParser.T__43)
                self.state = 1159
                self.match(GremlinParser.LPAREN)
                self.state = 1160
                self.stringLiteral()
                self.state = 1161
                self.match(GremlinParser.COMMA)
                self.state = 1162
                self.stringLiteral()
                self.state = 1163
                self.match(GremlinParser.COMMA)
                self.state = 1164
                self.genericLiteral()
                self.state = 1165
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 5:
                localctx = GremlinParser.TraversalMethod_has_String_String_PContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1167
                self.match(GremlinParser.T__43)
                self.state = 1168
                self.match(GremlinParser.LPAREN)
                self.state = 1169
                self.stringLiteral()
                self.state = 1170
                self.match(GremlinParser.COMMA)
                self.state = 1171
                self.stringLiteral()
                self.state = 1172
                self.match(GremlinParser.COMMA)
                self.state = 1173
                self.traversalPredicate(0)
                self.state = 1174
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 6:
                localctx = GremlinParser.TraversalMethod_has_String_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1176
                self.match(GremlinParser.T__43)
                self.state = 1177
                self.match(GremlinParser.LPAREN)
                self.state = 1178
                self.stringLiteral()
                self.state = 1179
                self.match(GremlinParser.COMMA)
                self.state = 1180
                self.nestedTraversal()
                self.state = 1181
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 7:
                localctx = GremlinParser.TraversalMethod_has_T_ObjectContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1183
                self.match(GremlinParser.T__43)
                self.state = 1184
                self.match(GremlinParser.LPAREN)
                self.state = 1185
                self.traversalToken()
                self.state = 1186
                self.match(GremlinParser.COMMA)
                self.state = 1187
                self.genericLiteral()
                self.state = 1188
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 8:
                localctx = GremlinParser.TraversalMethod_has_T_PContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1190
                self.match(GremlinParser.T__43)
                self.state = 1191
                self.match(GremlinParser.LPAREN)
                self.state = 1192
                self.traversalToken()
                self.state = 1193
                self.match(GremlinParser.COMMA)
                self.state = 1194
                self.traversalPredicate(0)
                self.state = 1195
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 9:
                localctx = GremlinParser.TraversalMethod_has_T_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 1197
                self.match(GremlinParser.T__43)
                self.state = 1198
                self.match(GremlinParser.LPAREN)
                self.state = 1199
                self.traversalToken()
                self.state = 1200
                self.match(GremlinParser.COMMA)
                self.state = 1201
                self.nestedTraversal()
                self.state = 1202
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_hasIdContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_hasId

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_hasId_PContext(TraversalMethod_hasIdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasIdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_hasId_P" ):
                listener.enterTraversalMethod_hasId_P(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_hasId_P" ):
                listener.exitTraversalMethod_hasId_P(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_hasId_P" ):
                return visitor.visitTraversalMethod_hasId_P(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_hasId_Object_ObjectContext(TraversalMethod_hasIdContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasIdContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def genericLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_hasId_Object_Object" ):
                listener.enterTraversalMethod_hasId_Object_Object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_hasId_Object_Object" ):
                listener.exitTraversalMethod_hasId_Object_Object(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_hasId_Object_Object" ):
                return visitor.visitTraversalMethod_hasId_Object_Object(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_hasId(self):

        localctx = GremlinParser.TraversalMethod_hasIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_traversalMethod_hasId)
        self._la = 0 # Token type
        try:
            self.state = 1220
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_hasId_Object_ObjectContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1206
                self.match(GremlinParser.T__44)
                self.state = 1207
                self.match(GremlinParser.LPAREN)
                self.state = 1208
                self.genericLiteral()
                self.state = 1211
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.COMMA:
                    self.state = 1209
                    self.match(GremlinParser.COMMA)
                    self.state = 1210
                    self.genericLiteralList()


                self.state = 1213
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_hasId_PContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1215
                self.match(GremlinParser.T__44)
                self.state = 1216
                self.match(GremlinParser.LPAREN)
                self.state = 1217
                self.traversalPredicate(0)
                self.state = 1218
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_hasKeyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_hasKey

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_hasKey_PContext(TraversalMethod_hasKeyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasKeyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_hasKey_P" ):
                listener.enterTraversalMethod_hasKey_P(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_hasKey_P" ):
                listener.exitTraversalMethod_hasKey_P(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_hasKey_P" ):
                return visitor.visitTraversalMethod_hasKey_P(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_hasKey_String_StringContext(TraversalMethod_hasKeyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasKeyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_hasKey_String_String" ):
                listener.enterTraversalMethod_hasKey_String_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_hasKey_String_String" ):
                listener.exitTraversalMethod_hasKey_String_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_hasKey_String_String" ):
                return visitor.visitTraversalMethod_hasKey_String_String(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_hasKey(self):

        localctx = GremlinParser.TraversalMethod_hasKeyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_traversalMethod_hasKey)
        self._la = 0 # Token type
        try:
            self.state = 1236
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_hasKey_PContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1222
                self.match(GremlinParser.T__45)
                self.state = 1223
                self.match(GremlinParser.LPAREN)
                self.state = 1224
                self.traversalPredicate(0)
                self.state = 1225
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_hasKey_String_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1227
                self.match(GremlinParser.T__45)
                self.state = 1228
                self.match(GremlinParser.LPAREN)
                self.state = 1229
                self.stringLiteral()
                self.state = 1232
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.COMMA:
                    self.state = 1230
                    self.match(GremlinParser.COMMA)
                    self.state = 1231
                    self.stringLiteralList()


                self.state = 1234
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_hasLabelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_hasLabel

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_hasLabel_String_StringContext(TraversalMethod_hasLabelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasLabelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_hasLabel_String_String" ):
                listener.enterTraversalMethod_hasLabel_String_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_hasLabel_String_String" ):
                listener.exitTraversalMethod_hasLabel_String_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_hasLabel_String_String" ):
                return visitor.visitTraversalMethod_hasLabel_String_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_hasLabel_PContext(TraversalMethod_hasLabelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasLabelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_hasLabel_P" ):
                listener.enterTraversalMethod_hasLabel_P(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_hasLabel_P" ):
                listener.exitTraversalMethod_hasLabel_P(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_hasLabel_P" ):
                return visitor.visitTraversalMethod_hasLabel_P(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_hasLabel(self):

        localctx = GremlinParser.TraversalMethod_hasLabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_traversalMethod_hasLabel)
        self._la = 0 # Token type
        try:
            self.state = 1252
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_hasLabel_PContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1238
                self.match(GremlinParser.T__46)
                self.state = 1239
                self.match(GremlinParser.LPAREN)
                self.state = 1240
                self.traversalPredicate(0)
                self.state = 1241
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_hasLabel_String_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1243
                self.match(GremlinParser.T__46)
                self.state = 1244
                self.match(GremlinParser.LPAREN)
                self.state = 1245
                self.stringLiteral()
                self.state = 1248
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.COMMA:
                    self.state = 1246
                    self.match(GremlinParser.COMMA)
                    self.state = 1247
                    self.stringLiteralList()


                self.state = 1250
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_hasNotContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_hasNot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_hasNot" ):
                listener.enterTraversalMethod_hasNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_hasNot" ):
                listener.exitTraversalMethod_hasNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_hasNot" ):
                return visitor.visitTraversalMethod_hasNot(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_hasNot(self):

        localctx = GremlinParser.TraversalMethod_hasNotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_traversalMethod_hasNot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1254
            self.match(GremlinParser.T__47)
            self.state = 1255
            self.match(GremlinParser.LPAREN)
            self.state = 1256
            self.stringLiteral()
            self.state = 1257
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_hasValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_hasValue

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_hasValue_Object_ObjectContext(TraversalMethod_hasValueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasValueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def genericLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_hasValue_Object_Object" ):
                listener.enterTraversalMethod_hasValue_Object_Object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_hasValue_Object_Object" ):
                listener.exitTraversalMethod_hasValue_Object_Object(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_hasValue_Object_Object" ):
                return visitor.visitTraversalMethod_hasValue_Object_Object(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_hasValue_PContext(TraversalMethod_hasValueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_hasValueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_hasValue_P" ):
                listener.enterTraversalMethod_hasValue_P(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_hasValue_P" ):
                listener.exitTraversalMethod_hasValue_P(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_hasValue_P" ):
                return visitor.visitTraversalMethod_hasValue_P(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_hasValue(self):

        localctx = GremlinParser.TraversalMethod_hasValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_traversalMethod_hasValue)
        self._la = 0 # Token type
        try:
            self.state = 1273
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_hasValue_Object_ObjectContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1259
                self.match(GremlinParser.T__48)
                self.state = 1260
                self.match(GremlinParser.LPAREN)
                self.state = 1261
                self.genericLiteral()
                self.state = 1264
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.COMMA:
                    self.state = 1262
                    self.match(GremlinParser.COMMA)
                    self.state = 1263
                    self.genericLiteralList()


                self.state = 1266
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_hasValue_PContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1268
                self.match(GremlinParser.T__48)
                self.state = 1269
                self.match(GremlinParser.LPAREN)
                self.state = 1270
                self.traversalPredicate(0)
                self.state = 1271
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_idContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_id

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_id" ):
                listener.enterTraversalMethod_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_id" ):
                listener.exitTraversalMethod_id(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_id" ):
                return visitor.visitTraversalMethod_id(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_id(self):

        localctx = GremlinParser.TraversalMethod_idContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_traversalMethod_id)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1275
            self.match(GremlinParser.T__49)
            self.state = 1276
            self.match(GremlinParser.LPAREN)
            self.state = 1277
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_identityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_identity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_identity" ):
                listener.enterTraversalMethod_identity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_identity" ):
                listener.exitTraversalMethod_identity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_identity" ):
                return visitor.visitTraversalMethod_identity(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_identity(self):

        localctx = GremlinParser.TraversalMethod_identityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_traversalMethod_identity)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1279
            self.match(GremlinParser.T__50)
            self.state = 1280
            self.match(GremlinParser.LPAREN)
            self.state = 1281
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_inContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_in

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_in" ):
                listener.enterTraversalMethod_in(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_in" ):
                listener.exitTraversalMethod_in(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_in" ):
                return visitor.visitTraversalMethod_in(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_in(self):

        localctx = GremlinParser.TraversalMethod_inContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_traversalMethod_in)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1283
            self.match(GremlinParser.T__51)
            self.state = 1284
            self.match(GremlinParser.LPAREN)
            self.state = 1285
            self.stringLiteralList()
            self.state = 1286
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_inEContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_inE

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_inE" ):
                listener.enterTraversalMethod_inE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_inE" ):
                listener.exitTraversalMethod_inE(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_inE" ):
                return visitor.visitTraversalMethod_inE(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_inE(self):

        localctx = GremlinParser.TraversalMethod_inEContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_traversalMethod_inE)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1288
            self.match(GremlinParser.T__52)
            self.state = 1289
            self.match(GremlinParser.LPAREN)
            self.state = 1290
            self.stringLiteralList()
            self.state = 1291
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_inVContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_inV

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_inV" ):
                listener.enterTraversalMethod_inV(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_inV" ):
                listener.exitTraversalMethod_inV(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_inV" ):
                return visitor.visitTraversalMethod_inV(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_inV(self):

        localctx = GremlinParser.TraversalMethod_inVContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_traversalMethod_inV)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1293
            self.match(GremlinParser.T__53)
            self.state = 1294
            self.match(GremlinParser.LPAREN)
            self.state = 1295
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_indexContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_index

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_index" ):
                listener.enterTraversalMethod_index(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_index" ):
                listener.exitTraversalMethod_index(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_index" ):
                return visitor.visitTraversalMethod_index(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_index(self):

        localctx = GremlinParser.TraversalMethod_indexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_traversalMethod_index)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1297
            self.match(GremlinParser.T__54)
            self.state = 1298
            self.match(GremlinParser.LPAREN)
            self.state = 1299
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_injectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_inject

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_inject" ):
                listener.enterTraversalMethod_inject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_inject" ):
                listener.exitTraversalMethod_inject(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_inject" ):
                return visitor.visitTraversalMethod_inject(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_inject(self):

        localctx = GremlinParser.TraversalMethod_injectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_traversalMethod_inject)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1301
            self.match(GremlinParser.T__14)
            self.state = 1302
            self.match(GremlinParser.LPAREN)
            self.state = 1303
            self.genericLiteralList()
            self.state = 1304
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_isContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_is

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_is_ObjectContext(TraversalMethod_isContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_isContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_is_Object" ):
                listener.enterTraversalMethod_is_Object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_is_Object" ):
                listener.exitTraversalMethod_is_Object(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_is_Object" ):
                return visitor.visitTraversalMethod_is_Object(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_is_PContext(TraversalMethod_isContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_isContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_is_P" ):
                listener.enterTraversalMethod_is_P(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_is_P" ):
                listener.exitTraversalMethod_is_P(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_is_P" ):
                return visitor.visitTraversalMethod_is_P(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_is(self):

        localctx = GremlinParser.TraversalMethod_isContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_traversalMethod_is)
        try:
            self.state = 1316
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_is_ObjectContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1306
                self.match(GremlinParser.T__55)
                self.state = 1307
                self.match(GremlinParser.LPAREN)
                self.state = 1308
                self.genericLiteral()
                self.state = 1309
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_is_PContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1311
                self.match(GremlinParser.T__55)
                self.state = 1312
                self.match(GremlinParser.LPAREN)
                self.state = 1313
                self.traversalPredicate(0)
                self.state = 1314
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_keyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_key

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_key" ):
                listener.enterTraversalMethod_key(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_key" ):
                listener.exitTraversalMethod_key(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_key" ):
                return visitor.visitTraversalMethod_key(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_key(self):

        localctx = GremlinParser.TraversalMethod_keyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_traversalMethod_key)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1318
            self.match(GremlinParser.T__56)
            self.state = 1319
            self.match(GremlinParser.LPAREN)
            self.state = 1320
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_labelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_label" ):
                listener.enterTraversalMethod_label(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_label" ):
                listener.exitTraversalMethod_label(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_label" ):
                return visitor.visitTraversalMethod_label(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_label(self):

        localctx = GremlinParser.TraversalMethod_labelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_traversalMethod_label)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1322
            self.match(GremlinParser.T__57)
            self.state = 1323
            self.match(GremlinParser.LPAREN)
            self.state = 1324
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_limitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_limit

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_limit_Scope_longContext(TraversalMethod_limitContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_limitContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_limit_Scope_long" ):
                listener.enterTraversalMethod_limit_Scope_long(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_limit_Scope_long" ):
                listener.exitTraversalMethod_limit_Scope_long(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_limit_Scope_long" ):
                return visitor.visitTraversalMethod_limit_Scope_long(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_limit_longContext(TraversalMethod_limitContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_limitContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_limit_long" ):
                listener.enterTraversalMethod_limit_long(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_limit_long" ):
                listener.exitTraversalMethod_limit_long(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_limit_long" ):
                return visitor.visitTraversalMethod_limit_long(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_limit(self):

        localctx = GremlinParser.TraversalMethod_limitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_traversalMethod_limit)
        try:
            self.state = 1338
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_limit_Scope_longContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1326
                self.match(GremlinParser.T__58)
                self.state = 1327
                self.match(GremlinParser.LPAREN)
                self.state = 1328
                self.traversalScope()
                self.state = 1329
                self.match(GremlinParser.COMMA)
                self.state = 1330
                self.integerLiteral()
                self.state = 1331
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_limit_longContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1333
                self.match(GremlinParser.T__58)
                self.state = 1334
                self.match(GremlinParser.LPAREN)
                self.state = 1335
                self.integerLiteral()
                self.state = 1336
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_localContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_local

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_local" ):
                listener.enterTraversalMethod_local(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_local" ):
                listener.exitTraversalMethod_local(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_local" ):
                return visitor.visitTraversalMethod_local(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_local(self):

        localctx = GremlinParser.TraversalMethod_localContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_traversalMethod_local)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1340
            self.match(GremlinParser.T__59)
            self.state = 1341
            self.match(GremlinParser.LPAREN)
            self.state = 1342
            self.nestedTraversal()
            self.state = 1343
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_loopsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_loops

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_loops_EmptyContext(TraversalMethod_loopsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_loopsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_loops_Empty" ):
                listener.enterTraversalMethod_loops_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_loops_Empty" ):
                listener.exitTraversalMethod_loops_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_loops_Empty" ):
                return visitor.visitTraversalMethod_loops_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_loops_StringContext(TraversalMethod_loopsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_loopsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_loops_String" ):
                listener.enterTraversalMethod_loops_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_loops_String" ):
                listener.exitTraversalMethod_loops_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_loops_String" ):
                return visitor.visitTraversalMethod_loops_String(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_loops(self):

        localctx = GremlinParser.TraversalMethod_loopsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_traversalMethod_loops)
        try:
            self.state = 1353
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_loops_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1345
                self.match(GremlinParser.T__60)
                self.state = 1346
                self.match(GremlinParser.LPAREN)
                self.state = 1347
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_loops_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1348
                self.match(GremlinParser.T__60)
                self.state = 1349
                self.match(GremlinParser.LPAREN)
                self.state = 1350
                self.stringLiteral()
                self.state = 1351
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_mapContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_map

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_map" ):
                listener.enterTraversalMethod_map(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_map" ):
                listener.exitTraversalMethod_map(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_map" ):
                return visitor.visitTraversalMethod_map(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_map(self):

        localctx = GremlinParser.TraversalMethod_mapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_traversalMethod_map)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1355
            self.match(GremlinParser.T__61)
            self.state = 1356
            self.match(GremlinParser.LPAREN)
            self.state = 1357
            self.nestedTraversal()
            self.state = 1358
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_matchContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversalList(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_match

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_match" ):
                listener.enterTraversalMethod_match(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_match" ):
                listener.exitTraversalMethod_match(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_match" ):
                return visitor.visitTraversalMethod_match(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_match(self):

        localctx = GremlinParser.TraversalMethod_matchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_traversalMethod_match)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1360
            self.match(GremlinParser.T__62)
            self.state = 1361
            self.match(GremlinParser.LPAREN)
            self.state = 1362
            self.nestedTraversalList()
            self.state = 1363
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_mathContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_math

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_math" ):
                listener.enterTraversalMethod_math(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_math" ):
                listener.exitTraversalMethod_math(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_math" ):
                return visitor.visitTraversalMethod_math(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_math(self):

        localctx = GremlinParser.TraversalMethod_mathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_traversalMethod_math)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1365
            self.match(GremlinParser.T__63)
            self.state = 1366
            self.match(GremlinParser.LPAREN)
            self.state = 1367
            self.stringLiteral()
            self.state = 1368
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_maxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_max

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_max_ScopeContext(TraversalMethod_maxContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_maxContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_max_Scope" ):
                listener.enterTraversalMethod_max_Scope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_max_Scope" ):
                listener.exitTraversalMethod_max_Scope(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_max_Scope" ):
                return visitor.visitTraversalMethod_max_Scope(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_max_EmptyContext(TraversalMethod_maxContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_maxContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_max_Empty" ):
                listener.enterTraversalMethod_max_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_max_Empty" ):
                listener.exitTraversalMethod_max_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_max_Empty" ):
                return visitor.visitTraversalMethod_max_Empty(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_max(self):

        localctx = GremlinParser.TraversalMethod_maxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_traversalMethod_max)
        try:
            self.state = 1378
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_max_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1370
                self.match(GremlinParser.T__64)
                self.state = 1371
                self.match(GremlinParser.LPAREN)
                self.state = 1372
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_max_ScopeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1373
                self.match(GremlinParser.T__64)
                self.state = 1374
                self.match(GremlinParser.LPAREN)
                self.state = 1375
                self.traversalScope()
                self.state = 1376
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_meanContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_mean

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_mean_EmptyContext(TraversalMethod_meanContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_meanContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_mean_Empty" ):
                listener.enterTraversalMethod_mean_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_mean_Empty" ):
                listener.exitTraversalMethod_mean_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_mean_Empty" ):
                return visitor.visitTraversalMethod_mean_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_mean_ScopeContext(TraversalMethod_meanContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_meanContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_mean_Scope" ):
                listener.enterTraversalMethod_mean_Scope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_mean_Scope" ):
                listener.exitTraversalMethod_mean_Scope(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_mean_Scope" ):
                return visitor.visitTraversalMethod_mean_Scope(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_mean(self):

        localctx = GremlinParser.TraversalMethod_meanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_traversalMethod_mean)
        try:
            self.state = 1388
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_mean_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1380
                self.match(GremlinParser.T__65)
                self.state = 1381
                self.match(GremlinParser.LPAREN)
                self.state = 1382
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_mean_ScopeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1383
                self.match(GremlinParser.T__65)
                self.state = 1384
                self.match(GremlinParser.LPAREN)
                self.state = 1385
                self.traversalScope()
                self.state = 1386
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_minContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_min

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_min_EmptyContext(TraversalMethod_minContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_minContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_min_Empty" ):
                listener.enterTraversalMethod_min_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_min_Empty" ):
                listener.exitTraversalMethod_min_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_min_Empty" ):
                return visitor.visitTraversalMethod_min_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_min_ScopeContext(TraversalMethod_minContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_minContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_min_Scope" ):
                listener.enterTraversalMethod_min_Scope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_min_Scope" ):
                listener.exitTraversalMethod_min_Scope(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_min_Scope" ):
                return visitor.visitTraversalMethod_min_Scope(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_min(self):

        localctx = GremlinParser.TraversalMethod_minContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_traversalMethod_min)
        try:
            self.state = 1398
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_min_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1390
                self.match(GremlinParser.T__66)
                self.state = 1391
                self.match(GremlinParser.LPAREN)
                self.state = 1392
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_min_ScopeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1393
                self.match(GremlinParser.T__66)
                self.state = 1394
                self.match(GremlinParser.LPAREN)
                self.state = 1395
                self.traversalScope()
                self.state = 1396
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_notContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_not

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_not" ):
                listener.enterTraversalMethod_not(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_not" ):
                listener.exitTraversalMethod_not(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_not" ):
                return visitor.visitTraversalMethod_not(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_not(self):

        localctx = GremlinParser.TraversalMethod_notContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_traversalMethod_not)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1400
            self.match(GremlinParser.T__67)
            self.state = 1401
            self.match(GremlinParser.LPAREN)
            self.state = 1402
            self.nestedTraversal()
            self.state = 1403
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_optionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_option

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_option_TraversalContext(TraversalMethod_optionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_optionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_option_Traversal" ):
                listener.enterTraversalMethod_option_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_option_Traversal" ):
                listener.exitTraversalMethod_option_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_option_Traversal" ):
                return visitor.visitTraversalMethod_option_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_option_Object_TraversalContext(TraversalMethod_optionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_optionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_option_Object_Traversal" ):
                listener.enterTraversalMethod_option_Object_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_option_Object_Traversal" ):
                listener.exitTraversalMethod_option_Object_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_option_Object_Traversal" ):
                return visitor.visitTraversalMethod_option_Object_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_option_Predicate_TraversalContext(TraversalMethod_optionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_optionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_option_Predicate_Traversal" ):
                listener.enterTraversalMethod_option_Predicate_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_option_Predicate_Traversal" ):
                listener.exitTraversalMethod_option_Predicate_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_option_Predicate_Traversal" ):
                return visitor.visitTraversalMethod_option_Predicate_Traversal(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_option(self):

        localctx = GremlinParser.TraversalMethod_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_traversalMethod_option)
        try:
            self.state = 1424
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_option_Predicate_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1405
                self.match(GremlinParser.T__68)
                self.state = 1406
                self.match(GremlinParser.LPAREN)
                self.state = 1407
                self.traversalPredicate(0)
                self.state = 1408
                self.match(GremlinParser.COMMA)
                self.state = 1409
                self.nestedTraversal()
                self.state = 1410
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_option_Object_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1412
                self.match(GremlinParser.T__68)
                self.state = 1413
                self.match(GremlinParser.LPAREN)
                self.state = 1414
                self.genericLiteral()
                self.state = 1415
                self.match(GremlinParser.COMMA)
                self.state = 1416
                self.nestedTraversal()
                self.state = 1417
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = GremlinParser.TraversalMethod_option_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1419
                self.match(GremlinParser.T__68)
                self.state = 1420
                self.match(GremlinParser.LPAREN)
                self.state = 1421
                self.nestedTraversal()
                self.state = 1422
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_optionalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_optional

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_optional" ):
                listener.enterTraversalMethod_optional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_optional" ):
                listener.exitTraversalMethod_optional(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_optional" ):
                return visitor.visitTraversalMethod_optional(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_optional(self):

        localctx = GremlinParser.TraversalMethod_optionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_traversalMethod_optional)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1426
            self.match(GremlinParser.T__69)
            self.state = 1427
            self.match(GremlinParser.LPAREN)
            self.state = 1428
            self.nestedTraversal()
            self.state = 1429
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_orContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversalList(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_or

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_or" ):
                listener.enterTraversalMethod_or(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_or" ):
                listener.exitTraversalMethod_or(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_or" ):
                return visitor.visitTraversalMethod_or(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_or(self):

        localctx = GremlinParser.TraversalMethod_orContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_traversalMethod_or)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1431
            self.match(GremlinParser.T__70)
            self.state = 1432
            self.match(GremlinParser.LPAREN)
            self.state = 1433
            self.nestedTraversalList()
            self.state = 1434
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_orderContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_order

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_order_EmptyContext(TraversalMethod_orderContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_orderContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_order_Empty" ):
                listener.enterTraversalMethod_order_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_order_Empty" ):
                listener.exitTraversalMethod_order_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_order_Empty" ):
                return visitor.visitTraversalMethod_order_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_order_ScopeContext(TraversalMethod_orderContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_orderContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_order_Scope" ):
                listener.enterTraversalMethod_order_Scope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_order_Scope" ):
                listener.exitTraversalMethod_order_Scope(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_order_Scope" ):
                return visitor.visitTraversalMethod_order_Scope(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_order(self):

        localctx = GremlinParser.TraversalMethod_orderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_traversalMethod_order)
        try:
            self.state = 1444
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_order_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1436
                self.match(GremlinParser.T__71)
                self.state = 1437
                self.match(GremlinParser.LPAREN)
                self.state = 1438
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_order_ScopeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1439
                self.match(GremlinParser.T__71)
                self.state = 1440
                self.match(GremlinParser.LPAREN)
                self.state = 1441
                self.traversalScope()
                self.state = 1442
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_otherVContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_otherV

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_otherV" ):
                listener.enterTraversalMethod_otherV(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_otherV" ):
                listener.exitTraversalMethod_otherV(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_otherV" ):
                return visitor.visitTraversalMethod_otherV(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_otherV(self):

        localctx = GremlinParser.TraversalMethod_otherVContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_traversalMethod_otherV)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1446
            self.match(GremlinParser.T__72)
            self.state = 1447
            self.match(GremlinParser.LPAREN)
            self.state = 1448
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_outContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_out

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_out" ):
                listener.enterTraversalMethod_out(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_out" ):
                listener.exitTraversalMethod_out(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_out" ):
                return visitor.visitTraversalMethod_out(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_out(self):

        localctx = GremlinParser.TraversalMethod_outContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_traversalMethod_out)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1450
            self.match(GremlinParser.T__73)
            self.state = 1451
            self.match(GremlinParser.LPAREN)
            self.state = 1452
            self.stringLiteralList()
            self.state = 1453
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_outEContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_outE

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_outE" ):
                listener.enterTraversalMethod_outE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_outE" ):
                listener.exitTraversalMethod_outE(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_outE" ):
                return visitor.visitTraversalMethod_outE(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_outE(self):

        localctx = GremlinParser.TraversalMethod_outEContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_traversalMethod_outE)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1455
            self.match(GremlinParser.T__74)
            self.state = 1456
            self.match(GremlinParser.LPAREN)
            self.state = 1457
            self.stringLiteralList()
            self.state = 1458
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_outVContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_outV

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_outV" ):
                listener.enterTraversalMethod_outV(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_outV" ):
                listener.exitTraversalMethod_outV(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_outV" ):
                return visitor.visitTraversalMethod_outV(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_outV(self):

        localctx = GremlinParser.TraversalMethod_outVContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_traversalMethod_outV)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1460
            self.match(GremlinParser.T__75)
            self.state = 1461
            self.match(GremlinParser.LPAREN)
            self.state = 1462
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_pageRankContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_pageRank

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_pageRank_EmptyContext(TraversalMethod_pageRankContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_pageRankContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_pageRank_Empty" ):
                listener.enterTraversalMethod_pageRank_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_pageRank_Empty" ):
                listener.exitTraversalMethod_pageRank_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_pageRank_Empty" ):
                return visitor.visitTraversalMethod_pageRank_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_pageRank_doubleContext(TraversalMethod_pageRankContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_pageRankContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def floatLiteral(self):
            return self.getTypedRuleContext(GremlinParser.FloatLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_pageRank_double" ):
                listener.enterTraversalMethod_pageRank_double(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_pageRank_double" ):
                listener.exitTraversalMethod_pageRank_double(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_pageRank_double" ):
                return visitor.visitTraversalMethod_pageRank_double(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_pageRank(self):

        localctx = GremlinParser.TraversalMethod_pageRankContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_traversalMethod_pageRank)
        try:
            self.state = 1472
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_pageRank_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1464
                self.match(GremlinParser.T__76)
                self.state = 1465
                self.match(GremlinParser.LPAREN)
                self.state = 1466
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_pageRank_doubleContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1467
                self.match(GremlinParser.T__76)
                self.state = 1468
                self.match(GremlinParser.LPAREN)
                self.state = 1469
                self.floatLiteral()
                self.state = 1470
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_pathContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_path

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_path" ):
                listener.enterTraversalMethod_path(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_path" ):
                listener.exitTraversalMethod_path(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_path" ):
                return visitor.visitTraversalMethod_path(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_path(self):

        localctx = GremlinParser.TraversalMethod_pathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_traversalMethod_path)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1474
            self.match(GremlinParser.T__77)
            self.state = 1475
            self.match(GremlinParser.LPAREN)
            self.state = 1476
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_peerPressureContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_peerPressure

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_peerPressure" ):
                listener.enterTraversalMethod_peerPressure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_peerPressure" ):
                listener.exitTraversalMethod_peerPressure(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_peerPressure" ):
                return visitor.visitTraversalMethod_peerPressure(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_peerPressure(self):

        localctx = GremlinParser.TraversalMethod_peerPressureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_traversalMethod_peerPressure)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1478
            self.match(GremlinParser.T__78)
            self.state = 1479
            self.match(GremlinParser.LPAREN)
            self.state = 1480
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_profileContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_profile

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_profile_EmptyContext(TraversalMethod_profileContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_profileContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_profile_Empty" ):
                listener.enterTraversalMethod_profile_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_profile_Empty" ):
                listener.exitTraversalMethod_profile_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_profile_Empty" ):
                return visitor.visitTraversalMethod_profile_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_profile_StringContext(TraversalMethod_profileContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_profileContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_profile_String" ):
                listener.enterTraversalMethod_profile_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_profile_String" ):
                listener.exitTraversalMethod_profile_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_profile_String" ):
                return visitor.visitTraversalMethod_profile_String(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_profile(self):

        localctx = GremlinParser.TraversalMethod_profileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_traversalMethod_profile)
        try:
            self.state = 1490
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_profile_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1482
                self.match(GremlinParser.T__79)
                self.state = 1483
                self.match(GremlinParser.LPAREN)
                self.state = 1484
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_profile_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1485
                self.match(GremlinParser.T__79)
                self.state = 1486
                self.match(GremlinParser.LPAREN)
                self.state = 1487
                self.stringLiteral()
                self.state = 1488
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_projectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_project" ):
                listener.enterTraversalMethod_project(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_project" ):
                listener.exitTraversalMethod_project(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_project" ):
                return visitor.visitTraversalMethod_project(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_project(self):

        localctx = GremlinParser.TraversalMethod_projectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_traversalMethod_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1492
            self.match(GremlinParser.T__80)
            self.state = 1493
            self.match(GremlinParser.LPAREN)
            self.state = 1494
            self.stringLiteral()
            self.state = 1497
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GremlinParser.COMMA:
                self.state = 1495
                self.match(GremlinParser.COMMA)
                self.state = 1496
                self.stringLiteralList()


            self.state = 1499
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_propertiesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_properties

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_properties" ):
                listener.enterTraversalMethod_properties(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_properties" ):
                listener.exitTraversalMethod_properties(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_properties" ):
                return visitor.visitTraversalMethod_properties(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_properties(self):

        localctx = GremlinParser.TraversalMethod_propertiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_traversalMethod_properties)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1501
            self.match(GremlinParser.T__81)
            self.state = 1502
            self.match(GremlinParser.LPAREN)
            self.state = 1503
            self.stringLiteralList()
            self.state = 1504
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_propertyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_property

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_property_Object_Object_ObjectContext(TraversalMethod_propertyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_propertyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def genericLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.GenericLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def genericLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_property_Object_Object_Object" ):
                listener.enterTraversalMethod_property_Object_Object_Object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_property_Object_Object_Object" ):
                listener.exitTraversalMethod_property_Object_Object_Object(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_property_Object_Object_Object" ):
                return visitor.visitTraversalMethod_property_Object_Object_Object(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_property_Cardinality_Object_Object_ObjectContext(TraversalMethod_propertyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_propertyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalCardinality(self):
            return self.getTypedRuleContext(GremlinParser.TraversalCardinalityContext,0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)
        def genericLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.GenericLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,i)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def genericLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_property_Cardinality_Object_Object_Object" ):
                listener.enterTraversalMethod_property_Cardinality_Object_Object_Object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_property_Cardinality_Object_Object_Object" ):
                listener.exitTraversalMethod_property_Cardinality_Object_Object_Object(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_property_Cardinality_Object_Object_Object" ):
                return visitor.visitTraversalMethod_property_Cardinality_Object_Object_Object(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_property(self):

        localctx = GremlinParser.TraversalMethod_propertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_traversalMethod_property)
        self._la = 0 # Token type
        try:
            self.state = 1530
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_property_Cardinality_Object_Object_ObjectContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1506
                self.match(GremlinParser.T__82)
                self.state = 1507
                self.match(GremlinParser.LPAREN)
                self.state = 1508
                self.traversalCardinality()
                self.state = 1509
                self.match(GremlinParser.COMMA)
                self.state = 1510
                self.genericLiteral()
                self.state = 1511
                self.match(GremlinParser.COMMA)
                self.state = 1512
                self.genericLiteral()
                self.state = 1515
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.COMMA:
                    self.state = 1513
                    self.match(GremlinParser.COMMA)
                    self.state = 1514
                    self.genericLiteralList()


                self.state = 1517
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_property_Object_Object_ObjectContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1519
                self.match(GremlinParser.T__82)
                self.state = 1520
                self.match(GremlinParser.LPAREN)
                self.state = 1521
                self.genericLiteral()
                self.state = 1522
                self.match(GremlinParser.COMMA)
                self.state = 1523
                self.genericLiteral()
                self.state = 1526
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.COMMA:
                    self.state = 1524
                    self.match(GremlinParser.COMMA)
                    self.state = 1525
                    self.genericLiteralList()


                self.state = 1528
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_propertyMapContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_propertyMap

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_propertyMap" ):
                listener.enterTraversalMethod_propertyMap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_propertyMap" ):
                listener.exitTraversalMethod_propertyMap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_propertyMap" ):
                return visitor.visitTraversalMethod_propertyMap(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_propertyMap(self):

        localctx = GremlinParser.TraversalMethod_propertyMapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_traversalMethod_propertyMap)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1532
            self.match(GremlinParser.T__83)
            self.state = 1533
            self.match(GremlinParser.LPAREN)
            self.state = 1534
            self.stringLiteralList()
            self.state = 1535
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_rangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_range

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_range_Scope_long_longContext(TraversalMethod_rangeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_rangeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)
        def integerLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.IntegerLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,i)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_range_Scope_long_long" ):
                listener.enterTraversalMethod_range_Scope_long_long(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_range_Scope_long_long" ):
                listener.exitTraversalMethod_range_Scope_long_long(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_range_Scope_long_long" ):
                return visitor.visitTraversalMethod_range_Scope_long_long(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_range_long_longContext(TraversalMethod_rangeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_rangeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def integerLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.IntegerLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,i)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_range_long_long" ):
                listener.enterTraversalMethod_range_long_long(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_range_long_long" ):
                listener.exitTraversalMethod_range_long_long(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_range_long_long" ):
                return visitor.visitTraversalMethod_range_long_long(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_range(self):

        localctx = GremlinParser.TraversalMethod_rangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_traversalMethod_range)
        try:
            self.state = 1553
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_range_Scope_long_longContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1537
                self.match(GremlinParser.T__84)
                self.state = 1538
                self.match(GremlinParser.LPAREN)
                self.state = 1539
                self.traversalScope()
                self.state = 1540
                self.match(GremlinParser.COMMA)
                self.state = 1541
                self.integerLiteral()
                self.state = 1542
                self.match(GremlinParser.COMMA)
                self.state = 1543
                self.integerLiteral()
                self.state = 1544
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_range_long_longContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1546
                self.match(GremlinParser.T__84)
                self.state = 1547
                self.match(GremlinParser.LPAREN)
                self.state = 1548
                self.integerLiteral()
                self.state = 1549
                self.match(GremlinParser.COMMA)
                self.state = 1550
                self.integerLiteral()
                self.state = 1551
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_readContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_read

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_read" ):
                listener.enterTraversalMethod_read(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_read" ):
                listener.exitTraversalMethod_read(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_read" ):
                return visitor.visitTraversalMethod_read(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_read(self):

        localctx = GremlinParser.TraversalMethod_readContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_traversalMethod_read)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1555
            self.match(GremlinParser.T__85)
            self.state = 1556
            self.match(GremlinParser.LPAREN)
            self.state = 1557
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_repeatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_repeat

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_repeat_String_TraversalContext(TraversalMethod_repeatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_repeatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_repeat_String_Traversal" ):
                listener.enterTraversalMethod_repeat_String_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_repeat_String_Traversal" ):
                listener.exitTraversalMethod_repeat_String_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_repeat_String_Traversal" ):
                return visitor.visitTraversalMethod_repeat_String_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_repeat_TraversalContext(TraversalMethod_repeatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_repeatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_repeat_Traversal" ):
                listener.enterTraversalMethod_repeat_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_repeat_Traversal" ):
                listener.exitTraversalMethod_repeat_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_repeat_Traversal" ):
                return visitor.visitTraversalMethod_repeat_Traversal(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_repeat(self):

        localctx = GremlinParser.TraversalMethod_repeatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_traversalMethod_repeat)
        try:
            self.state = 1571
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_repeat_String_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1559
                self.match(GremlinParser.T__86)
                self.state = 1560
                self.match(GremlinParser.LPAREN)
                self.state = 1561
                self.stringLiteral()
                self.state = 1562
                self.match(GremlinParser.COMMA)
                self.state = 1563
                self.nestedTraversal()
                self.state = 1564
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_repeat_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1566
                self.match(GremlinParser.T__86)
                self.state = 1567
                self.match(GremlinParser.LPAREN)
                self.state = 1568
                self.nestedTraversal()
                self.state = 1569
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_sackContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_sack

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_sack_EmptyContext(TraversalMethod_sackContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_sackContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_sack_Empty" ):
                listener.enterTraversalMethod_sack_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_sack_Empty" ):
                listener.exitTraversalMethod_sack_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_sack_Empty" ):
                return visitor.visitTraversalMethod_sack_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_sack_BiFunctionContext(TraversalMethod_sackContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_sackContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalBiFunction(self):
            return self.getTypedRuleContext(GremlinParser.TraversalBiFunctionContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_sack_BiFunction" ):
                listener.enterTraversalMethod_sack_BiFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_sack_BiFunction" ):
                listener.exitTraversalMethod_sack_BiFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_sack_BiFunction" ):
                return visitor.visitTraversalMethod_sack_BiFunction(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_sack(self):

        localctx = GremlinParser.TraversalMethod_sackContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_traversalMethod_sack)
        try:
            self.state = 1581
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_sack_BiFunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1573
                self.match(GremlinParser.T__87)
                self.state = 1574
                self.match(GremlinParser.LPAREN)
                self.state = 1575
                self.traversalBiFunction()
                self.state = 1576
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_sack_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1578
                self.match(GremlinParser.T__87)
                self.state = 1579
                self.match(GremlinParser.LPAREN)
                self.state = 1580
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_sampleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_sample

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_sample_intContext(TraversalMethod_sampleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_sampleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_sample_int" ):
                listener.enterTraversalMethod_sample_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_sample_int" ):
                listener.exitTraversalMethod_sample_int(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_sample_int" ):
                return visitor.visitTraversalMethod_sample_int(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_sample_Scope_intContext(TraversalMethod_sampleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_sampleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_sample_Scope_int" ):
                listener.enterTraversalMethod_sample_Scope_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_sample_Scope_int" ):
                listener.exitTraversalMethod_sample_Scope_int(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_sample_Scope_int" ):
                return visitor.visitTraversalMethod_sample_Scope_int(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_sample(self):

        localctx = GremlinParser.TraversalMethod_sampleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_traversalMethod_sample)
        try:
            self.state = 1595
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_sample_Scope_intContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1583
                self.match(GremlinParser.T__88)
                self.state = 1584
                self.match(GremlinParser.LPAREN)
                self.state = 1585
                self.traversalScope()
                self.state = 1586
                self.match(GremlinParser.COMMA)
                self.state = 1587
                self.integerLiteral()
                self.state = 1588
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_sample_intContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1590
                self.match(GremlinParser.T__88)
                self.state = 1591
                self.match(GremlinParser.LPAREN)
                self.state = 1592
                self.integerLiteral()
                self.state = 1593
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_selectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_select

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_select_String_String_StringContext(TraversalMethod_selectContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_selectContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.StringLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.StringLiteralContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_select_String_String_String" ):
                listener.enterTraversalMethod_select_String_String_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_select_String_String_String" ):
                listener.exitTraversalMethod_select_String_String_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_select_String_String_String" ):
                return visitor.visitTraversalMethod_select_String_String_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_select_Pop_TraversalContext(TraversalMethod_selectContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_selectContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPop(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPopContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_select_Pop_Traversal" ):
                listener.enterTraversalMethod_select_Pop_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_select_Pop_Traversal" ):
                listener.exitTraversalMethod_select_Pop_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_select_Pop_Traversal" ):
                return visitor.visitTraversalMethod_select_Pop_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_select_Pop_String_String_StringContext(TraversalMethod_selectContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_selectContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPop(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPopContext,0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)
        def stringLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.StringLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.StringLiteralContext,i)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_select_Pop_String_String_String" ):
                listener.enterTraversalMethod_select_Pop_String_String_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_select_Pop_String_String_String" ):
                listener.exitTraversalMethod_select_Pop_String_String_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_select_Pop_String_String_String" ):
                return visitor.visitTraversalMethod_select_Pop_String_String_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_select_StringContext(TraversalMethod_selectContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_selectContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_select_String" ):
                listener.enterTraversalMethod_select_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_select_String" ):
                listener.exitTraversalMethod_select_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_select_String" ):
                return visitor.visitTraversalMethod_select_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_select_ColumnContext(TraversalMethod_selectContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_selectContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalColumn(self):
            return self.getTypedRuleContext(GremlinParser.TraversalColumnContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_select_Column" ):
                listener.enterTraversalMethod_select_Column(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_select_Column" ):
                listener.exitTraversalMethod_select_Column(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_select_Column" ):
                return visitor.visitTraversalMethod_select_Column(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_select_TraversalContext(TraversalMethod_selectContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_selectContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_select_Traversal" ):
                listener.enterTraversalMethod_select_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_select_Traversal" ):
                listener.exitTraversalMethod_select_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_select_Traversal" ):
                return visitor.visitTraversalMethod_select_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_select_Pop_StringContext(TraversalMethod_selectContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_selectContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPop(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPopContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_select_Pop_String" ):
                listener.enterTraversalMethod_select_Pop_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_select_Pop_String" ):
                listener.exitTraversalMethod_select_Pop_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_select_Pop_String" ):
                return visitor.visitTraversalMethod_select_Pop_String(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_select(self):

        localctx = GremlinParser.TraversalMethod_selectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_traversalMethod_select)
        self._la = 0 # Token type
        try:
            self.state = 1650
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_select_ColumnContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1597
                self.match(GremlinParser.T__89)
                self.state = 1598
                self.match(GremlinParser.LPAREN)
                self.state = 1599
                self.traversalColumn()
                self.state = 1600
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_select_Pop_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1602
                self.match(GremlinParser.T__89)
                self.state = 1603
                self.match(GremlinParser.LPAREN)
                self.state = 1604
                self.traversalPop()
                self.state = 1605
                self.match(GremlinParser.COMMA)
                self.state = 1606
                self.stringLiteral()
                self.state = 1607
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = GremlinParser.TraversalMethod_select_Pop_String_String_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1609
                self.match(GremlinParser.T__89)
                self.state = 1610
                self.match(GremlinParser.LPAREN)
                self.state = 1611
                self.traversalPop()
                self.state = 1612
                self.match(GremlinParser.COMMA)
                self.state = 1613
                self.stringLiteral()
                self.state = 1614
                self.match(GremlinParser.COMMA)
                self.state = 1615
                self.stringLiteral()
                self.state = 1618
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.COMMA:
                    self.state = 1616
                    self.match(GremlinParser.COMMA)
                    self.state = 1617
                    self.stringLiteralList()


                self.state = 1620
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 4:
                localctx = GremlinParser.TraversalMethod_select_Pop_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1622
                self.match(GremlinParser.T__89)
                self.state = 1623
                self.match(GremlinParser.LPAREN)
                self.state = 1624
                self.traversalPop()
                self.state = 1625
                self.match(GremlinParser.COMMA)
                self.state = 1626
                self.nestedTraversal()
                self.state = 1627
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 5:
                localctx = GremlinParser.TraversalMethod_select_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1629
                self.match(GremlinParser.T__89)
                self.state = 1630
                self.match(GremlinParser.LPAREN)
                self.state = 1631
                self.stringLiteral()
                self.state = 1632
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 6:
                localctx = GremlinParser.TraversalMethod_select_String_String_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1634
                self.match(GremlinParser.T__89)
                self.state = 1635
                self.match(GremlinParser.LPAREN)
                self.state = 1636
                self.stringLiteral()
                self.state = 1637
                self.match(GremlinParser.COMMA)
                self.state = 1638
                self.stringLiteral()
                self.state = 1641
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.COMMA:
                    self.state = 1639
                    self.match(GremlinParser.COMMA)
                    self.state = 1640
                    self.stringLiteralList()


                self.state = 1643
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 7:
                localctx = GremlinParser.TraversalMethod_select_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1645
                self.match(GremlinParser.T__89)
                self.state = 1646
                self.match(GremlinParser.LPAREN)
                self.state = 1647
                self.nestedTraversal()
                self.state = 1648
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_shortestPathContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_shortestPath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_shortestPath" ):
                listener.enterTraversalMethod_shortestPath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_shortestPath" ):
                listener.exitTraversalMethod_shortestPath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_shortestPath" ):
                return visitor.visitTraversalMethod_shortestPath(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_shortestPath(self):

        localctx = GremlinParser.TraversalMethod_shortestPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_traversalMethod_shortestPath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1652
            self.match(GremlinParser.T__90)
            self.state = 1653
            self.match(GremlinParser.LPAREN)
            self.state = 1654
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_sideEffectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_sideEffect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_sideEffect" ):
                listener.enterTraversalMethod_sideEffect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_sideEffect" ):
                listener.exitTraversalMethod_sideEffect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_sideEffect" ):
                return visitor.visitTraversalMethod_sideEffect(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_sideEffect(self):

        localctx = GremlinParser.TraversalMethod_sideEffectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_traversalMethod_sideEffect)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1656
            self.match(GremlinParser.T__91)
            self.state = 1657
            self.match(GremlinParser.LPAREN)
            self.state = 1658
            self.nestedTraversal()
            self.state = 1659
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_simplePathContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_simplePath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_simplePath" ):
                listener.enterTraversalMethod_simplePath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_simplePath" ):
                listener.exitTraversalMethod_simplePath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_simplePath" ):
                return visitor.visitTraversalMethod_simplePath(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_simplePath(self):

        localctx = GremlinParser.TraversalMethod_simplePathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_traversalMethod_simplePath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1661
            self.match(GremlinParser.T__92)
            self.state = 1662
            self.match(GremlinParser.LPAREN)
            self.state = 1663
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_skipContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_skip

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_skip_longContext(TraversalMethod_skipContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_skipContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_skip_long" ):
                listener.enterTraversalMethod_skip_long(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_skip_long" ):
                listener.exitTraversalMethod_skip_long(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_skip_long" ):
                return visitor.visitTraversalMethod_skip_long(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_skip_Scope_longContext(TraversalMethod_skipContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_skipContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_skip_Scope_long" ):
                listener.enterTraversalMethod_skip_Scope_long(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_skip_Scope_long" ):
                listener.exitTraversalMethod_skip_Scope_long(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_skip_Scope_long" ):
                return visitor.visitTraversalMethod_skip_Scope_long(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_skip(self):

        localctx = GremlinParser.TraversalMethod_skipContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_traversalMethod_skip)
        try:
            self.state = 1677
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_skip_Scope_longContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1665
                self.match(GremlinParser.T__93)
                self.state = 1666
                self.match(GremlinParser.LPAREN)
                self.state = 1667
                self.traversalScope()
                self.state = 1668
                self.match(GremlinParser.COMMA)
                self.state = 1669
                self.integerLiteral()
                self.state = 1670
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_skip_longContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1672
                self.match(GremlinParser.T__93)
                self.state = 1673
                self.match(GremlinParser.LPAREN)
                self.state = 1674
                self.integerLiteral()
                self.state = 1675
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_storeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_store

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_store" ):
                listener.enterTraversalMethod_store(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_store" ):
                listener.exitTraversalMethod_store(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_store" ):
                return visitor.visitTraversalMethod_store(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_store(self):

        localctx = GremlinParser.TraversalMethod_storeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_traversalMethod_store)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1679
            self.match(GremlinParser.T__94)
            self.state = 1680
            self.match(GremlinParser.LPAREN)
            self.state = 1681
            self.stringLiteral()
            self.state = 1682
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_subgraphContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_subgraph

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_subgraph" ):
                listener.enterTraversalMethod_subgraph(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_subgraph" ):
                listener.exitTraversalMethod_subgraph(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_subgraph" ):
                return visitor.visitTraversalMethod_subgraph(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_subgraph(self):

        localctx = GremlinParser.TraversalMethod_subgraphContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_traversalMethod_subgraph)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1684
            self.match(GremlinParser.T__95)
            self.state = 1685
            self.match(GremlinParser.LPAREN)
            self.state = 1686
            self.stringLiteral()
            self.state = 1687
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_sumContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_sum

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_sum_EmptyContext(TraversalMethod_sumContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_sumContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_sum_Empty" ):
                listener.enterTraversalMethod_sum_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_sum_Empty" ):
                listener.exitTraversalMethod_sum_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_sum_Empty" ):
                return visitor.visitTraversalMethod_sum_Empty(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_sum_ScopeContext(TraversalMethod_sumContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_sumContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_sum_Scope" ):
                listener.enterTraversalMethod_sum_Scope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_sum_Scope" ):
                listener.exitTraversalMethod_sum_Scope(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_sum_Scope" ):
                return visitor.visitTraversalMethod_sum_Scope(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_sum(self):

        localctx = GremlinParser.TraversalMethod_sumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_traversalMethod_sum)
        try:
            self.state = 1697
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_sum_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1689
                self.match(GremlinParser.T__96)
                self.state = 1690
                self.match(GremlinParser.LPAREN)
                self.state = 1691
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_sum_ScopeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1692
                self.match(GremlinParser.T__96)
                self.state = 1693
                self.match(GremlinParser.LPAREN)
                self.state = 1694
                self.traversalScope()
                self.state = 1695
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_tail

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_tail_longContext(TraversalMethod_tailContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_tailContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_tail_long" ):
                listener.enterTraversalMethod_tail_long(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_tail_long" ):
                listener.exitTraversalMethod_tail_long(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_tail_long" ):
                return visitor.visitTraversalMethod_tail_long(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_tail_ScopeContext(TraversalMethod_tailContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_tailContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_tail_Scope" ):
                listener.enterTraversalMethod_tail_Scope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_tail_Scope" ):
                listener.exitTraversalMethod_tail_Scope(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_tail_Scope" ):
                return visitor.visitTraversalMethod_tail_Scope(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_tail_Scope_longContext(TraversalMethod_tailContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_tailContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalScope(self):
            return self.getTypedRuleContext(GremlinParser.TraversalScopeContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_tail_Scope_long" ):
                listener.enterTraversalMethod_tail_Scope_long(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_tail_Scope_long" ):
                listener.exitTraversalMethod_tail_Scope_long(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_tail_Scope_long" ):
                return visitor.visitTraversalMethod_tail_Scope_long(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_tail_EmptyContext(TraversalMethod_tailContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_tailContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_tail_Empty" ):
                listener.enterTraversalMethod_tail_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_tail_Empty" ):
                listener.exitTraversalMethod_tail_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_tail_Empty" ):
                return visitor.visitTraversalMethod_tail_Empty(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_tail(self):

        localctx = GremlinParser.TraversalMethod_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_traversalMethod_tail)
        try:
            self.state = 1719
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_tail_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1699
                self.match(GremlinParser.T__97)
                self.state = 1700
                self.match(GremlinParser.LPAREN)
                self.state = 1701
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_tail_ScopeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1702
                self.match(GremlinParser.T__97)
                self.state = 1703
                self.match(GremlinParser.LPAREN)
                self.state = 1704
                self.traversalScope()
                self.state = 1705
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = GremlinParser.TraversalMethod_tail_Scope_longContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1707
                self.match(GremlinParser.T__97)
                self.state = 1708
                self.match(GremlinParser.LPAREN)
                self.state = 1709
                self.traversalScope()
                self.state = 1710
                self.match(GremlinParser.COMMA)
                self.state = 1711
                self.integerLiteral()
                self.state = 1712
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 4:
                localctx = GremlinParser.TraversalMethod_tail_longContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1714
                self.match(GremlinParser.T__97)
                self.state = 1715
                self.match(GremlinParser.LPAREN)
                self.state = 1716
                self.integerLiteral()
                self.state = 1717
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_timeLimitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_timeLimit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_timeLimit" ):
                listener.enterTraversalMethod_timeLimit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_timeLimit" ):
                listener.exitTraversalMethod_timeLimit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_timeLimit" ):
                return visitor.visitTraversalMethod_timeLimit(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_timeLimit(self):

        localctx = GremlinParser.TraversalMethod_timeLimitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_traversalMethod_timeLimit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1721
            self.match(GremlinParser.T__98)
            self.state = 1722
            self.match(GremlinParser.LPAREN)
            self.state = 1723
            self.integerLiteral()
            self.state = 1724
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_timesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_times

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_times" ):
                listener.enterTraversalMethod_times(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_times" ):
                listener.exitTraversalMethod_times(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_times" ):
                return visitor.visitTraversalMethod_times(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_times(self):

        localctx = GremlinParser.TraversalMethod_timesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_traversalMethod_times)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1726
            self.match(GremlinParser.T__99)
            self.state = 1727
            self.match(GremlinParser.LPAREN)
            self.state = 1728
            self.integerLiteral()
            self.state = 1729
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_toContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_to

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_to_Direction_StringContext(TraversalMethod_toContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_toContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalDirection(self):
            return self.getTypedRuleContext(GremlinParser.TraversalDirectionContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_to_Direction_String" ):
                listener.enterTraversalMethod_to_Direction_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_to_Direction_String" ):
                listener.exitTraversalMethod_to_Direction_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_to_Direction_String" ):
                return visitor.visitTraversalMethod_to_Direction_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_to_StringContext(TraversalMethod_toContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_toContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_to_String" ):
                listener.enterTraversalMethod_to_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_to_String" ):
                listener.exitTraversalMethod_to_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_to_String" ):
                return visitor.visitTraversalMethod_to_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_to_TraversalContext(TraversalMethod_toContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_toContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_to_Traversal" ):
                listener.enterTraversalMethod_to_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_to_Traversal" ):
                listener.exitTraversalMethod_to_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_to_Traversal" ):
                return visitor.visitTraversalMethod_to_Traversal(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_to(self):

        localctx = GremlinParser.TraversalMethod_toContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_traversalMethod_to)
        self._la = 0 # Token type
        try:
            self.state = 1750
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_to_Direction_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1731
                self.match(GremlinParser.T__100)
                self.state = 1732
                self.match(GremlinParser.LPAREN)
                self.state = 1733
                self.traversalDirection()
                self.state = 1736
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.COMMA:
                    self.state = 1734
                    self.match(GremlinParser.COMMA)
                    self.state = 1735
                    self.stringLiteralList()


                self.state = 1738
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_to_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1740
                self.match(GremlinParser.T__100)
                self.state = 1741
                self.match(GremlinParser.LPAREN)
                self.state = 1742
                self.stringLiteral()
                self.state = 1743
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = GremlinParser.TraversalMethod_to_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1745
                self.match(GremlinParser.T__100)
                self.state = 1746
                self.match(GremlinParser.LPAREN)
                self.state = 1747
                self.nestedTraversal()
                self.state = 1748
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_toEContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def traversalDirection(self):
            return self.getTypedRuleContext(GremlinParser.TraversalDirectionContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_toE

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_toE" ):
                listener.enterTraversalMethod_toE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_toE" ):
                listener.exitTraversalMethod_toE(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_toE" ):
                return visitor.visitTraversalMethod_toE(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_toE(self):

        localctx = GremlinParser.TraversalMethod_toEContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_traversalMethod_toE)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1752
            self.match(GremlinParser.T__101)
            self.state = 1753
            self.match(GremlinParser.LPAREN)
            self.state = 1754
            self.traversalDirection()
            self.state = 1757
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GremlinParser.COMMA:
                self.state = 1755
                self.match(GremlinParser.COMMA)
                self.state = 1756
                self.stringLiteralList()


            self.state = 1759
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_toVContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def traversalDirection(self):
            return self.getTypedRuleContext(GremlinParser.TraversalDirectionContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_toV

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_toV" ):
                listener.enterTraversalMethod_toV(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_toV" ):
                listener.exitTraversalMethod_toV(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_toV" ):
                return visitor.visitTraversalMethod_toV(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_toV(self):

        localctx = GremlinParser.TraversalMethod_toVContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_traversalMethod_toV)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1761
            self.match(GremlinParser.T__102)
            self.state = 1762
            self.match(GremlinParser.LPAREN)
            self.state = 1763
            self.traversalDirection()
            self.state = 1764
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_treeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_tree

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_tree_StringContext(TraversalMethod_treeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_treeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_tree_String" ):
                listener.enterTraversalMethod_tree_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_tree_String" ):
                listener.exitTraversalMethod_tree_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_tree_String" ):
                return visitor.visitTraversalMethod_tree_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_tree_EmptyContext(TraversalMethod_treeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_treeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_tree_Empty" ):
                listener.enterTraversalMethod_tree_Empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_tree_Empty" ):
                listener.exitTraversalMethod_tree_Empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_tree_Empty" ):
                return visitor.visitTraversalMethod_tree_Empty(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_tree(self):

        localctx = GremlinParser.TraversalMethod_treeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_traversalMethod_tree)
        try:
            self.state = 1774
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_tree_EmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1766
                self.match(GremlinParser.T__103)
                self.state = 1767
                self.match(GremlinParser.LPAREN)
                self.state = 1768
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_tree_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1769
                self.match(GremlinParser.T__103)
                self.state = 1770
                self.match(GremlinParser.LPAREN)
                self.state = 1771
                self.stringLiteral()
                self.state = 1772
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_unfoldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_unfold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_unfold" ):
                listener.enterTraversalMethod_unfold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_unfold" ):
                listener.exitTraversalMethod_unfold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_unfold" ):
                return visitor.visitTraversalMethod_unfold(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_unfold(self):

        localctx = GremlinParser.TraversalMethod_unfoldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_traversalMethod_unfold)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1776
            self.match(GremlinParser.T__104)
            self.state = 1777
            self.match(GremlinParser.LPAREN)
            self.state = 1778
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_unionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def nestedTraversalList(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_union

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_union" ):
                listener.enterTraversalMethod_union(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_union" ):
                listener.exitTraversalMethod_union(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_union" ):
                return visitor.visitTraversalMethod_union(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_union(self):

        localctx = GremlinParser.TraversalMethod_unionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_traversalMethod_union)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1780
            self.match(GremlinParser.T__105)
            self.state = 1781
            self.match(GremlinParser.LPAREN)
            self.state = 1782
            self.nestedTraversalList()
            self.state = 1783
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_untilContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_until

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_until_TraversalContext(TraversalMethod_untilContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_untilContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_until_Traversal" ):
                listener.enterTraversalMethod_until_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_until_Traversal" ):
                listener.exitTraversalMethod_until_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_until_Traversal" ):
                return visitor.visitTraversalMethod_until_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_until_PredicateContext(TraversalMethod_untilContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_untilContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_until_Predicate" ):
                listener.enterTraversalMethod_until_Predicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_until_Predicate" ):
                listener.exitTraversalMethod_until_Predicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_until_Predicate" ):
                return visitor.visitTraversalMethod_until_Predicate(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_until(self):

        localctx = GremlinParser.TraversalMethod_untilContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_traversalMethod_until)
        try:
            self.state = 1795
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_until_PredicateContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1785
                self.match(GremlinParser.T__106)
                self.state = 1786
                self.match(GremlinParser.LPAREN)
                self.state = 1787
                self.traversalPredicate(0)
                self.state = 1788
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_until_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1790
                self.match(GremlinParser.T__106)
                self.state = 1791
                self.match(GremlinParser.LPAREN)
                self.state = 1792
                self.nestedTraversal()
                self.state = 1793
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_value" ):
                listener.enterTraversalMethod_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_value" ):
                listener.exitTraversalMethod_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_value" ):
                return visitor.visitTraversalMethod_value(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_value(self):

        localctx = GremlinParser.TraversalMethod_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_traversalMethod_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1797
            self.match(GremlinParser.T__107)
            self.state = 1798
            self.match(GremlinParser.LPAREN)
            self.state = 1799
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_valueMapContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_valueMap

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_valueMap_boolean_StringContext(TraversalMethod_valueMapContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_valueMapContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def booleanLiteral(self):
            return self.getTypedRuleContext(GremlinParser.BooleanLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)
        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_valueMap_boolean_String" ):
                listener.enterTraversalMethod_valueMap_boolean_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_valueMap_boolean_String" ):
                listener.exitTraversalMethod_valueMap_boolean_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_valueMap_boolean_String" ):
                return visitor.visitTraversalMethod_valueMap_boolean_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_valueMap_StringContext(TraversalMethod_valueMapContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_valueMapContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_valueMap_String" ):
                listener.enterTraversalMethod_valueMap_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_valueMap_String" ):
                listener.exitTraversalMethod_valueMap_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_valueMap_String" ):
                return visitor.visitTraversalMethod_valueMap_String(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_valueMap(self):

        localctx = GremlinParser.TraversalMethod_valueMapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_traversalMethod_valueMap)
        self._la = 0 # Token type
        try:
            self.state = 1815
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_valueMap_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1801
                self.match(GremlinParser.T__108)
                self.state = 1802
                self.match(GremlinParser.LPAREN)
                self.state = 1803
                self.stringLiteralList()
                self.state = 1804
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_valueMap_boolean_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1806
                self.match(GremlinParser.T__108)
                self.state = 1807
                self.match(GremlinParser.LPAREN)
                self.state = 1808
                self.booleanLiteral()
                self.state = 1811
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.COMMA:
                    self.state = 1809
                    self.match(GremlinParser.COMMA)
                    self.state = 1810
                    self.stringLiteralList()


                self.state = 1813
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_valuesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_values

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_values" ):
                listener.enterTraversalMethod_values(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_values" ):
                listener.exitTraversalMethod_values(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_values" ):
                return visitor.visitTraversalMethod_values(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_values(self):

        localctx = GremlinParser.TraversalMethod_valuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_traversalMethod_values)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1817
            self.match(GremlinParser.T__109)
            self.state = 1818
            self.match(GremlinParser.LPAREN)
            self.state = 1819
            self.stringLiteralList()
            self.state = 1820
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_whereContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_where

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_where_PContext(TraversalMethod_whereContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_whereContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_where_P" ):
                listener.enterTraversalMethod_where_P(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_where_P" ):
                listener.exitTraversalMethod_where_P(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_where_P" ):
                return visitor.visitTraversalMethod_where_P(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_where_TraversalContext(TraversalMethod_whereContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_whereContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_where_Traversal" ):
                listener.enterTraversalMethod_where_Traversal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_where_Traversal" ):
                listener.exitTraversalMethod_where_Traversal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_where_Traversal" ):
                return visitor.visitTraversalMethod_where_Traversal(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_where_String_PContext(TraversalMethod_whereContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_whereContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_where_String_P" ):
                listener.enterTraversalMethod_where_String_P(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_where_String_P" ):
                listener.exitTraversalMethod_where_String_P(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_where_String_P" ):
                return visitor.visitTraversalMethod_where_String_P(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_where(self):

        localctx = GremlinParser.TraversalMethod_whereContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_traversalMethod_where)
        try:
            self.state = 1839
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_where_PContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1822
                self.match(GremlinParser.T__110)
                self.state = 1823
                self.match(GremlinParser.LPAREN)
                self.state = 1824
                self.traversalPredicate(0)
                self.state = 1825
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_where_String_PContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1827
                self.match(GremlinParser.T__110)
                self.state = 1828
                self.match(GremlinParser.LPAREN)
                self.state = 1829
                self.stringLiteral()
                self.state = 1830
                self.match(GremlinParser.COMMA)
                self.state = 1831
                self.traversalPredicate(0)
                self.state = 1832
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                localctx = GremlinParser.TraversalMethod_where_TraversalContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1834
                self.match(GremlinParser.T__110)
                self.state = 1835
                self.match(GremlinParser.LPAREN)
                self.state = 1836
                self.nestedTraversal()
                self.state = 1837
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_withContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_with

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TraversalMethod_with_StringContext(TraversalMethod_withContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_withContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_with_String" ):
                listener.enterTraversalMethod_with_String(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_with_String" ):
                listener.exitTraversalMethod_with_String(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_with_String" ):
                return visitor.visitTraversalMethod_with_String(self)
            else:
                return visitor.visitChildren(self)


    class TraversalMethod_with_String_ObjectContext(TraversalMethod_withContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GremlinParser.TraversalMethod_withContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)

        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)
        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_with_String_Object" ):
                listener.enterTraversalMethod_with_String_Object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_with_String_Object" ):
                listener.exitTraversalMethod_with_String_Object(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_with_String_Object" ):
                return visitor.visitTraversalMethod_with_String_Object(self)
            else:
                return visitor.visitChildren(self)



    def traversalMethod_with(self):

        localctx = GremlinParser.TraversalMethod_withContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_traversalMethod_with)
        try:
            self.state = 1853
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                localctx = GremlinParser.TraversalMethod_with_StringContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1841
                self.match(GremlinParser.T__9)
                self.state = 1842
                self.match(GremlinParser.LPAREN)
                self.state = 1843
                self.stringLiteral()
                self.state = 1844
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = GremlinParser.TraversalMethod_with_String_ObjectContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1846
                self.match(GremlinParser.T__9)
                self.state = 1847
                self.match(GremlinParser.LPAREN)
                self.state = 1848
                self.stringLiteral()
                self.state = 1849
                self.match(GremlinParser.COMMA)
                self.state = 1850
                self.genericLiteral()
                self.state = 1851
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalMethod_writeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalMethod_write

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalMethod_write" ):
                listener.enterTraversalMethod_write(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalMethod_write" ):
                listener.exitTraversalMethod_write(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalMethod_write" ):
                return visitor.visitTraversalMethod_write(self)
            else:
                return visitor.visitChildren(self)




    def traversalMethod_write(self):

        localctx = GremlinParser.TraversalMethod_writeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_traversalMethod_write)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1855
            self.match(GremlinParser.T__111)
            self.state = 1856
            self.match(GremlinParser.LPAREN)
            self.state = 1857
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalStrategyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEW(self):
            return self.getToken(GremlinParser.NEW, 0)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def traversalStrategyArgs_PartitionStrategy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.TraversalStrategyArgs_PartitionStrategyContext)
            else:
                return self.getTypedRuleContext(GremlinParser.TraversalStrategyArgs_PartitionStrategyContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)

        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)


        def traversalStrategyArgs_SubgraphStrategy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.TraversalStrategyArgs_SubgraphStrategyContext)
            else:
                return self.getTypedRuleContext(GremlinParser.TraversalStrategyArgs_SubgraphStrategyContext,i)


        def traversalStrategyArgs_EdgeLabelVerificationStrategy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.TraversalStrategyArgs_EdgeLabelVerificationStrategyContext)
            else:
                return self.getTypedRuleContext(GremlinParser.TraversalStrategyArgs_EdgeLabelVerificationStrategyContext,i)


        def traversalStrategyArgs_ReservedKeysVerificationStrategy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.TraversalStrategyArgs_ReservedKeysVerificationStrategyContext)
            else:
                return self.getTypedRuleContext(GremlinParser.TraversalStrategyArgs_ReservedKeysVerificationStrategyContext,i)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalStrategy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalStrategy" ):
                listener.enterTraversalStrategy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalStrategy" ):
                listener.exitTraversalStrategy(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalStrategy" ):
                return visitor.visitTraversalStrategy(self)
            else:
                return visitor.visitChildren(self)




    def traversalStrategy(self):

        localctx = GremlinParser.TraversalStrategyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_traversalStrategy)
        self._la = 0 # Token type
        try:
            self.state = 1922
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1859
                self.match(GremlinParser.NEW)
                self.state = 1860
                self.match(GremlinParser.T__112)
                self.state = 1861
                self.match(GremlinParser.LPAREN)
                self.state = 1863
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 119)) & ~0x3f) == 0 and ((1 << (_la - 119)) & ((1 << (GremlinParser.T__118 - 119)) | (1 << (GremlinParser.T__119 - 119)) | (1 << (GremlinParser.T__120 - 119)) | (1 << (GremlinParser.T__121 - 119)))) != 0):
                    self.state = 1862
                    self.traversalStrategyArgs_PartitionStrategy()


                self.state = 1869
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GremlinParser.COMMA:
                    self.state = 1865
                    self.match(GremlinParser.COMMA)
                    self.state = 1866
                    self.traversalStrategyArgs_PartitionStrategy()
                    self.state = 1871
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1872
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1873
                self.match(GremlinParser.NEW)
                self.state = 1874
                self.match(GremlinParser.T__113)
                self.state = 1875
                self.match(GremlinParser.LPAREN)
                self.state = 1876
                self.integerLiteral()
                self.state = 1877
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1879
                self.match(GremlinParser.NEW)
                self.state = 1880
                self.match(GremlinParser.T__114)
                self.state = 1881
                self.match(GremlinParser.LPAREN)
                self.state = 1883
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 123)) & ~0x3f) == 0 and ((1 << (_la - 123)) & ((1 << (GremlinParser.T__122 - 123)) | (1 << (GremlinParser.T__123 - 123)) | (1 << (GremlinParser.T__124 - 123)) | (1 << (GremlinParser.T__125 - 123)))) != 0):
                    self.state = 1882
                    self.traversalStrategyArgs_SubgraphStrategy()


                self.state = 1889
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GremlinParser.COMMA:
                    self.state = 1885
                    self.match(GremlinParser.COMMA)
                    self.state = 1886
                    self.traversalStrategyArgs_SubgraphStrategy()
                    self.state = 1891
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1892
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1893
                self.match(GremlinParser.NEW)
                self.state = 1894
                self.match(GremlinParser.T__115)
                self.state = 1895
                self.match(GremlinParser.LPAREN)
                self.state = 1897
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GremlinParser.T__126 or _la==GremlinParser.T__127:
                    self.state = 1896
                    self.traversalStrategyArgs_EdgeLabelVerificationStrategy()


                self.state = 1903
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GremlinParser.COMMA:
                    self.state = 1899
                    self.match(GremlinParser.COMMA)
                    self.state = 1900
                    self.traversalStrategyArgs_EdgeLabelVerificationStrategy()
                    self.state = 1905
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1906
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1907
                self.match(GremlinParser.T__116)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1908
                self.match(GremlinParser.NEW)
                self.state = 1909
                self.match(GremlinParser.T__117)
                self.state = 1910
                self.match(GremlinParser.LPAREN)
                self.state = 1912
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & ((1 << (GremlinParser.T__126 - 127)) | (1 << (GremlinParser.T__127 - 127)) | (1 << (GremlinParser.T__128 - 127)))) != 0):
                    self.state = 1911
                    self.traversalStrategyArgs_ReservedKeysVerificationStrategy()


                self.state = 1918
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GremlinParser.COMMA:
                    self.state = 1914
                    self.match(GremlinParser.COMMA)
                    self.state = 1915
                    self.traversalStrategyArgs_ReservedKeysVerificationStrategy()
                    self.state = 1920
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1921
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalStrategyArgs_PartitionStrategyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(GremlinParser.COLON, 0)

        def booleanLiteral(self):
            return self.getTypedRuleContext(GremlinParser.BooleanLiteralContext,0)


        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalStrategyArgs_PartitionStrategy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalStrategyArgs_PartitionStrategy" ):
                listener.enterTraversalStrategyArgs_PartitionStrategy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalStrategyArgs_PartitionStrategy" ):
                listener.exitTraversalStrategyArgs_PartitionStrategy(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalStrategyArgs_PartitionStrategy" ):
                return visitor.visitTraversalStrategyArgs_PartitionStrategy(self)
            else:
                return visitor.visitChildren(self)




    def traversalStrategyArgs_PartitionStrategy(self):

        localctx = GremlinParser.TraversalStrategyArgs_PartitionStrategyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_traversalStrategyArgs_PartitionStrategy)
        try:
            self.state = 1936
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__118]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1924
                self.match(GremlinParser.T__118)
                self.state = 1925
                self.match(GremlinParser.COLON)
                self.state = 1926
                self.booleanLiteral()
                pass
            elif token in [GremlinParser.T__119]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1927
                self.match(GremlinParser.T__119)
                self.state = 1928
                self.match(GremlinParser.COLON)
                self.state = 1929
                self.stringLiteral()
                pass
            elif token in [GremlinParser.T__120]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1930
                self.match(GremlinParser.T__120)
                self.state = 1931
                self.match(GremlinParser.COLON)
                self.state = 1932
                self.stringLiteral()
                pass
            elif token in [GremlinParser.T__121]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1933
                self.match(GremlinParser.T__121)
                self.state = 1934
                self.match(GremlinParser.COLON)
                self.state = 1935
                self.stringLiteralList()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalStrategyArgs_SubgraphStrategyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(GremlinParser.COLON, 0)

        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)


        def booleanLiteral(self):
            return self.getTypedRuleContext(GremlinParser.BooleanLiteralContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalStrategyArgs_SubgraphStrategy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalStrategyArgs_SubgraphStrategy" ):
                listener.enterTraversalStrategyArgs_SubgraphStrategy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalStrategyArgs_SubgraphStrategy" ):
                listener.exitTraversalStrategyArgs_SubgraphStrategy(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalStrategyArgs_SubgraphStrategy" ):
                return visitor.visitTraversalStrategyArgs_SubgraphStrategy(self)
            else:
                return visitor.visitChildren(self)




    def traversalStrategyArgs_SubgraphStrategy(self):

        localctx = GremlinParser.TraversalStrategyArgs_SubgraphStrategyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_traversalStrategyArgs_SubgraphStrategy)
        try:
            self.state = 1950
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__122]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1938
                self.match(GremlinParser.T__122)
                self.state = 1939
                self.match(GremlinParser.COLON)
                self.state = 1940
                self.nestedTraversal()
                pass
            elif token in [GremlinParser.T__123]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1941
                self.match(GremlinParser.T__123)
                self.state = 1942
                self.match(GremlinParser.COLON)
                self.state = 1943
                self.nestedTraversal()
                pass
            elif token in [GremlinParser.T__124]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1944
                self.match(GremlinParser.T__124)
                self.state = 1945
                self.match(GremlinParser.COLON)
                self.state = 1946
                self.nestedTraversal()
                pass
            elif token in [GremlinParser.T__125]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1947
                self.match(GremlinParser.T__125)
                self.state = 1948
                self.match(GremlinParser.COLON)
                self.state = 1949
                self.booleanLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalStrategyArgs_EdgeLabelVerificationStrategyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(GremlinParser.COLON, 0)

        def booleanLiteral(self):
            return self.getTypedRuleContext(GremlinParser.BooleanLiteralContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalStrategyArgs_EdgeLabelVerificationStrategy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalStrategyArgs_EdgeLabelVerificationStrategy" ):
                listener.enterTraversalStrategyArgs_EdgeLabelVerificationStrategy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalStrategyArgs_EdgeLabelVerificationStrategy" ):
                listener.exitTraversalStrategyArgs_EdgeLabelVerificationStrategy(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalStrategyArgs_EdgeLabelVerificationStrategy" ):
                return visitor.visitTraversalStrategyArgs_EdgeLabelVerificationStrategy(self)
            else:
                return visitor.visitChildren(self)




    def traversalStrategyArgs_EdgeLabelVerificationStrategy(self):

        localctx = GremlinParser.TraversalStrategyArgs_EdgeLabelVerificationStrategyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_traversalStrategyArgs_EdgeLabelVerificationStrategy)
        try:
            self.state = 1958
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__126]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1952
                self.match(GremlinParser.T__126)
                self.state = 1953
                self.match(GremlinParser.COLON)
                self.state = 1954
                self.booleanLiteral()
                pass
            elif token in [GremlinParser.T__127]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1955
                self.match(GremlinParser.T__127)
                self.state = 1956
                self.match(GremlinParser.COLON)
                self.state = 1957
                self.booleanLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalStrategyArgs_ReservedKeysVerificationStrategyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(GremlinParser.COLON, 0)

        def stringLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralListContext,0)


        def booleanLiteral(self):
            return self.getTypedRuleContext(GremlinParser.BooleanLiteralContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalStrategyArgs_ReservedKeysVerificationStrategy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalStrategyArgs_ReservedKeysVerificationStrategy" ):
                listener.enterTraversalStrategyArgs_ReservedKeysVerificationStrategy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalStrategyArgs_ReservedKeysVerificationStrategy" ):
                listener.exitTraversalStrategyArgs_ReservedKeysVerificationStrategy(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalStrategyArgs_ReservedKeysVerificationStrategy" ):
                return visitor.visitTraversalStrategyArgs_ReservedKeysVerificationStrategy(self)
            else:
                return visitor.visitChildren(self)




    def traversalStrategyArgs_ReservedKeysVerificationStrategy(self):

        localctx = GremlinParser.TraversalStrategyArgs_ReservedKeysVerificationStrategyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_traversalStrategyArgs_ReservedKeysVerificationStrategy)
        try:
            self.state = 1969
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__128]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1960
                self.match(GremlinParser.T__128)
                self.state = 1961
                self.match(GremlinParser.COLON)
                self.state = 1962
                self.stringLiteralList()
                pass
            elif token in [GremlinParser.T__126]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1963
                self.match(GremlinParser.T__126)
                self.state = 1964
                self.match(GremlinParser.COLON)
                self.state = 1965
                self.booleanLiteral()
                pass
            elif token in [GremlinParser.T__127]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1966
                self.match(GremlinParser.T__127)
                self.state = 1967
                self.match(GremlinParser.COLON)
                self.state = 1968
                self.booleanLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalScopeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalScope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalScope" ):
                listener.enterTraversalScope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalScope" ):
                listener.exitTraversalScope(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalScope" ):
                return visitor.visitTraversalScope(self)
            else:
                return visitor.visitChildren(self)




    def traversalScope(self):

        localctx = GremlinParser.TraversalScopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_traversalScope)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1971
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__59 or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & ((1 << (GremlinParser.T__129 - 130)) | (1 << (GremlinParser.T__130 - 130)) | (1 << (GremlinParser.T__131 - 130)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalTokenContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalToken

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalToken" ):
                listener.enterTraversalToken(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalToken" ):
                listener.exitTraversalToken(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalToken" ):
                return visitor.visitTraversalToken(self)
            else:
                return visitor.visitChildren(self)




    def traversalToken(self):

        localctx = GremlinParser.TraversalTokenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_traversalToken)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1973
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GremlinParser.T__49) | (1 << GremlinParser.T__56) | (1 << GremlinParser.T__57))) != 0) or ((((_la - 108)) & ~0x3f) == 0 and ((1 << (_la - 108)) & ((1 << (GremlinParser.T__107 - 108)) | (1 << (GremlinParser.T__132 - 108)) | (1 << (GremlinParser.T__133 - 108)) | (1 << (GremlinParser.T__134 - 108)) | (1 << (GremlinParser.T__135 - 108)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalOrderContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalOrder

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalOrder" ):
                listener.enterTraversalOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalOrder" ):
                listener.exitTraversalOrder(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalOrder" ):
                return visitor.visitTraversalOrder(self)
            else:
                return visitor.visitChildren(self)




    def traversalOrder(self):

        localctx = GremlinParser.TraversalOrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_traversalOrder)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1975
            _la = self._input.LA(1)
            if not(((((_la - 137)) & ~0x3f) == 0 and ((1 << (_la - 137)) & ((1 << (GremlinParser.T__136 - 137)) | (1 << (GremlinParser.T__137 - 137)) | (1 << (GremlinParser.T__138 - 137)) | (1 << (GremlinParser.T__139 - 137)) | (1 << (GremlinParser.T__140 - 137)) | (1 << (GremlinParser.T__141 - 137)) | (1 << (GremlinParser.T__142 - 137)) | (1 << (GremlinParser.T__143 - 137)) | (1 << (GremlinParser.T__144 - 137)) | (1 << (GremlinParser.T__145 - 137)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalDirectionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalDirection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalDirection" ):
                listener.enterTraversalDirection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalDirection" ):
                listener.exitTraversalDirection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalDirection" ):
                return visitor.visitTraversalDirection(self)
            else:
                return visitor.visitChildren(self)




    def traversalDirection(self):

        localctx = GremlinParser.TraversalDirectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_traversalDirection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1977
            _la = self._input.LA(1)
            if not(((((_la - 147)) & ~0x3f) == 0 and ((1 << (_la - 147)) & ((1 << (GremlinParser.T__146 - 147)) | (1 << (GremlinParser.T__147 - 147)) | (1 << (GremlinParser.T__148 - 147)) | (1 << (GremlinParser.T__149 - 147)) | (1 << (GremlinParser.T__150 - 147)) | (1 << (GremlinParser.T__151 - 147)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalCardinalityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalCardinality

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalCardinality" ):
                listener.enterTraversalCardinality(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalCardinality" ):
                listener.exitTraversalCardinality(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalCardinality" ):
                return visitor.visitTraversalCardinality(self)
            else:
                return visitor.visitChildren(self)




    def traversalCardinality(self):

        localctx = GremlinParser.TraversalCardinalityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_traversalCardinality)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1979
            _la = self._input.LA(1)
            if not(((((_la - 153)) & ~0x3f) == 0 and ((1 << (_la - 153)) & ((1 << (GremlinParser.T__152 - 153)) | (1 << (GremlinParser.T__153 - 153)) | (1 << (GremlinParser.T__154 - 153)) | (1 << (GremlinParser.T__155 - 153)) | (1 << (GremlinParser.T__156 - 153)) | (1 << (GremlinParser.T__157 - 153)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalColumnContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalColumn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalColumn" ):
                listener.enterTraversalColumn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalColumn" ):
                listener.exitTraversalColumn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalColumn" ):
                return visitor.visitTraversalColumn(self)
            else:
                return visitor.visitChildren(self)




    def traversalColumn(self):

        localctx = GremlinParser.TraversalColumnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_traversalColumn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1981
            _la = self._input.LA(1)
            if not(((((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & ((1 << (GremlinParser.T__109 - 110)) | (1 << (GremlinParser.T__128 - 110)) | (1 << (GremlinParser.T__158 - 110)) | (1 << (GremlinParser.T__159 - 110)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPop" ):
                listener.enterTraversalPop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPop" ):
                listener.exitTraversalPop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPop" ):
                return visitor.visitTraversalPop(self)
            else:
                return visitor.visitChildren(self)




    def traversalPop(self):

        localctx = GremlinParser.TraversalPopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_traversalPop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1983
            _la = self._input.LA(1)
            if not(((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & ((1 << (GremlinParser.T__160 - 161)) | (1 << (GremlinParser.T__161 - 161)) | (1 << (GremlinParser.T__162 - 161)) | (1 << (GremlinParser.T__163 - 161)) | (1 << (GremlinParser.T__164 - 161)) | (1 << (GremlinParser.T__165 - 161)) | (1 << (GremlinParser.T__166 - 161)) | (1 << (GremlinParser.T__167 - 161)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalOperator" ):
                listener.enterTraversalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalOperator" ):
                listener.exitTraversalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalOperator" ):
                return visitor.visitTraversalOperator(self)
            else:
                return visitor.visitChildren(self)




    def traversalOperator(self):

        localctx = GremlinParser.TraversalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_traversalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1985
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__17 or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (GremlinParser.T__64 - 65)) | (1 << (GremlinParser.T__66 - 65)) | (1 << (GremlinParser.T__70 - 65)) | (1 << (GremlinParser.T__96 - 65)))) != 0) or ((((_la - 169)) & ~0x3f) == 0 and ((1 << (_la - 169)) & ((1 << (GremlinParser.T__168 - 169)) | (1 << (GremlinParser.T__169 - 169)) | (1 << (GremlinParser.T__170 - 169)) | (1 << (GremlinParser.T__171 - 169)) | (1 << (GremlinParser.T__172 - 169)) | (1 << (GremlinParser.T__173 - 169)) | (1 << (GremlinParser.T__174 - 169)) | (1 << (GremlinParser.T__175 - 169)) | (1 << (GremlinParser.T__176 - 169)) | (1 << (GremlinParser.T__177 - 169)) | (1 << (GremlinParser.T__178 - 169)) | (1 << (GremlinParser.T__179 - 169)) | (1 << (GremlinParser.T__180 - 169)) | (1 << (GremlinParser.T__181 - 169)) | (1 << (GremlinParser.T__182 - 169)) | (1 << (GremlinParser.T__183 - 169)) | (1 << (GremlinParser.T__184 - 169)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalOptionParentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalOptionParent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalOptionParent" ):
                listener.enterTraversalOptionParent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalOptionParent" ):
                listener.exitTraversalOptionParent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalOptionParent" ):
                return visitor.visitTraversalOptionParent(self)
            else:
                return visitor.visitChildren(self)




    def traversalOptionParent(self):

        localctx = GremlinParser.TraversalOptionParentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_traversalOptionParent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1987
            _la = self._input.LA(1)
            if not(((((_la - 186)) & ~0x3f) == 0 and ((1 << (_la - 186)) & ((1 << (GremlinParser.T__185 - 186)) | (1 << (GremlinParser.T__186 - 186)) | (1 << (GremlinParser.T__187 - 186)) | (1 << (GremlinParser.T__188 - 186)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalPredicate_eq(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_eqContext,0)


        def traversalPredicate_neq(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_neqContext,0)


        def traversalPredicate_lt(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_ltContext,0)


        def traversalPredicate_lte(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_lteContext,0)


        def traversalPredicate_gt(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_gtContext,0)


        def traversalPredicate_gte(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_gteContext,0)


        def traversalPredicate_inside(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_insideContext,0)


        def traversalPredicate_outside(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_outsideContext,0)


        def traversalPredicate_between(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_betweenContext,0)


        def traversalPredicate_within(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_withinContext,0)


        def traversalPredicate_without(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_withoutContext,0)


        def traversalPredicate_not(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_notContext,0)


        def traversalPredicate_startingWith(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_startingWithContext,0)


        def traversalPredicate_notStartingWith(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_notStartingWithContext,0)


        def traversalPredicate_endingWith(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_endingWithContext,0)


        def traversalPredicate_notEndingWith(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_notEndingWithContext,0)


        def traversalPredicate_containing(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_containingContext,0)


        def traversalPredicate_notContaining(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicate_notContainingContext,0)


        def traversalPredicate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.TraversalPredicateContext)
            else:
                return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,i)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate" ):
                listener.enterTraversalPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate" ):
                listener.exitTraversalPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate" ):
                return visitor.visitTraversalPredicate(self)
            else:
                return visitor.visitChildren(self)



    def traversalPredicate(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = GremlinParser.TraversalPredicateContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 280
        self.enterRecursionRule(localctx, 280, self.RULE_traversalPredicate, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2008
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__192, GremlinParser.T__193]:
                self.state = 1990
                self.traversalPredicate_eq()
                pass
            elif token in [GremlinParser.T__194, GremlinParser.T__195]:
                self.state = 1991
                self.traversalPredicate_neq()
                pass
            elif token in [GremlinParser.T__196, GremlinParser.T__197]:
                self.state = 1992
                self.traversalPredicate_lt()
                pass
            elif token in [GremlinParser.T__198, GremlinParser.T__199]:
                self.state = 1993
                self.traversalPredicate_lte()
                pass
            elif token in [GremlinParser.T__200, GremlinParser.T__201]:
                self.state = 1994
                self.traversalPredicate_gt()
                pass
            elif token in [GremlinParser.T__202, GremlinParser.T__203]:
                self.state = 1995
                self.traversalPredicate_gte()
                pass
            elif token in [GremlinParser.T__204, GremlinParser.T__205]:
                self.state = 1996
                self.traversalPredicate_inside()
                pass
            elif token in [GremlinParser.T__206, GremlinParser.T__207]:
                self.state = 1997
                self.traversalPredicate_outside()
                pass
            elif token in [GremlinParser.T__208, GremlinParser.T__209]:
                self.state = 1998
                self.traversalPredicate_between()
                pass
            elif token in [GremlinParser.T__210, GremlinParser.T__211]:
                self.state = 1999
                self.traversalPredicate_within()
                pass
            elif token in [GremlinParser.T__212, GremlinParser.T__213]:
                self.state = 2000
                self.traversalPredicate_without()
                pass
            elif token in [GremlinParser.T__67, GremlinParser.T__214]:
                self.state = 2001
                self.traversalPredicate_not()
                pass
            elif token in [GremlinParser.T__219, GremlinParser.T__220]:
                self.state = 2002
                self.traversalPredicate_startingWith()
                pass
            elif token in [GremlinParser.T__221, GremlinParser.T__222]:
                self.state = 2003
                self.traversalPredicate_notStartingWith()
                pass
            elif token in [GremlinParser.T__223, GremlinParser.T__224]:
                self.state = 2004
                self.traversalPredicate_endingWith()
                pass
            elif token in [GremlinParser.T__225, GremlinParser.T__226]:
                self.state = 2005
                self.traversalPredicate_notEndingWith()
                pass
            elif token in [GremlinParser.T__215, GremlinParser.T__216]:
                self.state = 2006
                self.traversalPredicate_containing()
                pass
            elif token in [GremlinParser.T__217, GremlinParser.T__218]:
                self.state = 2007
                self.traversalPredicate_notContaining()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 2031
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,95,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2029
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
                    if la_ == 1:
                        localctx = GremlinParser.TraversalPredicateContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_traversalPredicate)
                        self.state = 2010
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 2011
                        self.match(GremlinParser.DOT)
                        self.state = 2012
                        self.match(GremlinParser.T__17)
                        self.state = 2013
                        self.match(GremlinParser.LPAREN)
                        self.state = 2014
                        self.traversalPredicate(0)
                        self.state = 2015
                        self.match(GremlinParser.RPAREN)
                        pass

                    elif la_ == 2:
                        localctx = GremlinParser.TraversalPredicateContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_traversalPredicate)
                        self.state = 2017
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 2018
                        self.match(GremlinParser.DOT)
                        self.state = 2019
                        self.match(GremlinParser.T__70)
                        self.state = 2020
                        self.match(GremlinParser.LPAREN)
                        self.state = 2021
                        self.traversalPredicate(0)
                        self.state = 2022
                        self.match(GremlinParser.RPAREN)
                        pass

                    elif la_ == 3:
                        localctx = GremlinParser.TraversalPredicateContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_traversalPredicate)
                        self.state = 2024
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 2025
                        self.match(GremlinParser.DOT)
                        self.state = 2026
                        self.match(GremlinParser.T__189)
                        self.state = 2027
                        self.match(GremlinParser.LPAREN)
                        self.state = 2028
                        self.match(GremlinParser.RPAREN)
                        pass

             
                self.state = 2033
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,95,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TraversalTerminalMethodContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalTerminalMethod_explain(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTerminalMethod_explainContext,0)


        def traversalTerminalMethod_iterate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTerminalMethod_iterateContext,0)


        def traversalTerminalMethod_hasNext(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTerminalMethod_hasNextContext,0)


        def traversalTerminalMethod_tryNext(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTerminalMethod_tryNextContext,0)


        def traversalTerminalMethod_next(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTerminalMethod_nextContext,0)


        def traversalTerminalMethod_toList(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTerminalMethod_toListContext,0)


        def traversalTerminalMethod_toSet(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTerminalMethod_toSetContext,0)


        def traversalTerminalMethod_toBulkSet(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTerminalMethod_toBulkSetContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalTerminalMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalTerminalMethod" ):
                listener.enterTraversalTerminalMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalTerminalMethod" ):
                listener.exitTraversalTerminalMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalTerminalMethod" ):
                return visitor.visitTraversalTerminalMethod(self)
            else:
                return visitor.visitChildren(self)




    def traversalTerminalMethod(self):

        localctx = GremlinParser.TraversalTerminalMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_traversalTerminalMethod)
        try:
            self.state = 2042
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__227]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2034
                self.traversalTerminalMethod_explain()
                pass
            elif token in [GremlinParser.T__229]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2035
                self.traversalTerminalMethod_iterate()
                pass
            elif token in [GremlinParser.T__228]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2036
                self.traversalTerminalMethod_hasNext()
                pass
            elif token in [GremlinParser.T__230]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2037
                self.traversalTerminalMethod_tryNext()
                pass
            elif token in [GremlinParser.T__231]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2038
                self.traversalTerminalMethod_next()
                pass
            elif token in [GremlinParser.T__232]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2039
                self.traversalTerminalMethod_toList()
                pass
            elif token in [GremlinParser.T__233]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2040
                self.traversalTerminalMethod_toSet()
                pass
            elif token in [GremlinParser.T__234]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2041
                self.traversalTerminalMethod_toBulkSet()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSackMethodContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSackMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSackMethod" ):
                listener.enterTraversalSackMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSackMethod" ):
                listener.exitTraversalSackMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSackMethod" ):
                return visitor.visitTraversalSackMethod(self)
            else:
                return visitor.visitChildren(self)




    def traversalSackMethod(self):

        localctx = GremlinParser.TraversalSackMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_traversalSackMethod)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2044
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__190 or _la==GremlinParser.T__191):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSelfMethodContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalSelfMethod_none(self):
            return self.getTypedRuleContext(GremlinParser.TraversalSelfMethod_noneContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSelfMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSelfMethod" ):
                listener.enterTraversalSelfMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSelfMethod" ):
                listener.exitTraversalSelfMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSelfMethod" ):
                return visitor.visitTraversalSelfMethod(self)
            else:
                return visitor.visitChildren(self)




    def traversalSelfMethod(self):

        localctx = GremlinParser.TraversalSelfMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_traversalSelfMethod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2046
            self.traversalSelfMethod_none()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalComparatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalOrder(self):
            return self.getTypedRuleContext(GremlinParser.TraversalOrderContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalComparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalComparator" ):
                listener.enterTraversalComparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalComparator" ):
                listener.exitTraversalComparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalComparator" ):
                return visitor.visitTraversalComparator(self)
            else:
                return visitor.visitChildren(self)




    def traversalComparator(self):

        localctx = GremlinParser.TraversalComparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_traversalComparator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2048
            self.traversalOrder()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalToken(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTokenContext,0)


        def traversalColumn(self):
            return self.getTypedRuleContext(GremlinParser.TraversalColumnContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalFunction" ):
                listener.enterTraversalFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalFunction" ):
                listener.exitTraversalFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalFunction" ):
                return visitor.visitTraversalFunction(self)
            else:
                return visitor.visitChildren(self)




    def traversalFunction(self):

        localctx = GremlinParser.TraversalFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_traversalFunction)
        try:
            self.state = 2052
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__49, GremlinParser.T__56, GremlinParser.T__57, GremlinParser.T__107, GremlinParser.T__132, GremlinParser.T__133, GremlinParser.T__134, GremlinParser.T__135]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2050
                self.traversalToken()
                pass
            elif token in [GremlinParser.T__109, GremlinParser.T__128, GremlinParser.T__158, GremlinParser.T__159]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2051
                self.traversalColumn()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalBiFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalOperator(self):
            return self.getTypedRuleContext(GremlinParser.TraversalOperatorContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalBiFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalBiFunction" ):
                listener.enterTraversalBiFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalBiFunction" ):
                listener.exitTraversalBiFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalBiFunction" ):
                return visitor.visitTraversalBiFunction(self)
            else:
                return visitor.visitChildren(self)




    def traversalBiFunction(self):

        localctx = GremlinParser.TraversalBiFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_traversalBiFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2054
            self.traversalOperator()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_eqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_eq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_eq" ):
                listener.enterTraversalPredicate_eq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_eq" ):
                listener.exitTraversalPredicate_eq(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_eq" ):
                return visitor.visitTraversalPredicate_eq(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_eq(self):

        localctx = GremlinParser.TraversalPredicate_eqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_traversalPredicate_eq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2056
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__192 or _la==GremlinParser.T__193):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2057
            self.match(GremlinParser.LPAREN)
            self.state = 2058
            self.genericLiteral()
            self.state = 2059
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_neqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_neq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_neq" ):
                listener.enterTraversalPredicate_neq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_neq" ):
                listener.exitTraversalPredicate_neq(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_neq" ):
                return visitor.visitTraversalPredicate_neq(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_neq(self):

        localctx = GremlinParser.TraversalPredicate_neqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_traversalPredicate_neq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2061
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__194 or _la==GremlinParser.T__195):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2062
            self.match(GremlinParser.LPAREN)
            self.state = 2063
            self.genericLiteral()
            self.state = 2064
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_ltContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_lt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_lt" ):
                listener.enterTraversalPredicate_lt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_lt" ):
                listener.exitTraversalPredicate_lt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_lt" ):
                return visitor.visitTraversalPredicate_lt(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_lt(self):

        localctx = GremlinParser.TraversalPredicate_ltContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_traversalPredicate_lt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2066
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__196 or _la==GremlinParser.T__197):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2067
            self.match(GremlinParser.LPAREN)
            self.state = 2068
            self.genericLiteral()
            self.state = 2069
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_lteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_lte

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_lte" ):
                listener.enterTraversalPredicate_lte(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_lte" ):
                listener.exitTraversalPredicate_lte(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_lte" ):
                return visitor.visitTraversalPredicate_lte(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_lte(self):

        localctx = GremlinParser.TraversalPredicate_lteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_traversalPredicate_lte)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2071
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__198 or _la==GremlinParser.T__199):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2072
            self.match(GremlinParser.LPAREN)
            self.state = 2073
            self.genericLiteral()
            self.state = 2074
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_gtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_gt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_gt" ):
                listener.enterTraversalPredicate_gt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_gt" ):
                listener.exitTraversalPredicate_gt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_gt" ):
                return visitor.visitTraversalPredicate_gt(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_gt(self):

        localctx = GremlinParser.TraversalPredicate_gtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_traversalPredicate_gt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2076
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__200 or _la==GremlinParser.T__201):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2077
            self.match(GremlinParser.LPAREN)
            self.state = 2078
            self.genericLiteral()
            self.state = 2079
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_gteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteral(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_gte

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_gte" ):
                listener.enterTraversalPredicate_gte(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_gte" ):
                listener.exitTraversalPredicate_gte(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_gte" ):
                return visitor.visitTraversalPredicate_gte(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_gte(self):

        localctx = GremlinParser.TraversalPredicate_gteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_traversalPredicate_gte)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2081
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__202 or _la==GremlinParser.T__203):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2082
            self.match(GremlinParser.LPAREN)
            self.state = 2083
            self.genericLiteral()
            self.state = 2084
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_insideContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.GenericLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,i)


        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_inside

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_inside" ):
                listener.enterTraversalPredicate_inside(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_inside" ):
                listener.exitTraversalPredicate_inside(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_inside" ):
                return visitor.visitTraversalPredicate_inside(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_inside(self):

        localctx = GremlinParser.TraversalPredicate_insideContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_traversalPredicate_inside)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2086
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__204 or _la==GremlinParser.T__205):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2087
            self.match(GremlinParser.LPAREN)
            self.state = 2088
            self.genericLiteral()
            self.state = 2089
            self.match(GremlinParser.COMMA)
            self.state = 2090
            self.genericLiteral()
            self.state = 2091
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_outsideContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.GenericLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,i)


        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_outside

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_outside" ):
                listener.enterTraversalPredicate_outside(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_outside" ):
                listener.exitTraversalPredicate_outside(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_outside" ):
                return visitor.visitTraversalPredicate_outside(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_outside(self):

        localctx = GremlinParser.TraversalPredicate_outsideContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_traversalPredicate_outside)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2093
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__206 or _la==GremlinParser.T__207):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2094
            self.match(GremlinParser.LPAREN)
            self.state = 2095
            self.genericLiteral()
            self.state = 2096
            self.match(GremlinParser.COMMA)
            self.state = 2097
            self.genericLiteral()
            self.state = 2098
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_betweenContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.GenericLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,i)


        def COMMA(self):
            return self.getToken(GremlinParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_between

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_between" ):
                listener.enterTraversalPredicate_between(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_between" ):
                listener.exitTraversalPredicate_between(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_between" ):
                return visitor.visitTraversalPredicate_between(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_between(self):

        localctx = GremlinParser.TraversalPredicate_betweenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_traversalPredicate_between)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2100
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__208 or _la==GremlinParser.T__209):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2101
            self.match(GremlinParser.LPAREN)
            self.state = 2102
            self.genericLiteral()
            self.state = 2103
            self.match(GremlinParser.COMMA)
            self.state = 2104
            self.genericLiteral()
            self.state = 2105
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_withinContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_within

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_within" ):
                listener.enterTraversalPredicate_within(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_within" ):
                listener.exitTraversalPredicate_within(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_within" ):
                return visitor.visitTraversalPredicate_within(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_within(self):

        localctx = GremlinParser.TraversalPredicate_withinContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_traversalPredicate_within)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2107
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__210 or _la==GremlinParser.T__211):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2108
            self.match(GremlinParser.LPAREN)
            self.state = 2109
            self.genericLiteralList()
            self.state = 2110
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_withoutContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def genericLiteralList(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralListContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_without

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_without" ):
                listener.enterTraversalPredicate_without(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_without" ):
                listener.exitTraversalPredicate_without(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_without" ):
                return visitor.visitTraversalPredicate_without(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_without(self):

        localctx = GremlinParser.TraversalPredicate_withoutContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_traversalPredicate_without)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2112
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__212 or _la==GremlinParser.T__213):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2113
            self.match(GremlinParser.LPAREN)
            self.state = 2114
            self.genericLiteralList()
            self.state = 2115
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_notContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def traversalPredicate(self):
            return self.getTypedRuleContext(GremlinParser.TraversalPredicateContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_not

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_not" ):
                listener.enterTraversalPredicate_not(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_not" ):
                listener.exitTraversalPredicate_not(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_not" ):
                return visitor.visitTraversalPredicate_not(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_not(self):

        localctx = GremlinParser.TraversalPredicate_notContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_traversalPredicate_not)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2117
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__67 or _la==GremlinParser.T__214):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2118
            self.match(GremlinParser.LPAREN)
            self.state = 2119
            self.traversalPredicate(0)
            self.state = 2120
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_containingContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_containing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_containing" ):
                listener.enterTraversalPredicate_containing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_containing" ):
                listener.exitTraversalPredicate_containing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_containing" ):
                return visitor.visitTraversalPredicate_containing(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_containing(self):

        localctx = GremlinParser.TraversalPredicate_containingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_traversalPredicate_containing)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2122
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__215 or _la==GremlinParser.T__216):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2123
            self.match(GremlinParser.LPAREN)
            self.state = 2124
            self.stringLiteral()
            self.state = 2125
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_notContainingContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_notContaining

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_notContaining" ):
                listener.enterTraversalPredicate_notContaining(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_notContaining" ):
                listener.exitTraversalPredicate_notContaining(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_notContaining" ):
                return visitor.visitTraversalPredicate_notContaining(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_notContaining(self):

        localctx = GremlinParser.TraversalPredicate_notContainingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_traversalPredicate_notContaining)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2127
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__217 or _la==GremlinParser.T__218):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2128
            self.match(GremlinParser.LPAREN)
            self.state = 2129
            self.stringLiteral()
            self.state = 2130
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_startingWithContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_startingWith

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_startingWith" ):
                listener.enterTraversalPredicate_startingWith(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_startingWith" ):
                listener.exitTraversalPredicate_startingWith(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_startingWith" ):
                return visitor.visitTraversalPredicate_startingWith(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_startingWith(self):

        localctx = GremlinParser.TraversalPredicate_startingWithContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_traversalPredicate_startingWith)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2132
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__219 or _la==GremlinParser.T__220):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2133
            self.match(GremlinParser.LPAREN)
            self.state = 2134
            self.stringLiteral()
            self.state = 2135
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_notStartingWithContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_notStartingWith

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_notStartingWith" ):
                listener.enterTraversalPredicate_notStartingWith(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_notStartingWith" ):
                listener.exitTraversalPredicate_notStartingWith(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_notStartingWith" ):
                return visitor.visitTraversalPredicate_notStartingWith(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_notStartingWith(self):

        localctx = GremlinParser.TraversalPredicate_notStartingWithContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_traversalPredicate_notStartingWith)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2137
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__221 or _la==GremlinParser.T__222):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2138
            self.match(GremlinParser.LPAREN)
            self.state = 2139
            self.stringLiteral()
            self.state = 2140
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_endingWithContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_endingWith

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_endingWith" ):
                listener.enterTraversalPredicate_endingWith(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_endingWith" ):
                listener.exitTraversalPredicate_endingWith(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_endingWith" ):
                return visitor.visitTraversalPredicate_endingWith(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_endingWith(self):

        localctx = GremlinParser.TraversalPredicate_endingWithContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_traversalPredicate_endingWith)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2142
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__223 or _la==GremlinParser.T__224):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2143
            self.match(GremlinParser.LPAREN)
            self.state = 2144
            self.stringLiteral()
            self.state = 2145
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalPredicate_notEndingWithContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalPredicate_notEndingWith

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalPredicate_notEndingWith" ):
                listener.enterTraversalPredicate_notEndingWith(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalPredicate_notEndingWith" ):
                listener.exitTraversalPredicate_notEndingWith(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalPredicate_notEndingWith" ):
                return visitor.visitTraversalPredicate_notEndingWith(self)
            else:
                return visitor.visitChildren(self)




    def traversalPredicate_notEndingWith(self):

        localctx = GremlinParser.TraversalPredicate_notEndingWithContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_traversalPredicate_notEndingWith)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2147
            _la = self._input.LA(1)
            if not(_la==GremlinParser.T__225 or _la==GremlinParser.T__226):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2148
            self.match(GremlinParser.LPAREN)
            self.state = 2149
            self.stringLiteral()
            self.state = 2150
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalTerminalMethod_explainContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalTerminalMethod_explain

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalTerminalMethod_explain" ):
                listener.enterTraversalTerminalMethod_explain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalTerminalMethod_explain" ):
                listener.exitTraversalTerminalMethod_explain(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalTerminalMethod_explain" ):
                return visitor.visitTraversalTerminalMethod_explain(self)
            else:
                return visitor.visitChildren(self)




    def traversalTerminalMethod_explain(self):

        localctx = GremlinParser.TraversalTerminalMethod_explainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_traversalTerminalMethod_explain)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2152
            self.match(GremlinParser.T__227)
            self.state = 2153
            self.match(GremlinParser.LPAREN)
            self.state = 2154
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalTerminalMethod_hasNextContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalTerminalMethod_hasNext

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalTerminalMethod_hasNext" ):
                listener.enterTraversalTerminalMethod_hasNext(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalTerminalMethod_hasNext" ):
                listener.exitTraversalTerminalMethod_hasNext(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalTerminalMethod_hasNext" ):
                return visitor.visitTraversalTerminalMethod_hasNext(self)
            else:
                return visitor.visitChildren(self)




    def traversalTerminalMethod_hasNext(self):

        localctx = GremlinParser.TraversalTerminalMethod_hasNextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_traversalTerminalMethod_hasNext)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2156
            self.match(GremlinParser.T__228)
            self.state = 2157
            self.match(GremlinParser.LPAREN)
            self.state = 2158
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalTerminalMethod_iterateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalTerminalMethod_iterate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalTerminalMethod_iterate" ):
                listener.enterTraversalTerminalMethod_iterate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalTerminalMethod_iterate" ):
                listener.exitTraversalTerminalMethod_iterate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalTerminalMethod_iterate" ):
                return visitor.visitTraversalTerminalMethod_iterate(self)
            else:
                return visitor.visitChildren(self)




    def traversalTerminalMethod_iterate(self):

        localctx = GremlinParser.TraversalTerminalMethod_iterateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_traversalTerminalMethod_iterate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2160
            self.match(GremlinParser.T__229)
            self.state = 2161
            self.match(GremlinParser.LPAREN)
            self.state = 2162
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalTerminalMethod_tryNextContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalTerminalMethod_tryNext

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalTerminalMethod_tryNext" ):
                listener.enterTraversalTerminalMethod_tryNext(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalTerminalMethod_tryNext" ):
                listener.exitTraversalTerminalMethod_tryNext(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalTerminalMethod_tryNext" ):
                return visitor.visitTraversalTerminalMethod_tryNext(self)
            else:
                return visitor.visitChildren(self)




    def traversalTerminalMethod_tryNext(self):

        localctx = GremlinParser.TraversalTerminalMethod_tryNextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_traversalTerminalMethod_tryNext)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2164
            self.match(GremlinParser.T__230)
            self.state = 2165
            self.match(GremlinParser.LPAREN)
            self.state = 2166
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalTerminalMethod_nextContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalTerminalMethod_next

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalTerminalMethod_next" ):
                listener.enterTraversalTerminalMethod_next(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalTerminalMethod_next" ):
                listener.exitTraversalTerminalMethod_next(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalTerminalMethod_next" ):
                return visitor.visitTraversalTerminalMethod_next(self)
            else:
                return visitor.visitChildren(self)




    def traversalTerminalMethod_next(self):

        localctx = GremlinParser.TraversalTerminalMethod_nextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_traversalTerminalMethod_next)
        try:
            self.state = 2176
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2168
                self.match(GremlinParser.T__231)
                self.state = 2169
                self.match(GremlinParser.LPAREN)
                self.state = 2170
                self.match(GremlinParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2171
                self.match(GremlinParser.T__231)
                self.state = 2172
                self.match(GremlinParser.LPAREN)
                self.state = 2173
                self.integerLiteral()
                self.state = 2174
                self.match(GremlinParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalTerminalMethod_toListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalTerminalMethod_toList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalTerminalMethod_toList" ):
                listener.enterTraversalTerminalMethod_toList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalTerminalMethod_toList" ):
                listener.exitTraversalTerminalMethod_toList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalTerminalMethod_toList" ):
                return visitor.visitTraversalTerminalMethod_toList(self)
            else:
                return visitor.visitChildren(self)




    def traversalTerminalMethod_toList(self):

        localctx = GremlinParser.TraversalTerminalMethod_toListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_traversalTerminalMethod_toList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2178
            self.match(GremlinParser.T__232)
            self.state = 2179
            self.match(GremlinParser.LPAREN)
            self.state = 2180
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalTerminalMethod_toSetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalTerminalMethod_toSet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalTerminalMethod_toSet" ):
                listener.enterTraversalTerminalMethod_toSet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalTerminalMethod_toSet" ):
                listener.exitTraversalTerminalMethod_toSet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalTerminalMethod_toSet" ):
                return visitor.visitTraversalTerminalMethod_toSet(self)
            else:
                return visitor.visitChildren(self)




    def traversalTerminalMethod_toSet(self):

        localctx = GremlinParser.TraversalTerminalMethod_toSetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_traversalTerminalMethod_toSet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2182
            self.match(GremlinParser.T__233)
            self.state = 2183
            self.match(GremlinParser.LPAREN)
            self.state = 2184
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalTerminalMethod_toBulkSetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalTerminalMethod_toBulkSet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalTerminalMethod_toBulkSet" ):
                listener.enterTraversalTerminalMethod_toBulkSet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalTerminalMethod_toBulkSet" ):
                listener.exitTraversalTerminalMethod_toBulkSet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalTerminalMethod_toBulkSet" ):
                return visitor.visitTraversalTerminalMethod_toBulkSet(self)
            else:
                return visitor.visitChildren(self)




    def traversalTerminalMethod_toBulkSet(self):

        localctx = GremlinParser.TraversalTerminalMethod_toBulkSetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_traversalTerminalMethod_toBulkSet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2186
            self.match(GremlinParser.T__234)
            self.state = 2187
            self.match(GremlinParser.LPAREN)
            self.state = 2188
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalSelfMethod_noneContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalSelfMethod_none

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalSelfMethod_none" ):
                listener.enterTraversalSelfMethod_none(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalSelfMethod_none" ):
                listener.exitTraversalSelfMethod_none(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalSelfMethod_none" ):
                return visitor.visitTraversalSelfMethod_none(self)
            else:
                return visitor.visitChildren(self)




    def traversalSelfMethod_none(self):

        localctx = GremlinParser.TraversalSelfMethod_noneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_traversalSelfMethod_none)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2190
            self.match(GremlinParser.T__187)
            self.state = 2191
            self.match(GremlinParser.LPAREN)
            self.state = 2192
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstantsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withOptionsStringConstants(self):
            return self.getTypedRuleContext(GremlinParser.WithOptionsStringConstantsContext,0)


        def shortestPathStringConstants(self):
            return self.getTypedRuleContext(GremlinParser.ShortestPathStringConstantsContext,0)


        def pageRankStringConstants(self):
            return self.getTypedRuleContext(GremlinParser.PageRankStringConstantsContext,0)


        def peerPressureStringConstants(self):
            return self.getTypedRuleContext(GremlinParser.PeerPressureStringConstantsContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants" ):
                listener.enterGremlinStringConstants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants" ):
                listener.exitGremlinStringConstants(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants" ):
                return visitor.visitGremlinStringConstants(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants(self):

        localctx = GremlinParser.GremlinStringConstantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_gremlinStringConstants)
        try:
            self.state = 2198
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__247]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2194
                self.withOptionsStringConstants()
                pass
            elif token in [GremlinParser.T__246]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2195
                self.shortestPathStringConstants()
                pass
            elif token in [GremlinParser.T__244]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2196
                self.pageRankStringConstants()
                pass
            elif token in [GremlinParser.T__245]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2197
                self.peerPressureStringConstants()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PageRankStringConstantsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gremlinStringConstants_pageRankStringConstants_edges(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_pageRankStringConstants_edgesContext,0)


        def gremlinStringConstants_pageRankStringConstants_times(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_pageRankStringConstants_timesContext,0)


        def gremlinStringConstants_pageRankStringConstants_propertyName(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_pageRankStringConstants_propertyNameContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_pageRankStringConstants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPageRankStringConstants" ):
                listener.enterPageRankStringConstants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPageRankStringConstants" ):
                listener.exitPageRankStringConstants(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPageRankStringConstants" ):
                return visitor.visitPageRankStringConstants(self)
            else:
                return visitor.visitChildren(self)




    def pageRankStringConstants(self):

        localctx = GremlinParser.PageRankStringConstantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_pageRankStringConstants)
        try:
            self.state = 2203
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2200
                self.gremlinStringConstants_pageRankStringConstants_edges()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2201
                self.gremlinStringConstants_pageRankStringConstants_times()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2202
                self.gremlinStringConstants_pageRankStringConstants_propertyName()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeerPressureStringConstantsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gremlinStringConstants_peerPressureStringConstants_edges(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_peerPressureStringConstants_edgesContext,0)


        def gremlinStringConstants_peerPressureStringConstants_times(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_peerPressureStringConstants_timesContext,0)


        def gremlinStringConstants_peerPressureStringConstants_propertyName(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_peerPressureStringConstants_propertyNameContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_peerPressureStringConstants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeerPressureStringConstants" ):
                listener.enterPeerPressureStringConstants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeerPressureStringConstants" ):
                listener.exitPeerPressureStringConstants(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeerPressureStringConstants" ):
                return visitor.visitPeerPressureStringConstants(self)
            else:
                return visitor.visitChildren(self)




    def peerPressureStringConstants(self):

        localctx = GremlinParser.PeerPressureStringConstantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_peerPressureStringConstants)
        try:
            self.state = 2208
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2205
                self.gremlinStringConstants_peerPressureStringConstants_edges()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2206
                self.gremlinStringConstants_peerPressureStringConstants_times()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2207
                self.gremlinStringConstants_peerPressureStringConstants_propertyName()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShortestPathStringConstantsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gremlinStringConstants_shortestPathStringConstants_target(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_shortestPathStringConstants_targetContext,0)


        def gremlinStringConstants_shortestPathStringConstants_edges(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_shortestPathStringConstants_edgesContext,0)


        def gremlinStringConstants_shortestPathStringConstants_distance(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_shortestPathStringConstants_distanceContext,0)


        def gremlinStringConstants_shortestPathStringConstants_maxDistance(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_shortestPathStringConstants_maxDistanceContext,0)


        def gremlinStringConstants_shortestPathStringConstants_includeEdges(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_shortestPathStringConstants_includeEdgesContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_shortestPathStringConstants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShortestPathStringConstants" ):
                listener.enterShortestPathStringConstants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShortestPathStringConstants" ):
                listener.exitShortestPathStringConstants(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShortestPathStringConstants" ):
                return visitor.visitShortestPathStringConstants(self)
            else:
                return visitor.visitChildren(self)




    def shortestPathStringConstants(self):

        localctx = GremlinParser.ShortestPathStringConstantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_shortestPathStringConstants)
        try:
            self.state = 2215
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2210
                self.gremlinStringConstants_shortestPathStringConstants_target()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2211
                self.gremlinStringConstants_shortestPathStringConstants_edges()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2212
                self.gremlinStringConstants_shortestPathStringConstants_distance()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2213
                self.gremlinStringConstants_shortestPathStringConstants_maxDistance()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2214
                self.gremlinStringConstants_shortestPathStringConstants_includeEdges()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithOptionsStringConstantsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gremlinStringConstants_withOptionsStringConstants_tokens(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_withOptionsStringConstants_tokensContext,0)


        def gremlinStringConstants_withOptionsStringConstants_none(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_withOptionsStringConstants_noneContext,0)


        def gremlinStringConstants_withOptionsStringConstants_ids(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_withOptionsStringConstants_idsContext,0)


        def gremlinStringConstants_withOptionsStringConstants_labels(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_withOptionsStringConstants_labelsContext,0)


        def gremlinStringConstants_withOptionsStringConstants_keys(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_withOptionsStringConstants_keysContext,0)


        def gremlinStringConstants_withOptionsStringConstants_values(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_withOptionsStringConstants_valuesContext,0)


        def gremlinStringConstants_withOptionsStringConstants_all(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_withOptionsStringConstants_allContext,0)


        def gremlinStringConstants_withOptionsStringConstants_indexer(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_withOptionsStringConstants_indexerContext,0)


        def gremlinStringConstants_withOptionsStringConstants_list(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_withOptionsStringConstants_listContext,0)


        def gremlinStringConstants_withOptionsStringConstants_map(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstants_withOptionsStringConstants_mapContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_withOptionsStringConstants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithOptionsStringConstants" ):
                listener.enterWithOptionsStringConstants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithOptionsStringConstants" ):
                listener.exitWithOptionsStringConstants(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWithOptionsStringConstants" ):
                return visitor.visitWithOptionsStringConstants(self)
            else:
                return visitor.visitChildren(self)




    def withOptionsStringConstants(self):

        localctx = GremlinParser.WithOptionsStringConstantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_withOptionsStringConstants)
        try:
            self.state = 2227
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2217
                self.gremlinStringConstants_withOptionsStringConstants_tokens()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2218
                self.gremlinStringConstants_withOptionsStringConstants_none()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2219
                self.gremlinStringConstants_withOptionsStringConstants_ids()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2220
                self.gremlinStringConstants_withOptionsStringConstants_labels()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2221
                self.gremlinStringConstants_withOptionsStringConstants_keys()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2222
                self.gremlinStringConstants_withOptionsStringConstants_values()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2223
                self.gremlinStringConstants_withOptionsStringConstants_all()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2224
                self.gremlinStringConstants_withOptionsStringConstants_indexer()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2225
                self.gremlinStringConstants_withOptionsStringConstants_list()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 2226
                self.gremlinStringConstants_withOptionsStringConstants_map()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_pageRankStringConstants_edgesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pageRankStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.PageRankStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_pageRankStringConstants_edges

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_pageRankStringConstants_edges" ):
                listener.enterGremlinStringConstants_pageRankStringConstants_edges(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_pageRankStringConstants_edges" ):
                listener.exitGremlinStringConstants_pageRankStringConstants_edges(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_pageRankStringConstants_edges" ):
                return visitor.visitGremlinStringConstants_pageRankStringConstants_edges(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_pageRankStringConstants_edges(self):

        localctx = GremlinParser.GremlinStringConstants_pageRankStringConstants_edgesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_gremlinStringConstants_pageRankStringConstants_edges)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2229
            self.pageRankStringConstant()
            self.state = 2230
            self.match(GremlinParser.DOT)
            self.state = 2231
            self.match(GremlinParser.T__123)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_pageRankStringConstants_timesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pageRankStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.PageRankStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_pageRankStringConstants_times

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_pageRankStringConstants_times" ):
                listener.enterGremlinStringConstants_pageRankStringConstants_times(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_pageRankStringConstants_times" ):
                listener.exitGremlinStringConstants_pageRankStringConstants_times(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_pageRankStringConstants_times" ):
                return visitor.visitGremlinStringConstants_pageRankStringConstants_times(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_pageRankStringConstants_times(self):

        localctx = GremlinParser.GremlinStringConstants_pageRankStringConstants_timesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_gremlinStringConstants_pageRankStringConstants_times)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2233
            self.pageRankStringConstant()
            self.state = 2234
            self.match(GremlinParser.DOT)
            self.state = 2235
            self.match(GremlinParser.T__99)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_pageRankStringConstants_propertyNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pageRankStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.PageRankStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_pageRankStringConstants_propertyName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_pageRankStringConstants_propertyName" ):
                listener.enterGremlinStringConstants_pageRankStringConstants_propertyName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_pageRankStringConstants_propertyName" ):
                listener.exitGremlinStringConstants_pageRankStringConstants_propertyName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_pageRankStringConstants_propertyName" ):
                return visitor.visitGremlinStringConstants_pageRankStringConstants_propertyName(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_pageRankStringConstants_propertyName(self):

        localctx = GremlinParser.GremlinStringConstants_pageRankStringConstants_propertyNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_gremlinStringConstants_pageRankStringConstants_propertyName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2237
            self.pageRankStringConstant()
            self.state = 2238
            self.match(GremlinParser.DOT)
            self.state = 2239
            self.match(GremlinParser.T__235)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_peerPressureStringConstants_edgesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def peerPressureStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.PeerPressureStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_peerPressureStringConstants_edges

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_peerPressureStringConstants_edges" ):
                listener.enterGremlinStringConstants_peerPressureStringConstants_edges(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_peerPressureStringConstants_edges" ):
                listener.exitGremlinStringConstants_peerPressureStringConstants_edges(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_peerPressureStringConstants_edges" ):
                return visitor.visitGremlinStringConstants_peerPressureStringConstants_edges(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_peerPressureStringConstants_edges(self):

        localctx = GremlinParser.GremlinStringConstants_peerPressureStringConstants_edgesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_gremlinStringConstants_peerPressureStringConstants_edges)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2241
            self.peerPressureStringConstant()
            self.state = 2242
            self.match(GremlinParser.DOT)
            self.state = 2243
            self.match(GremlinParser.T__123)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_peerPressureStringConstants_timesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def peerPressureStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.PeerPressureStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_peerPressureStringConstants_times

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_peerPressureStringConstants_times" ):
                listener.enterGremlinStringConstants_peerPressureStringConstants_times(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_peerPressureStringConstants_times" ):
                listener.exitGremlinStringConstants_peerPressureStringConstants_times(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_peerPressureStringConstants_times" ):
                return visitor.visitGremlinStringConstants_peerPressureStringConstants_times(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_peerPressureStringConstants_times(self):

        localctx = GremlinParser.GremlinStringConstants_peerPressureStringConstants_timesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_gremlinStringConstants_peerPressureStringConstants_times)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2245
            self.peerPressureStringConstant()
            self.state = 2246
            self.match(GremlinParser.DOT)
            self.state = 2247
            self.match(GremlinParser.T__99)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_peerPressureStringConstants_propertyNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def peerPressureStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.PeerPressureStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_peerPressureStringConstants_propertyName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_peerPressureStringConstants_propertyName" ):
                listener.enterGremlinStringConstants_peerPressureStringConstants_propertyName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_peerPressureStringConstants_propertyName" ):
                listener.exitGremlinStringConstants_peerPressureStringConstants_propertyName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_peerPressureStringConstants_propertyName" ):
                return visitor.visitGremlinStringConstants_peerPressureStringConstants_propertyName(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_peerPressureStringConstants_propertyName(self):

        localctx = GremlinParser.GremlinStringConstants_peerPressureStringConstants_propertyNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_gremlinStringConstants_peerPressureStringConstants_propertyName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2249
            self.peerPressureStringConstant()
            self.state = 2250
            self.match(GremlinParser.DOT)
            self.state = 2251
            self.match(GremlinParser.T__235)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_shortestPathStringConstants_targetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shortestPathStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.ShortestPathStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_shortestPathStringConstants_target

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_shortestPathStringConstants_target" ):
                listener.enterGremlinStringConstants_shortestPathStringConstants_target(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_shortestPathStringConstants_target" ):
                listener.exitGremlinStringConstants_shortestPathStringConstants_target(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_shortestPathStringConstants_target" ):
                return visitor.visitGremlinStringConstants_shortestPathStringConstants_target(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_shortestPathStringConstants_target(self):

        localctx = GremlinParser.GremlinStringConstants_shortestPathStringConstants_targetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_gremlinStringConstants_shortestPathStringConstants_target)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2253
            self.shortestPathStringConstant()
            self.state = 2254
            self.match(GremlinParser.DOT)
            self.state = 2255
            self.match(GremlinParser.T__236)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_shortestPathStringConstants_edgesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shortestPathStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.ShortestPathStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_shortestPathStringConstants_edges

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_shortestPathStringConstants_edges" ):
                listener.enterGremlinStringConstants_shortestPathStringConstants_edges(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_shortestPathStringConstants_edges" ):
                listener.exitGremlinStringConstants_shortestPathStringConstants_edges(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_shortestPathStringConstants_edges" ):
                return visitor.visitGremlinStringConstants_shortestPathStringConstants_edges(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_shortestPathStringConstants_edges(self):

        localctx = GremlinParser.GremlinStringConstants_shortestPathStringConstants_edgesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_gremlinStringConstants_shortestPathStringConstants_edges)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2257
            self.shortestPathStringConstant()
            self.state = 2258
            self.match(GremlinParser.DOT)
            self.state = 2259
            self.match(GremlinParser.T__123)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_shortestPathStringConstants_distanceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shortestPathStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.ShortestPathStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_shortestPathStringConstants_distance

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_shortestPathStringConstants_distance" ):
                listener.enterGremlinStringConstants_shortestPathStringConstants_distance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_shortestPathStringConstants_distance" ):
                listener.exitGremlinStringConstants_shortestPathStringConstants_distance(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_shortestPathStringConstants_distance" ):
                return visitor.visitGremlinStringConstants_shortestPathStringConstants_distance(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_shortestPathStringConstants_distance(self):

        localctx = GremlinParser.GremlinStringConstants_shortestPathStringConstants_distanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_gremlinStringConstants_shortestPathStringConstants_distance)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2261
            self.shortestPathStringConstant()
            self.state = 2262
            self.match(GremlinParser.DOT)
            self.state = 2263
            self.match(GremlinParser.T__237)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_shortestPathStringConstants_maxDistanceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shortestPathStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.ShortestPathStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_shortestPathStringConstants_maxDistance

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_shortestPathStringConstants_maxDistance" ):
                listener.enterGremlinStringConstants_shortestPathStringConstants_maxDistance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_shortestPathStringConstants_maxDistance" ):
                listener.exitGremlinStringConstants_shortestPathStringConstants_maxDistance(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_shortestPathStringConstants_maxDistance" ):
                return visitor.visitGremlinStringConstants_shortestPathStringConstants_maxDistance(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_shortestPathStringConstants_maxDistance(self):

        localctx = GremlinParser.GremlinStringConstants_shortestPathStringConstants_maxDistanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_gremlinStringConstants_shortestPathStringConstants_maxDistance)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2265
            self.shortestPathStringConstant()
            self.state = 2266
            self.match(GremlinParser.DOT)
            self.state = 2267
            self.match(GremlinParser.T__238)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_shortestPathStringConstants_includeEdgesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shortestPathStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.ShortestPathStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_shortestPathStringConstants_includeEdges

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_shortestPathStringConstants_includeEdges" ):
                listener.enterGremlinStringConstants_shortestPathStringConstants_includeEdges(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_shortestPathStringConstants_includeEdges" ):
                listener.exitGremlinStringConstants_shortestPathStringConstants_includeEdges(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_shortestPathStringConstants_includeEdges" ):
                return visitor.visitGremlinStringConstants_shortestPathStringConstants_includeEdges(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_shortestPathStringConstants_includeEdges(self):

        localctx = GremlinParser.GremlinStringConstants_shortestPathStringConstants_includeEdgesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_gremlinStringConstants_shortestPathStringConstants_includeEdges)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2269
            self.shortestPathStringConstant()
            self.state = 2270
            self.match(GremlinParser.DOT)
            self.state = 2271
            self.match(GremlinParser.T__239)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_withOptionsStringConstants_tokensContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withOptionsStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.WithOptionsStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_withOptionsStringConstants_tokens

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_withOptionsStringConstants_tokens" ):
                listener.enterGremlinStringConstants_withOptionsStringConstants_tokens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_withOptionsStringConstants_tokens" ):
                listener.exitGremlinStringConstants_withOptionsStringConstants_tokens(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_withOptionsStringConstants_tokens" ):
                return visitor.visitGremlinStringConstants_withOptionsStringConstants_tokens(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_withOptionsStringConstants_tokens(self):

        localctx = GremlinParser.GremlinStringConstants_withOptionsStringConstants_tokensContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_gremlinStringConstants_withOptionsStringConstants_tokens)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2273
            self.withOptionsStringConstant()
            self.state = 2274
            self.match(GremlinParser.DOT)
            self.state = 2275
            self.match(GremlinParser.T__240)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_withOptionsStringConstants_noneContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withOptionsStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.WithOptionsStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_withOptionsStringConstants_none

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_withOptionsStringConstants_none" ):
                listener.enterGremlinStringConstants_withOptionsStringConstants_none(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_withOptionsStringConstants_none" ):
                listener.exitGremlinStringConstants_withOptionsStringConstants_none(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_withOptionsStringConstants_none" ):
                return visitor.visitGremlinStringConstants_withOptionsStringConstants_none(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_withOptionsStringConstants_none(self):

        localctx = GremlinParser.GremlinStringConstants_withOptionsStringConstants_noneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_gremlinStringConstants_withOptionsStringConstants_none)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2277
            self.withOptionsStringConstant()
            self.state = 2278
            self.match(GremlinParser.DOT)
            self.state = 2279
            self.match(GremlinParser.T__187)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_withOptionsStringConstants_idsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withOptionsStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.WithOptionsStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_withOptionsStringConstants_ids

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_withOptionsStringConstants_ids" ):
                listener.enterGremlinStringConstants_withOptionsStringConstants_ids(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_withOptionsStringConstants_ids" ):
                listener.exitGremlinStringConstants_withOptionsStringConstants_ids(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_withOptionsStringConstants_ids" ):
                return visitor.visitGremlinStringConstants_withOptionsStringConstants_ids(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_withOptionsStringConstants_ids(self):

        localctx = GremlinParser.GremlinStringConstants_withOptionsStringConstants_idsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_gremlinStringConstants_withOptionsStringConstants_ids)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2281
            self.withOptionsStringConstant()
            self.state = 2282
            self.match(GremlinParser.DOT)
            self.state = 2283
            self.match(GremlinParser.T__241)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_withOptionsStringConstants_labelsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withOptionsStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.WithOptionsStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_withOptionsStringConstants_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_withOptionsStringConstants_labels" ):
                listener.enterGremlinStringConstants_withOptionsStringConstants_labels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_withOptionsStringConstants_labels" ):
                listener.exitGremlinStringConstants_withOptionsStringConstants_labels(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_withOptionsStringConstants_labels" ):
                return visitor.visitGremlinStringConstants_withOptionsStringConstants_labels(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_withOptionsStringConstants_labels(self):

        localctx = GremlinParser.GremlinStringConstants_withOptionsStringConstants_labelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_gremlinStringConstants_withOptionsStringConstants_labels)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2285
            self.withOptionsStringConstant()
            self.state = 2286
            self.match(GremlinParser.DOT)
            self.state = 2287
            self.match(GremlinParser.T__242)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_withOptionsStringConstants_keysContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withOptionsStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.WithOptionsStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_withOptionsStringConstants_keys

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_withOptionsStringConstants_keys" ):
                listener.enterGremlinStringConstants_withOptionsStringConstants_keys(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_withOptionsStringConstants_keys" ):
                listener.exitGremlinStringConstants_withOptionsStringConstants_keys(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_withOptionsStringConstants_keys" ):
                return visitor.visitGremlinStringConstants_withOptionsStringConstants_keys(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_withOptionsStringConstants_keys(self):

        localctx = GremlinParser.GremlinStringConstants_withOptionsStringConstants_keysContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_gremlinStringConstants_withOptionsStringConstants_keys)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2289
            self.withOptionsStringConstant()
            self.state = 2290
            self.match(GremlinParser.DOT)
            self.state = 2291
            self.match(GremlinParser.T__128)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_withOptionsStringConstants_valuesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withOptionsStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.WithOptionsStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_withOptionsStringConstants_values

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_withOptionsStringConstants_values" ):
                listener.enterGremlinStringConstants_withOptionsStringConstants_values(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_withOptionsStringConstants_values" ):
                listener.exitGremlinStringConstants_withOptionsStringConstants_values(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_withOptionsStringConstants_values" ):
                return visitor.visitGremlinStringConstants_withOptionsStringConstants_values(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_withOptionsStringConstants_values(self):

        localctx = GremlinParser.GremlinStringConstants_withOptionsStringConstants_valuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_gremlinStringConstants_withOptionsStringConstants_values)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2293
            self.withOptionsStringConstant()
            self.state = 2294
            self.match(GremlinParser.DOT)
            self.state = 2295
            self.match(GremlinParser.T__109)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_withOptionsStringConstants_allContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withOptionsStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.WithOptionsStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_withOptionsStringConstants_all

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_withOptionsStringConstants_all" ):
                listener.enterGremlinStringConstants_withOptionsStringConstants_all(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_withOptionsStringConstants_all" ):
                listener.exitGremlinStringConstants_withOptionsStringConstants_all(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_withOptionsStringConstants_all" ):
                return visitor.visitGremlinStringConstants_withOptionsStringConstants_all(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_withOptionsStringConstants_all(self):

        localctx = GremlinParser.GremlinStringConstants_withOptionsStringConstants_allContext(self, self._ctx, self.state)
        self.enterRule(localctx, 392, self.RULE_gremlinStringConstants_withOptionsStringConstants_all)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2297
            self.withOptionsStringConstant()
            self.state = 2298
            self.match(GremlinParser.DOT)
            self.state = 2299
            self.match(GremlinParser.T__164)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_withOptionsStringConstants_indexerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withOptionsStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.WithOptionsStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_withOptionsStringConstants_indexer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_withOptionsStringConstants_indexer" ):
                listener.enterGremlinStringConstants_withOptionsStringConstants_indexer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_withOptionsStringConstants_indexer" ):
                listener.exitGremlinStringConstants_withOptionsStringConstants_indexer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_withOptionsStringConstants_indexer" ):
                return visitor.visitGremlinStringConstants_withOptionsStringConstants_indexer(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_withOptionsStringConstants_indexer(self):

        localctx = GremlinParser.GremlinStringConstants_withOptionsStringConstants_indexerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_gremlinStringConstants_withOptionsStringConstants_indexer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2301
            self.withOptionsStringConstant()
            self.state = 2302
            self.match(GremlinParser.DOT)
            self.state = 2303
            self.match(GremlinParser.T__243)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_withOptionsStringConstants_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withOptionsStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.WithOptionsStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_withOptionsStringConstants_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_withOptionsStringConstants_list" ):
                listener.enterGremlinStringConstants_withOptionsStringConstants_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_withOptionsStringConstants_list" ):
                listener.exitGremlinStringConstants_withOptionsStringConstants_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_withOptionsStringConstants_list" ):
                return visitor.visitGremlinStringConstants_withOptionsStringConstants_list(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_withOptionsStringConstants_list(self):

        localctx = GremlinParser.GremlinStringConstants_withOptionsStringConstants_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_gremlinStringConstants_withOptionsStringConstants_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2305
            self.withOptionsStringConstant()
            self.state = 2306
            self.match(GremlinParser.DOT)
            self.state = 2307
            self.match(GremlinParser.T__156)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GremlinStringConstants_withOptionsStringConstants_mapContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withOptionsStringConstant(self):
            return self.getTypedRuleContext(GremlinParser.WithOptionsStringConstantContext,0)


        def DOT(self):
            return self.getToken(GremlinParser.DOT, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_gremlinStringConstants_withOptionsStringConstants_map

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGremlinStringConstants_withOptionsStringConstants_map" ):
                listener.enterGremlinStringConstants_withOptionsStringConstants_map(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGremlinStringConstants_withOptionsStringConstants_map" ):
                listener.exitGremlinStringConstants_withOptionsStringConstants_map(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGremlinStringConstants_withOptionsStringConstants_map" ):
                return visitor.visitGremlinStringConstants_withOptionsStringConstants_map(self)
            else:
                return visitor.visitChildren(self)




    def gremlinStringConstants_withOptionsStringConstants_map(self):

        localctx = GremlinParser.GremlinStringConstants_withOptionsStringConstants_mapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_gremlinStringConstants_withOptionsStringConstants_map)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2309
            self.withOptionsStringConstant()
            self.state = 2310
            self.match(GremlinParser.DOT)
            self.state = 2311
            self.match(GremlinParser.T__61)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PageRankStringConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_pageRankStringConstant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPageRankStringConstant" ):
                listener.enterPageRankStringConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPageRankStringConstant" ):
                listener.exitPageRankStringConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPageRankStringConstant" ):
                return visitor.visitPageRankStringConstant(self)
            else:
                return visitor.visitChildren(self)




    def pageRankStringConstant(self):

        localctx = GremlinParser.PageRankStringConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_pageRankStringConstant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2313
            self.match(GremlinParser.T__244)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeerPressureStringConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_peerPressureStringConstant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeerPressureStringConstant" ):
                listener.enterPeerPressureStringConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeerPressureStringConstant" ):
                listener.exitPeerPressureStringConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeerPressureStringConstant" ):
                return visitor.visitPeerPressureStringConstant(self)
            else:
                return visitor.visitChildren(self)




    def peerPressureStringConstant(self):

        localctx = GremlinParser.PeerPressureStringConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 402, self.RULE_peerPressureStringConstant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2315
            self.match(GremlinParser.T__245)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShortestPathStringConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_shortestPathStringConstant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShortestPathStringConstant" ):
                listener.enterShortestPathStringConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShortestPathStringConstant" ):
                listener.exitShortestPathStringConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShortestPathStringConstant" ):
                return visitor.visitShortestPathStringConstant(self)
            else:
                return visitor.visitChildren(self)




    def shortestPathStringConstant(self):

        localctx = GremlinParser.ShortestPathStringConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 404, self.RULE_shortestPathStringConstant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2317
            self.match(GremlinParser.T__246)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithOptionsStringConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GremlinParser.RULE_withOptionsStringConstant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithOptionsStringConstant" ):
                listener.enterWithOptionsStringConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithOptionsStringConstant" ):
                listener.exitWithOptionsStringConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWithOptionsStringConstant" ):
                return visitor.visitWithOptionsStringConstant(self)
            else:
                return visitor.visitChildren(self)




    def withOptionsStringConstant(self):

        localctx = GremlinParser.WithOptionsStringConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 406, self.RULE_withOptionsStringConstant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2319
            self.match(GremlinParser.T__247)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalStrategyListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalStrategyExpr(self):
            return self.getTypedRuleContext(GremlinParser.TraversalStrategyExprContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_traversalStrategyList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalStrategyList" ):
                listener.enterTraversalStrategyList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalStrategyList" ):
                listener.exitTraversalStrategyList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalStrategyList" ):
                return visitor.visitTraversalStrategyList(self)
            else:
                return visitor.visitChildren(self)




    def traversalStrategyList(self):

        localctx = GremlinParser.TraversalStrategyListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 408, self.RULE_traversalStrategyList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2322
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GremlinParser.T__116 or _la==GremlinParser.NEW:
                self.state = 2321
                self.traversalStrategyExpr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraversalStrategyExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traversalStrategy(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.TraversalStrategyContext)
            else:
                return self.getTypedRuleContext(GremlinParser.TraversalStrategyContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)

        def getRuleIndex(self):
            return GremlinParser.RULE_traversalStrategyExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraversalStrategyExpr" ):
                listener.enterTraversalStrategyExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraversalStrategyExpr" ):
                listener.exitTraversalStrategyExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraversalStrategyExpr" ):
                return visitor.visitTraversalStrategyExpr(self)
            else:
                return visitor.visitChildren(self)




    def traversalStrategyExpr(self):

        localctx = GremlinParser.TraversalStrategyExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 410, self.RULE_traversalStrategyExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2324
            self.traversalStrategy()
            self.state = 2329
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GremlinParser.COMMA:
                self.state = 2325
                self.match(GremlinParser.COMMA)
                self.state = 2326
                self.traversalStrategy()
                self.state = 2331
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedTraversalListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedTraversalExpr(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalExprContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_nestedTraversalList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedTraversalList" ):
                listener.enterNestedTraversalList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedTraversalList" ):
                listener.exitNestedTraversalList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNestedTraversalList" ):
                return visitor.visitNestedTraversalList(self)
            else:
                return visitor.visitChildren(self)




    def nestedTraversalList(self):

        localctx = GremlinParser.NestedTraversalListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 412, self.RULE_nestedTraversalList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2333
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GremlinParser.T__9) | (1 << GremlinParser.T__10) | (1 << GremlinParser.T__11) | (1 << GremlinParser.T__13) | (1 << GremlinParser.T__14) | (1 << GremlinParser.T__16) | (1 << GremlinParser.T__17) | (1 << GremlinParser.T__18) | (1 << GremlinParser.T__19) | (1 << GremlinParser.T__20) | (1 << GremlinParser.T__21) | (1 << GremlinParser.T__22) | (1 << GremlinParser.T__23) | (1 << GremlinParser.T__24) | (1 << GremlinParser.T__25) | (1 << GremlinParser.T__26) | (1 << GremlinParser.T__27) | (1 << GremlinParser.T__28) | (1 << GremlinParser.T__29) | (1 << GremlinParser.T__30) | (1 << GremlinParser.T__31) | (1 << GremlinParser.T__32) | (1 << GremlinParser.T__33) | (1 << GremlinParser.T__34) | (1 << GremlinParser.T__35) | (1 << GremlinParser.T__36) | (1 << GremlinParser.T__37) | (1 << GremlinParser.T__38) | (1 << GremlinParser.T__39) | (1 << GremlinParser.T__40) | (1 << GremlinParser.T__41) | (1 << GremlinParser.T__42) | (1 << GremlinParser.T__43) | (1 << GremlinParser.T__44) | (1 << GremlinParser.T__45) | (1 << GremlinParser.T__46) | (1 << GremlinParser.T__47) | (1 << GremlinParser.T__48) | (1 << GremlinParser.T__49) | (1 << GremlinParser.T__50) | (1 << GremlinParser.T__51) | (1 << GremlinParser.T__52) | (1 << GremlinParser.T__53) | (1 << GremlinParser.T__54) | (1 << GremlinParser.T__55) | (1 << GremlinParser.T__56) | (1 << GremlinParser.T__57) | (1 << GremlinParser.T__58) | (1 << GremlinParser.T__59) | (1 << GremlinParser.T__60) | (1 << GremlinParser.T__61) | (1 << GremlinParser.T__62))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (GremlinParser.T__63 - 64)) | (1 << (GremlinParser.T__64 - 64)) | (1 << (GremlinParser.T__65 - 64)) | (1 << (GremlinParser.T__66 - 64)) | (1 << (GremlinParser.T__67 - 64)) | (1 << (GremlinParser.T__68 - 64)) | (1 << (GremlinParser.T__69 - 64)) | (1 << (GremlinParser.T__70 - 64)) | (1 << (GremlinParser.T__71 - 64)) | (1 << (GremlinParser.T__72 - 64)) | (1 << (GremlinParser.T__73 - 64)) | (1 << (GremlinParser.T__74 - 64)) | (1 << (GremlinParser.T__75 - 64)) | (1 << (GremlinParser.T__76 - 64)) | (1 << (GremlinParser.T__77 - 64)) | (1 << (GremlinParser.T__78 - 64)) | (1 << (GremlinParser.T__79 - 64)) | (1 << (GremlinParser.T__80 - 64)) | (1 << (GremlinParser.T__81 - 64)) | (1 << (GremlinParser.T__82 - 64)) | (1 << (GremlinParser.T__83 - 64)) | (1 << (GremlinParser.T__84 - 64)) | (1 << (GremlinParser.T__85 - 64)) | (1 << (GremlinParser.T__86 - 64)) | (1 << (GremlinParser.T__87 - 64)) | (1 << (GremlinParser.T__88 - 64)) | (1 << (GremlinParser.T__89 - 64)) | (1 << (GremlinParser.T__90 - 64)) | (1 << (GremlinParser.T__91 - 64)) | (1 << (GremlinParser.T__92 - 64)) | (1 << (GremlinParser.T__93 - 64)) | (1 << (GremlinParser.T__94 - 64)) | (1 << (GremlinParser.T__95 - 64)) | (1 << (GremlinParser.T__96 - 64)) | (1 << (GremlinParser.T__97 - 64)) | (1 << (GremlinParser.T__98 - 64)) | (1 << (GremlinParser.T__99 - 64)) | (1 << (GremlinParser.T__100 - 64)) | (1 << (GremlinParser.T__101 - 64)) | (1 << (GremlinParser.T__102 - 64)) | (1 << (GremlinParser.T__103 - 64)) | (1 << (GremlinParser.T__104 - 64)) | (1 << (GremlinParser.T__105 - 64)) | (1 << (GremlinParser.T__106 - 64)) | (1 << (GremlinParser.T__107 - 64)) | (1 << (GremlinParser.T__108 - 64)) | (1 << (GremlinParser.T__109 - 64)) | (1 << (GremlinParser.T__110 - 64)) | (1 << (GremlinParser.T__111 - 64)))) != 0) or _la==GremlinParser.TRAVERSAL_ROOT or _la==GremlinParser.ANON_TRAVERSAL_ROOT:
                self.state = 2332
                self.nestedTraversalExpr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedTraversalExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nestedTraversal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.NestedTraversalContext)
            else:
                return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)

        def getRuleIndex(self):
            return GremlinParser.RULE_nestedTraversalExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedTraversalExpr" ):
                listener.enterNestedTraversalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedTraversalExpr" ):
                listener.exitNestedTraversalExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNestedTraversalExpr" ):
                return visitor.visitNestedTraversalExpr(self)
            else:
                return visitor.visitChildren(self)




    def nestedTraversalExpr(self):

        localctx = GremlinParser.NestedTraversalExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 414, self.RULE_nestedTraversalExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2335
            self.nestedTraversal()
            self.state = 2340
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GremlinParser.COMMA:
                self.state = 2336
                self.match(GremlinParser.COMMA)
                self.state = 2337
                self.nestedTraversal()
                self.state = 2342
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericLiteralListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def genericLiteralExpr(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralExprContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_genericLiteralList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericLiteralList" ):
                listener.enterGenericLiteralList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericLiteralList" ):
                listener.exitGenericLiteralList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericLiteralList" ):
                return visitor.visitGenericLiteralList(self)
            else:
                return visitor.visitChildren(self)




    def genericLiteralList(self):

        localctx = GremlinParser.GenericLiteralListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 416, self.RULE_genericLiteralList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2344
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GremlinParser.T__9) | (1 << GremlinParser.T__10) | (1 << GremlinParser.T__11) | (1 << GremlinParser.T__13) | (1 << GremlinParser.T__14) | (1 << GremlinParser.T__16) | (1 << GremlinParser.T__17) | (1 << GremlinParser.T__18) | (1 << GremlinParser.T__19) | (1 << GremlinParser.T__20) | (1 << GremlinParser.T__21) | (1 << GremlinParser.T__22) | (1 << GremlinParser.T__23) | (1 << GremlinParser.T__24) | (1 << GremlinParser.T__25) | (1 << GremlinParser.T__26) | (1 << GremlinParser.T__27) | (1 << GremlinParser.T__28) | (1 << GremlinParser.T__29) | (1 << GremlinParser.T__30) | (1 << GremlinParser.T__31) | (1 << GremlinParser.T__32) | (1 << GremlinParser.T__33) | (1 << GremlinParser.T__34) | (1 << GremlinParser.T__35) | (1 << GremlinParser.T__36) | (1 << GremlinParser.T__37) | (1 << GremlinParser.T__38) | (1 << GremlinParser.T__39) | (1 << GremlinParser.T__40) | (1 << GremlinParser.T__41) | (1 << GremlinParser.T__42) | (1 << GremlinParser.T__43) | (1 << GremlinParser.T__44) | (1 << GremlinParser.T__45) | (1 << GremlinParser.T__46) | (1 << GremlinParser.T__47) | (1 << GremlinParser.T__48) | (1 << GremlinParser.T__49) | (1 << GremlinParser.T__50) | (1 << GremlinParser.T__51) | (1 << GremlinParser.T__52) | (1 << GremlinParser.T__53) | (1 << GremlinParser.T__54) | (1 << GremlinParser.T__55) | (1 << GremlinParser.T__56) | (1 << GremlinParser.T__57) | (1 << GremlinParser.T__58) | (1 << GremlinParser.T__59) | (1 << GremlinParser.T__60) | (1 << GremlinParser.T__61) | (1 << GremlinParser.T__62))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (GremlinParser.T__63 - 64)) | (1 << (GremlinParser.T__64 - 64)) | (1 << (GremlinParser.T__65 - 64)) | (1 << (GremlinParser.T__66 - 64)) | (1 << (GremlinParser.T__67 - 64)) | (1 << (GremlinParser.T__68 - 64)) | (1 << (GremlinParser.T__69 - 64)) | (1 << (GremlinParser.T__70 - 64)) | (1 << (GremlinParser.T__71 - 64)) | (1 << (GremlinParser.T__72 - 64)) | (1 << (GremlinParser.T__73 - 64)) | (1 << (GremlinParser.T__74 - 64)) | (1 << (GremlinParser.T__75 - 64)) | (1 << (GremlinParser.T__76 - 64)) | (1 << (GremlinParser.T__77 - 64)) | (1 << (GremlinParser.T__78 - 64)) | (1 << (GremlinParser.T__79 - 64)) | (1 << (GremlinParser.T__80 - 64)) | (1 << (GremlinParser.T__81 - 64)) | (1 << (GremlinParser.T__82 - 64)) | (1 << (GremlinParser.T__83 - 64)) | (1 << (GremlinParser.T__84 - 64)) | (1 << (GremlinParser.T__85 - 64)) | (1 << (GremlinParser.T__86 - 64)) | (1 << (GremlinParser.T__87 - 64)) | (1 << (GremlinParser.T__88 - 64)) | (1 << (GremlinParser.T__89 - 64)) | (1 << (GremlinParser.T__90 - 64)) | (1 << (GremlinParser.T__91 - 64)) | (1 << (GremlinParser.T__92 - 64)) | (1 << (GremlinParser.T__93 - 64)) | (1 << (GremlinParser.T__94 - 64)) | (1 << (GremlinParser.T__95 - 64)) | (1 << (GremlinParser.T__96 - 64)) | (1 << (GremlinParser.T__97 - 64)) | (1 << (GremlinParser.T__98 - 64)) | (1 << (GremlinParser.T__99 - 64)) | (1 << (GremlinParser.T__100 - 64)) | (1 << (GremlinParser.T__101 - 64)) | (1 << (GremlinParser.T__102 - 64)) | (1 << (GremlinParser.T__103 - 64)) | (1 << (GremlinParser.T__104 - 64)) | (1 << (GremlinParser.T__105 - 64)) | (1 << (GremlinParser.T__106 - 64)) | (1 << (GremlinParser.T__107 - 64)) | (1 << (GremlinParser.T__108 - 64)) | (1 << (GremlinParser.T__109 - 64)) | (1 << (GremlinParser.T__110 - 64)) | (1 << (GremlinParser.T__111 - 64)))) != 0) or ((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & ((1 << (GremlinParser.T__132 - 133)) | (1 << (GremlinParser.T__133 - 133)) | (1 << (GremlinParser.T__134 - 133)) | (1 << (GremlinParser.T__135 - 133)) | (1 << (GremlinParser.T__146 - 133)) | (1 << (GremlinParser.T__147 - 133)) | (1 << (GremlinParser.T__148 - 133)) | (1 << (GremlinParser.T__149 - 133)) | (1 << (GremlinParser.T__150 - 133)) | (1 << (GremlinParser.T__151 - 133)) | (1 << (GremlinParser.T__152 - 133)) | (1 << (GremlinParser.T__153 - 133)) | (1 << (GremlinParser.T__154 - 133)) | (1 << (GremlinParser.T__155 - 133)) | (1 << (GremlinParser.T__156 - 133)) | (1 << (GremlinParser.T__157 - 133)) | (1 << (GremlinParser.T__185 - 133)) | (1 << (GremlinParser.T__186 - 133)) | (1 << (GremlinParser.T__187 - 133)) | (1 << (GremlinParser.T__188 - 133)))) != 0) or ((((_la - 245)) & ~0x3f) == 0 and ((1 << (_la - 245)) & ((1 << (GremlinParser.T__244 - 245)) | (1 << (GremlinParser.T__245 - 245)) | (1 << (GremlinParser.T__246 - 245)) | (1 << (GremlinParser.T__247 - 245)) | (1 << (GremlinParser.T__248 - 245)) | (1 << (GremlinParser.IntegerLiteral - 245)) | (1 << (GremlinParser.FloatingPointLiteral - 245)) | (1 << (GremlinParser.BooleanLiteral - 245)) | (1 << (GremlinParser.NullLiteral - 245)) | (1 << (GremlinParser.NonEmptyStringLiteral - 245)) | (1 << (GremlinParser.EmptyStringLiteral - 245)) | (1 << (GremlinParser.LBRACK - 245)) | (1 << (GremlinParser.TRAVERSAL_ROOT - 245)) | (1 << (GremlinParser.ANON_TRAVERSAL_ROOT - 245)))) != 0):
                self.state = 2343
                self.genericLiteralExpr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericLiteralExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def genericLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.GenericLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)

        def getRuleIndex(self):
            return GremlinParser.RULE_genericLiteralExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericLiteralExpr" ):
                listener.enterGenericLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericLiteralExpr" ):
                listener.exitGenericLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericLiteralExpr" ):
                return visitor.visitGenericLiteralExpr(self)
            else:
                return visitor.visitChildren(self)




    def genericLiteralExpr(self):

        localctx = GremlinParser.GenericLiteralExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 418, self.RULE_genericLiteralExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2346
            self.genericLiteral()
            self.state = 2351
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GremlinParser.COMMA:
                self.state = 2347
                self.match(GremlinParser.COMMA)
                self.state = 2348
                self.genericLiteral()
                self.state = 2353
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericLiteralRangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integerLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.IntegerLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.DOT)
            else:
                return self.getToken(GremlinParser.DOT, i)

        def stringLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.StringLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.StringLiteralContext,i)


        def getRuleIndex(self):
            return GremlinParser.RULE_genericLiteralRange

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericLiteralRange" ):
                listener.enterGenericLiteralRange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericLiteralRange" ):
                listener.exitGenericLiteralRange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericLiteralRange" ):
                return visitor.visitGenericLiteralRange(self)
            else:
                return visitor.visitChildren(self)




    def genericLiteralRange(self):

        localctx = GremlinParser.GenericLiteralRangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 420, self.RULE_genericLiteralRange)
        try:
            self.state = 2364
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.IntegerLiteral]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2354
                self.integerLiteral()
                self.state = 2355
                self.match(GremlinParser.DOT)
                self.state = 2356
                self.match(GremlinParser.DOT)
                self.state = 2357
                self.integerLiteral()
                pass
            elif token in [GremlinParser.T__244, GremlinParser.T__245, GremlinParser.T__246, GremlinParser.T__247, GremlinParser.NonEmptyStringLiteral, GremlinParser.EmptyStringLiteral]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2359
                self.stringLiteral()
                self.state = 2360
                self.match(GremlinParser.DOT)
                self.state = 2361
                self.match(GremlinParser.DOT)
                self.state = 2362
                self.stringLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericLiteralCollectionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self):
            return self.getToken(GremlinParser.LBRACK, 0)

        def RBRACK(self):
            return self.getToken(GremlinParser.RBRACK, 0)

        def genericLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.GenericLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)

        def getRuleIndex(self):
            return GremlinParser.RULE_genericLiteralCollection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericLiteralCollection" ):
                listener.enterGenericLiteralCollection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericLiteralCollection" ):
                listener.exitGenericLiteralCollection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericLiteralCollection" ):
                return visitor.visitGenericLiteralCollection(self)
            else:
                return visitor.visitChildren(self)




    def genericLiteralCollection(self):

        localctx = GremlinParser.GenericLiteralCollectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 422, self.RULE_genericLiteralCollection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2366
            self.match(GremlinParser.LBRACK)
            self.state = 2375
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GremlinParser.T__9) | (1 << GremlinParser.T__10) | (1 << GremlinParser.T__11) | (1 << GremlinParser.T__13) | (1 << GremlinParser.T__14) | (1 << GremlinParser.T__16) | (1 << GremlinParser.T__17) | (1 << GremlinParser.T__18) | (1 << GremlinParser.T__19) | (1 << GremlinParser.T__20) | (1 << GremlinParser.T__21) | (1 << GremlinParser.T__22) | (1 << GremlinParser.T__23) | (1 << GremlinParser.T__24) | (1 << GremlinParser.T__25) | (1 << GremlinParser.T__26) | (1 << GremlinParser.T__27) | (1 << GremlinParser.T__28) | (1 << GremlinParser.T__29) | (1 << GremlinParser.T__30) | (1 << GremlinParser.T__31) | (1 << GremlinParser.T__32) | (1 << GremlinParser.T__33) | (1 << GremlinParser.T__34) | (1 << GremlinParser.T__35) | (1 << GremlinParser.T__36) | (1 << GremlinParser.T__37) | (1 << GremlinParser.T__38) | (1 << GremlinParser.T__39) | (1 << GremlinParser.T__40) | (1 << GremlinParser.T__41) | (1 << GremlinParser.T__42) | (1 << GremlinParser.T__43) | (1 << GremlinParser.T__44) | (1 << GremlinParser.T__45) | (1 << GremlinParser.T__46) | (1 << GremlinParser.T__47) | (1 << GremlinParser.T__48) | (1 << GremlinParser.T__49) | (1 << GremlinParser.T__50) | (1 << GremlinParser.T__51) | (1 << GremlinParser.T__52) | (1 << GremlinParser.T__53) | (1 << GremlinParser.T__54) | (1 << GremlinParser.T__55) | (1 << GremlinParser.T__56) | (1 << GremlinParser.T__57) | (1 << GremlinParser.T__58) | (1 << GremlinParser.T__59) | (1 << GremlinParser.T__60) | (1 << GremlinParser.T__61) | (1 << GremlinParser.T__62))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (GremlinParser.T__63 - 64)) | (1 << (GremlinParser.T__64 - 64)) | (1 << (GremlinParser.T__65 - 64)) | (1 << (GremlinParser.T__66 - 64)) | (1 << (GremlinParser.T__67 - 64)) | (1 << (GremlinParser.T__68 - 64)) | (1 << (GremlinParser.T__69 - 64)) | (1 << (GremlinParser.T__70 - 64)) | (1 << (GremlinParser.T__71 - 64)) | (1 << (GremlinParser.T__72 - 64)) | (1 << (GremlinParser.T__73 - 64)) | (1 << (GremlinParser.T__74 - 64)) | (1 << (GremlinParser.T__75 - 64)) | (1 << (GremlinParser.T__76 - 64)) | (1 << (GremlinParser.T__77 - 64)) | (1 << (GremlinParser.T__78 - 64)) | (1 << (GremlinParser.T__79 - 64)) | (1 << (GremlinParser.T__80 - 64)) | (1 << (GremlinParser.T__81 - 64)) | (1 << (GremlinParser.T__82 - 64)) | (1 << (GremlinParser.T__83 - 64)) | (1 << (GremlinParser.T__84 - 64)) | (1 << (GremlinParser.T__85 - 64)) | (1 << (GremlinParser.T__86 - 64)) | (1 << (GremlinParser.T__87 - 64)) | (1 << (GremlinParser.T__88 - 64)) | (1 << (GremlinParser.T__89 - 64)) | (1 << (GremlinParser.T__90 - 64)) | (1 << (GremlinParser.T__91 - 64)) | (1 << (GremlinParser.T__92 - 64)) | (1 << (GremlinParser.T__93 - 64)) | (1 << (GremlinParser.T__94 - 64)) | (1 << (GremlinParser.T__95 - 64)) | (1 << (GremlinParser.T__96 - 64)) | (1 << (GremlinParser.T__97 - 64)) | (1 << (GremlinParser.T__98 - 64)) | (1 << (GremlinParser.T__99 - 64)) | (1 << (GremlinParser.T__100 - 64)) | (1 << (GremlinParser.T__101 - 64)) | (1 << (GremlinParser.T__102 - 64)) | (1 << (GremlinParser.T__103 - 64)) | (1 << (GremlinParser.T__104 - 64)) | (1 << (GremlinParser.T__105 - 64)) | (1 << (GremlinParser.T__106 - 64)) | (1 << (GremlinParser.T__107 - 64)) | (1 << (GremlinParser.T__108 - 64)) | (1 << (GremlinParser.T__109 - 64)) | (1 << (GremlinParser.T__110 - 64)) | (1 << (GremlinParser.T__111 - 64)))) != 0) or ((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & ((1 << (GremlinParser.T__132 - 133)) | (1 << (GremlinParser.T__133 - 133)) | (1 << (GremlinParser.T__134 - 133)) | (1 << (GremlinParser.T__135 - 133)) | (1 << (GremlinParser.T__146 - 133)) | (1 << (GremlinParser.T__147 - 133)) | (1 << (GremlinParser.T__148 - 133)) | (1 << (GremlinParser.T__149 - 133)) | (1 << (GremlinParser.T__150 - 133)) | (1 << (GremlinParser.T__151 - 133)) | (1 << (GremlinParser.T__152 - 133)) | (1 << (GremlinParser.T__153 - 133)) | (1 << (GremlinParser.T__154 - 133)) | (1 << (GremlinParser.T__155 - 133)) | (1 << (GremlinParser.T__156 - 133)) | (1 << (GremlinParser.T__157 - 133)) | (1 << (GremlinParser.T__185 - 133)) | (1 << (GremlinParser.T__186 - 133)) | (1 << (GremlinParser.T__187 - 133)) | (1 << (GremlinParser.T__188 - 133)))) != 0) or ((((_la - 245)) & ~0x3f) == 0 and ((1 << (_la - 245)) & ((1 << (GremlinParser.T__244 - 245)) | (1 << (GremlinParser.T__245 - 245)) | (1 << (GremlinParser.T__246 - 245)) | (1 << (GremlinParser.T__247 - 245)) | (1 << (GremlinParser.T__248 - 245)) | (1 << (GremlinParser.IntegerLiteral - 245)) | (1 << (GremlinParser.FloatingPointLiteral - 245)) | (1 << (GremlinParser.BooleanLiteral - 245)) | (1 << (GremlinParser.NullLiteral - 245)) | (1 << (GremlinParser.NonEmptyStringLiteral - 245)) | (1 << (GremlinParser.EmptyStringLiteral - 245)) | (1 << (GremlinParser.LBRACK - 245)) | (1 << (GremlinParser.TRAVERSAL_ROOT - 245)) | (1 << (GremlinParser.ANON_TRAVERSAL_ROOT - 245)))) != 0):
                self.state = 2367
                self.genericLiteral()
                self.state = 2372
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GremlinParser.COMMA:
                    self.state = 2368
                    self.match(GremlinParser.COMMA)
                    self.state = 2369
                    self.genericLiteral()
                    self.state = 2374
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 2377
            self.match(GremlinParser.RBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringLiteralListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringLiteralExpr(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralExprContext,0)


        def LBRACK(self):
            return self.getToken(GremlinParser.LBRACK, 0)

        def RBRACK(self):
            return self.getToken(GremlinParser.RBRACK, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_stringLiteralList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteralList" ):
                listener.enterStringLiteralList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteralList" ):
                listener.exitStringLiteralList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteralList" ):
                return visitor.visitStringLiteralList(self)
            else:
                return visitor.visitChildren(self)




    def stringLiteralList(self):

        localctx = GremlinParser.StringLiteralListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 424, self.RULE_stringLiteralList)
        self._la = 0 # Token type
        try:
            self.state = 2387
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.T__244, GremlinParser.T__245, GremlinParser.T__246, GremlinParser.T__247, GremlinParser.NonEmptyStringLiteral, GremlinParser.EmptyStringLiteral, GremlinParser.RPAREN, GremlinParser.COMMA]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2380
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 245)) & ~0x3f) == 0 and ((1 << (_la - 245)) & ((1 << (GremlinParser.T__244 - 245)) | (1 << (GremlinParser.T__245 - 245)) | (1 << (GremlinParser.T__246 - 245)) | (1 << (GremlinParser.T__247 - 245)) | (1 << (GremlinParser.NonEmptyStringLiteral - 245)) | (1 << (GremlinParser.EmptyStringLiteral - 245)))) != 0):
                    self.state = 2379
                    self.stringLiteralExpr()


                pass
            elif token in [GremlinParser.LBRACK]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2382
                self.match(GremlinParser.LBRACK)
                self.state = 2384
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 245)) & ~0x3f) == 0 and ((1 << (_la - 245)) & ((1 << (GremlinParser.T__244 - 245)) | (1 << (GremlinParser.T__245 - 245)) | (1 << (GremlinParser.T__246 - 245)) | (1 << (GremlinParser.T__247 - 245)) | (1 << (GremlinParser.NonEmptyStringLiteral - 245)) | (1 << (GremlinParser.EmptyStringLiteral - 245)))) != 0):
                    self.state = 2383
                    self.stringLiteralExpr()


                self.state = 2386
                self.match(GremlinParser.RBRACK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringLiteralExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.StringLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.StringLiteralContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)

        def getRuleIndex(self):
            return GremlinParser.RULE_stringLiteralExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteralExpr" ):
                listener.enterStringLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteralExpr" ):
                listener.exitStringLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteralExpr" ):
                return visitor.visitStringLiteralExpr(self)
            else:
                return visitor.visitChildren(self)




    def stringLiteralExpr(self):

        localctx = GremlinParser.StringLiteralExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 426, self.RULE_stringLiteralExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2389
            self.stringLiteral()
            self.state = 2394
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,116,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2390
                    self.match(GremlinParser.COMMA)
                    self.state = 2391
                    self.stringLiteral() 
                self.state = 2396
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,116,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integerLiteral(self):
            return self.getTypedRuleContext(GremlinParser.IntegerLiteralContext,0)


        def floatLiteral(self):
            return self.getTypedRuleContext(GremlinParser.FloatLiteralContext,0)


        def booleanLiteral(self):
            return self.getTypedRuleContext(GremlinParser.BooleanLiteralContext,0)


        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def dateLiteral(self):
            return self.getTypedRuleContext(GremlinParser.DateLiteralContext,0)


        def nullLiteral(self):
            return self.getTypedRuleContext(GremlinParser.NullLiteralContext,0)


        def traversalToken(self):
            return self.getTypedRuleContext(GremlinParser.TraversalTokenContext,0)


        def traversalCardinality(self):
            return self.getTypedRuleContext(GremlinParser.TraversalCardinalityContext,0)


        def traversalDirection(self):
            return self.getTypedRuleContext(GremlinParser.TraversalDirectionContext,0)


        def traversalOptionParent(self):
            return self.getTypedRuleContext(GremlinParser.TraversalOptionParentContext,0)


        def genericLiteralCollection(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralCollectionContext,0)


        def genericLiteralRange(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralRangeContext,0)


        def nestedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.NestedTraversalContext,0)


        def terminatedTraversal(self):
            return self.getTypedRuleContext(GremlinParser.TerminatedTraversalContext,0)


        def genericLiteralMap(self):
            return self.getTypedRuleContext(GremlinParser.GenericLiteralMapContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_genericLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericLiteral" ):
                listener.enterGenericLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericLiteral" ):
                listener.exitGenericLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericLiteral" ):
                return visitor.visitGenericLiteral(self)
            else:
                return visitor.visitChildren(self)




    def genericLiteral(self):

        localctx = GremlinParser.GenericLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 428, self.RULE_genericLiteral)
        try:
            self.state = 2412
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,117,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2397
                self.integerLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2398
                self.floatLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2399
                self.booleanLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2400
                self.stringLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2401
                self.dateLiteral()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2402
                self.nullLiteral()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2403
                self.traversalToken()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2404
                self.traversalCardinality()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2405
                self.traversalDirection()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 2406
                self.traversalOptionParent()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 2407
                self.genericLiteralCollection()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 2408
                self.genericLiteralRange()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 2409
                self.nestedTraversal()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 2410
                self.terminatedTraversal()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 2411
                self.genericLiteralMap()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericLiteralMapContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self):
            return self.getToken(GremlinParser.LBRACK, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COLON)
            else:
                return self.getToken(GremlinParser.COLON, i)

        def RBRACK(self):
            return self.getToken(GremlinParser.RBRACK, 0)

        def genericLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GremlinParser.GenericLiteralContext)
            else:
                return self.getTypedRuleContext(GremlinParser.GenericLiteralContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GremlinParser.COMMA)
            else:
                return self.getToken(GremlinParser.COMMA, i)

        def getRuleIndex(self):
            return GremlinParser.RULE_genericLiteralMap

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericLiteralMap" ):
                listener.enterGenericLiteralMap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericLiteralMap" ):
                listener.exitGenericLiteralMap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericLiteralMap" ):
                return visitor.visitGenericLiteralMap(self)
            else:
                return visitor.visitChildren(self)




    def genericLiteralMap(self):

        localctx = GremlinParser.GenericLiteralMapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 430, self.RULE_genericLiteralMap)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2414
            self.match(GremlinParser.LBRACK)
            self.state = 2416
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GremlinParser.T__9) | (1 << GremlinParser.T__10) | (1 << GremlinParser.T__11) | (1 << GremlinParser.T__13) | (1 << GremlinParser.T__14) | (1 << GremlinParser.T__16) | (1 << GremlinParser.T__17) | (1 << GremlinParser.T__18) | (1 << GremlinParser.T__19) | (1 << GremlinParser.T__20) | (1 << GremlinParser.T__21) | (1 << GremlinParser.T__22) | (1 << GremlinParser.T__23) | (1 << GremlinParser.T__24) | (1 << GremlinParser.T__25) | (1 << GremlinParser.T__26) | (1 << GremlinParser.T__27) | (1 << GremlinParser.T__28) | (1 << GremlinParser.T__29) | (1 << GremlinParser.T__30) | (1 << GremlinParser.T__31) | (1 << GremlinParser.T__32) | (1 << GremlinParser.T__33) | (1 << GremlinParser.T__34) | (1 << GremlinParser.T__35) | (1 << GremlinParser.T__36) | (1 << GremlinParser.T__37) | (1 << GremlinParser.T__38) | (1 << GremlinParser.T__39) | (1 << GremlinParser.T__40) | (1 << GremlinParser.T__41) | (1 << GremlinParser.T__42) | (1 << GremlinParser.T__43) | (1 << GremlinParser.T__44) | (1 << GremlinParser.T__45) | (1 << GremlinParser.T__46) | (1 << GremlinParser.T__47) | (1 << GremlinParser.T__48) | (1 << GremlinParser.T__49) | (1 << GremlinParser.T__50) | (1 << GremlinParser.T__51) | (1 << GremlinParser.T__52) | (1 << GremlinParser.T__53) | (1 << GremlinParser.T__54) | (1 << GremlinParser.T__55) | (1 << GremlinParser.T__56) | (1 << GremlinParser.T__57) | (1 << GremlinParser.T__58) | (1 << GremlinParser.T__59) | (1 << GremlinParser.T__60) | (1 << GremlinParser.T__61) | (1 << GremlinParser.T__62))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (GremlinParser.T__63 - 64)) | (1 << (GremlinParser.T__64 - 64)) | (1 << (GremlinParser.T__65 - 64)) | (1 << (GremlinParser.T__66 - 64)) | (1 << (GremlinParser.T__67 - 64)) | (1 << (GremlinParser.T__68 - 64)) | (1 << (GremlinParser.T__69 - 64)) | (1 << (GremlinParser.T__70 - 64)) | (1 << (GremlinParser.T__71 - 64)) | (1 << (GremlinParser.T__72 - 64)) | (1 << (GremlinParser.T__73 - 64)) | (1 << (GremlinParser.T__74 - 64)) | (1 << (GremlinParser.T__75 - 64)) | (1 << (GremlinParser.T__76 - 64)) | (1 << (GremlinParser.T__77 - 64)) | (1 << (GremlinParser.T__78 - 64)) | (1 << (GremlinParser.T__79 - 64)) | (1 << (GremlinParser.T__80 - 64)) | (1 << (GremlinParser.T__81 - 64)) | (1 << (GremlinParser.T__82 - 64)) | (1 << (GremlinParser.T__83 - 64)) | (1 << (GremlinParser.T__84 - 64)) | (1 << (GremlinParser.T__85 - 64)) | (1 << (GremlinParser.T__86 - 64)) | (1 << (GremlinParser.T__87 - 64)) | (1 << (GremlinParser.T__88 - 64)) | (1 << (GremlinParser.T__89 - 64)) | (1 << (GremlinParser.T__90 - 64)) | (1 << (GremlinParser.T__91 - 64)) | (1 << (GremlinParser.T__92 - 64)) | (1 << (GremlinParser.T__93 - 64)) | (1 << (GremlinParser.T__94 - 64)) | (1 << (GremlinParser.T__95 - 64)) | (1 << (GremlinParser.T__96 - 64)) | (1 << (GremlinParser.T__97 - 64)) | (1 << (GremlinParser.T__98 - 64)) | (1 << (GremlinParser.T__99 - 64)) | (1 << (GremlinParser.T__100 - 64)) | (1 << (GremlinParser.T__101 - 64)) | (1 << (GremlinParser.T__102 - 64)) | (1 << (GremlinParser.T__103 - 64)) | (1 << (GremlinParser.T__104 - 64)) | (1 << (GremlinParser.T__105 - 64)) | (1 << (GremlinParser.T__106 - 64)) | (1 << (GremlinParser.T__107 - 64)) | (1 << (GremlinParser.T__108 - 64)) | (1 << (GremlinParser.T__109 - 64)) | (1 << (GremlinParser.T__110 - 64)) | (1 << (GremlinParser.T__111 - 64)))) != 0) or ((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & ((1 << (GremlinParser.T__132 - 133)) | (1 << (GremlinParser.T__133 - 133)) | (1 << (GremlinParser.T__134 - 133)) | (1 << (GremlinParser.T__135 - 133)) | (1 << (GremlinParser.T__146 - 133)) | (1 << (GremlinParser.T__147 - 133)) | (1 << (GremlinParser.T__148 - 133)) | (1 << (GremlinParser.T__149 - 133)) | (1 << (GremlinParser.T__150 - 133)) | (1 << (GremlinParser.T__151 - 133)) | (1 << (GremlinParser.T__152 - 133)) | (1 << (GremlinParser.T__153 - 133)) | (1 << (GremlinParser.T__154 - 133)) | (1 << (GremlinParser.T__155 - 133)) | (1 << (GremlinParser.T__156 - 133)) | (1 << (GremlinParser.T__157 - 133)) | (1 << (GremlinParser.T__185 - 133)) | (1 << (GremlinParser.T__186 - 133)) | (1 << (GremlinParser.T__187 - 133)) | (1 << (GremlinParser.T__188 - 133)))) != 0) or ((((_la - 245)) & ~0x3f) == 0 and ((1 << (_la - 245)) & ((1 << (GremlinParser.T__244 - 245)) | (1 << (GremlinParser.T__245 - 245)) | (1 << (GremlinParser.T__246 - 245)) | (1 << (GremlinParser.T__247 - 245)) | (1 << (GremlinParser.T__248 - 245)) | (1 << (GremlinParser.IntegerLiteral - 245)) | (1 << (GremlinParser.FloatingPointLiteral - 245)) | (1 << (GremlinParser.BooleanLiteral - 245)) | (1 << (GremlinParser.NullLiteral - 245)) | (1 << (GremlinParser.NonEmptyStringLiteral - 245)) | (1 << (GremlinParser.EmptyStringLiteral - 245)) | (1 << (GremlinParser.LBRACK - 245)) | (1 << (GremlinParser.TRAVERSAL_ROOT - 245)) | (1 << (GremlinParser.ANON_TRAVERSAL_ROOT - 245)))) != 0):
                self.state = 2415
                self.genericLiteral()


            self.state = 2418
            self.match(GremlinParser.COLON)
            self.state = 2420
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GremlinParser.T__9) | (1 << GremlinParser.T__10) | (1 << GremlinParser.T__11) | (1 << GremlinParser.T__13) | (1 << GremlinParser.T__14) | (1 << GremlinParser.T__16) | (1 << GremlinParser.T__17) | (1 << GremlinParser.T__18) | (1 << GremlinParser.T__19) | (1 << GremlinParser.T__20) | (1 << GremlinParser.T__21) | (1 << GremlinParser.T__22) | (1 << GremlinParser.T__23) | (1 << GremlinParser.T__24) | (1 << GremlinParser.T__25) | (1 << GremlinParser.T__26) | (1 << GremlinParser.T__27) | (1 << GremlinParser.T__28) | (1 << GremlinParser.T__29) | (1 << GremlinParser.T__30) | (1 << GremlinParser.T__31) | (1 << GremlinParser.T__32) | (1 << GremlinParser.T__33) | (1 << GremlinParser.T__34) | (1 << GremlinParser.T__35) | (1 << GremlinParser.T__36) | (1 << GremlinParser.T__37) | (1 << GremlinParser.T__38) | (1 << GremlinParser.T__39) | (1 << GremlinParser.T__40) | (1 << GremlinParser.T__41) | (1 << GremlinParser.T__42) | (1 << GremlinParser.T__43) | (1 << GremlinParser.T__44) | (1 << GremlinParser.T__45) | (1 << GremlinParser.T__46) | (1 << GremlinParser.T__47) | (1 << GremlinParser.T__48) | (1 << GremlinParser.T__49) | (1 << GremlinParser.T__50) | (1 << GremlinParser.T__51) | (1 << GremlinParser.T__52) | (1 << GremlinParser.T__53) | (1 << GremlinParser.T__54) | (1 << GremlinParser.T__55) | (1 << GremlinParser.T__56) | (1 << GremlinParser.T__57) | (1 << GremlinParser.T__58) | (1 << GremlinParser.T__59) | (1 << GremlinParser.T__60) | (1 << GremlinParser.T__61) | (1 << GremlinParser.T__62))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (GremlinParser.T__63 - 64)) | (1 << (GremlinParser.T__64 - 64)) | (1 << (GremlinParser.T__65 - 64)) | (1 << (GremlinParser.T__66 - 64)) | (1 << (GremlinParser.T__67 - 64)) | (1 << (GremlinParser.T__68 - 64)) | (1 << (GremlinParser.T__69 - 64)) | (1 << (GremlinParser.T__70 - 64)) | (1 << (GremlinParser.T__71 - 64)) | (1 << (GremlinParser.T__72 - 64)) | (1 << (GremlinParser.T__73 - 64)) | (1 << (GremlinParser.T__74 - 64)) | (1 << (GremlinParser.T__75 - 64)) | (1 << (GremlinParser.T__76 - 64)) | (1 << (GremlinParser.T__77 - 64)) | (1 << (GremlinParser.T__78 - 64)) | (1 << (GremlinParser.T__79 - 64)) | (1 << (GremlinParser.T__80 - 64)) | (1 << (GremlinParser.T__81 - 64)) | (1 << (GremlinParser.T__82 - 64)) | (1 << (GremlinParser.T__83 - 64)) | (1 << (GremlinParser.T__84 - 64)) | (1 << (GremlinParser.T__85 - 64)) | (1 << (GremlinParser.T__86 - 64)) | (1 << (GremlinParser.T__87 - 64)) | (1 << (GremlinParser.T__88 - 64)) | (1 << (GremlinParser.T__89 - 64)) | (1 << (GremlinParser.T__90 - 64)) | (1 << (GremlinParser.T__91 - 64)) | (1 << (GremlinParser.T__92 - 64)) | (1 << (GremlinParser.T__93 - 64)) | (1 << (GremlinParser.T__94 - 64)) | (1 << (GremlinParser.T__95 - 64)) | (1 << (GremlinParser.T__96 - 64)) | (1 << (GremlinParser.T__97 - 64)) | (1 << (GremlinParser.T__98 - 64)) | (1 << (GremlinParser.T__99 - 64)) | (1 << (GremlinParser.T__100 - 64)) | (1 << (GremlinParser.T__101 - 64)) | (1 << (GremlinParser.T__102 - 64)) | (1 << (GremlinParser.T__103 - 64)) | (1 << (GremlinParser.T__104 - 64)) | (1 << (GremlinParser.T__105 - 64)) | (1 << (GremlinParser.T__106 - 64)) | (1 << (GremlinParser.T__107 - 64)) | (1 << (GremlinParser.T__108 - 64)) | (1 << (GremlinParser.T__109 - 64)) | (1 << (GremlinParser.T__110 - 64)) | (1 << (GremlinParser.T__111 - 64)))) != 0) or ((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & ((1 << (GremlinParser.T__132 - 133)) | (1 << (GremlinParser.T__133 - 133)) | (1 << (GremlinParser.T__134 - 133)) | (1 << (GremlinParser.T__135 - 133)) | (1 << (GremlinParser.T__146 - 133)) | (1 << (GremlinParser.T__147 - 133)) | (1 << (GremlinParser.T__148 - 133)) | (1 << (GremlinParser.T__149 - 133)) | (1 << (GremlinParser.T__150 - 133)) | (1 << (GremlinParser.T__151 - 133)) | (1 << (GremlinParser.T__152 - 133)) | (1 << (GremlinParser.T__153 - 133)) | (1 << (GremlinParser.T__154 - 133)) | (1 << (GremlinParser.T__155 - 133)) | (1 << (GremlinParser.T__156 - 133)) | (1 << (GremlinParser.T__157 - 133)) | (1 << (GremlinParser.T__185 - 133)) | (1 << (GremlinParser.T__186 - 133)) | (1 << (GremlinParser.T__187 - 133)) | (1 << (GremlinParser.T__188 - 133)))) != 0) or ((((_la - 245)) & ~0x3f) == 0 and ((1 << (_la - 245)) & ((1 << (GremlinParser.T__244 - 245)) | (1 << (GremlinParser.T__245 - 245)) | (1 << (GremlinParser.T__246 - 245)) | (1 << (GremlinParser.T__247 - 245)) | (1 << (GremlinParser.T__248 - 245)) | (1 << (GremlinParser.IntegerLiteral - 245)) | (1 << (GremlinParser.FloatingPointLiteral - 245)) | (1 << (GremlinParser.BooleanLiteral - 245)) | (1 << (GremlinParser.NullLiteral - 245)) | (1 << (GremlinParser.NonEmptyStringLiteral - 245)) | (1 << (GremlinParser.EmptyStringLiteral - 245)) | (1 << (GremlinParser.LBRACK - 245)) | (1 << (GremlinParser.TRAVERSAL_ROOT - 245)) | (1 << (GremlinParser.ANON_TRAVERSAL_ROOT - 245)))) != 0):
                self.state = 2419
                self.genericLiteral()


            self.state = 2432
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GremlinParser.COMMA:
                self.state = 2422
                self.match(GremlinParser.COMMA)
                self.state = 2424
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GremlinParser.T__9) | (1 << GremlinParser.T__10) | (1 << GremlinParser.T__11) | (1 << GremlinParser.T__13) | (1 << GremlinParser.T__14) | (1 << GremlinParser.T__16) | (1 << GremlinParser.T__17) | (1 << GremlinParser.T__18) | (1 << GremlinParser.T__19) | (1 << GremlinParser.T__20) | (1 << GremlinParser.T__21) | (1 << GremlinParser.T__22) | (1 << GremlinParser.T__23) | (1 << GremlinParser.T__24) | (1 << GremlinParser.T__25) | (1 << GremlinParser.T__26) | (1 << GremlinParser.T__27) | (1 << GremlinParser.T__28) | (1 << GremlinParser.T__29) | (1 << GremlinParser.T__30) | (1 << GremlinParser.T__31) | (1 << GremlinParser.T__32) | (1 << GremlinParser.T__33) | (1 << GremlinParser.T__34) | (1 << GremlinParser.T__35) | (1 << GremlinParser.T__36) | (1 << GremlinParser.T__37) | (1 << GremlinParser.T__38) | (1 << GremlinParser.T__39) | (1 << GremlinParser.T__40) | (1 << GremlinParser.T__41) | (1 << GremlinParser.T__42) | (1 << GremlinParser.T__43) | (1 << GremlinParser.T__44) | (1 << GremlinParser.T__45) | (1 << GremlinParser.T__46) | (1 << GremlinParser.T__47) | (1 << GremlinParser.T__48) | (1 << GremlinParser.T__49) | (1 << GremlinParser.T__50) | (1 << GremlinParser.T__51) | (1 << GremlinParser.T__52) | (1 << GremlinParser.T__53) | (1 << GremlinParser.T__54) | (1 << GremlinParser.T__55) | (1 << GremlinParser.T__56) | (1 << GremlinParser.T__57) | (1 << GremlinParser.T__58) | (1 << GremlinParser.T__59) | (1 << GremlinParser.T__60) | (1 << GremlinParser.T__61) | (1 << GremlinParser.T__62))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (GremlinParser.T__63 - 64)) | (1 << (GremlinParser.T__64 - 64)) | (1 << (GremlinParser.T__65 - 64)) | (1 << (GremlinParser.T__66 - 64)) | (1 << (GremlinParser.T__67 - 64)) | (1 << (GremlinParser.T__68 - 64)) | (1 << (GremlinParser.T__69 - 64)) | (1 << (GremlinParser.T__70 - 64)) | (1 << (GremlinParser.T__71 - 64)) | (1 << (GremlinParser.T__72 - 64)) | (1 << (GremlinParser.T__73 - 64)) | (1 << (GremlinParser.T__74 - 64)) | (1 << (GremlinParser.T__75 - 64)) | (1 << (GremlinParser.T__76 - 64)) | (1 << (GremlinParser.T__77 - 64)) | (1 << (GremlinParser.T__78 - 64)) | (1 << (GremlinParser.T__79 - 64)) | (1 << (GremlinParser.T__80 - 64)) | (1 << (GremlinParser.T__81 - 64)) | (1 << (GremlinParser.T__82 - 64)) | (1 << (GremlinParser.T__83 - 64)) | (1 << (GremlinParser.T__84 - 64)) | (1 << (GremlinParser.T__85 - 64)) | (1 << (GremlinParser.T__86 - 64)) | (1 << (GremlinParser.T__87 - 64)) | (1 << (GremlinParser.T__88 - 64)) | (1 << (GremlinParser.T__89 - 64)) | (1 << (GremlinParser.T__90 - 64)) | (1 << (GremlinParser.T__91 - 64)) | (1 << (GremlinParser.T__92 - 64)) | (1 << (GremlinParser.T__93 - 64)) | (1 << (GremlinParser.T__94 - 64)) | (1 << (GremlinParser.T__95 - 64)) | (1 << (GremlinParser.T__96 - 64)) | (1 << (GremlinParser.T__97 - 64)) | (1 << (GremlinParser.T__98 - 64)) | (1 << (GremlinParser.T__99 - 64)) | (1 << (GremlinParser.T__100 - 64)) | (1 << (GremlinParser.T__101 - 64)) | (1 << (GremlinParser.T__102 - 64)) | (1 << (GremlinParser.T__103 - 64)) | (1 << (GremlinParser.T__104 - 64)) | (1 << (GremlinParser.T__105 - 64)) | (1 << (GremlinParser.T__106 - 64)) | (1 << (GremlinParser.T__107 - 64)) | (1 << (GremlinParser.T__108 - 64)) | (1 << (GremlinParser.T__109 - 64)) | (1 << (GremlinParser.T__110 - 64)) | (1 << (GremlinParser.T__111 - 64)))) != 0) or ((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & ((1 << (GremlinParser.T__132 - 133)) | (1 << (GremlinParser.T__133 - 133)) | (1 << (GremlinParser.T__134 - 133)) | (1 << (GremlinParser.T__135 - 133)) | (1 << (GremlinParser.T__146 - 133)) | (1 << (GremlinParser.T__147 - 133)) | (1 << (GremlinParser.T__148 - 133)) | (1 << (GremlinParser.T__149 - 133)) | (1 << (GremlinParser.T__150 - 133)) | (1 << (GremlinParser.T__151 - 133)) | (1 << (GremlinParser.T__152 - 133)) | (1 << (GremlinParser.T__153 - 133)) | (1 << (GremlinParser.T__154 - 133)) | (1 << (GremlinParser.T__155 - 133)) | (1 << (GremlinParser.T__156 - 133)) | (1 << (GremlinParser.T__157 - 133)) | (1 << (GremlinParser.T__185 - 133)) | (1 << (GremlinParser.T__186 - 133)) | (1 << (GremlinParser.T__187 - 133)) | (1 << (GremlinParser.T__188 - 133)))) != 0) or ((((_la - 245)) & ~0x3f) == 0 and ((1 << (_la - 245)) & ((1 << (GremlinParser.T__244 - 245)) | (1 << (GremlinParser.T__245 - 245)) | (1 << (GremlinParser.T__246 - 245)) | (1 << (GremlinParser.T__247 - 245)) | (1 << (GremlinParser.T__248 - 245)) | (1 << (GremlinParser.IntegerLiteral - 245)) | (1 << (GremlinParser.FloatingPointLiteral - 245)) | (1 << (GremlinParser.BooleanLiteral - 245)) | (1 << (GremlinParser.NullLiteral - 245)) | (1 << (GremlinParser.NonEmptyStringLiteral - 245)) | (1 << (GremlinParser.EmptyStringLiteral - 245)) | (1 << (GremlinParser.LBRACK - 245)) | (1 << (GremlinParser.TRAVERSAL_ROOT - 245)) | (1 << (GremlinParser.ANON_TRAVERSAL_ROOT - 245)))) != 0):
                    self.state = 2423
                    self.genericLiteral()


                self.state = 2426
                self.match(GremlinParser.COLON)
                self.state = 2428
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GremlinParser.T__9) | (1 << GremlinParser.T__10) | (1 << GremlinParser.T__11) | (1 << GremlinParser.T__13) | (1 << GremlinParser.T__14) | (1 << GremlinParser.T__16) | (1 << GremlinParser.T__17) | (1 << GremlinParser.T__18) | (1 << GremlinParser.T__19) | (1 << GremlinParser.T__20) | (1 << GremlinParser.T__21) | (1 << GremlinParser.T__22) | (1 << GremlinParser.T__23) | (1 << GremlinParser.T__24) | (1 << GremlinParser.T__25) | (1 << GremlinParser.T__26) | (1 << GremlinParser.T__27) | (1 << GremlinParser.T__28) | (1 << GremlinParser.T__29) | (1 << GremlinParser.T__30) | (1 << GremlinParser.T__31) | (1 << GremlinParser.T__32) | (1 << GremlinParser.T__33) | (1 << GremlinParser.T__34) | (1 << GremlinParser.T__35) | (1 << GremlinParser.T__36) | (1 << GremlinParser.T__37) | (1 << GremlinParser.T__38) | (1 << GremlinParser.T__39) | (1 << GremlinParser.T__40) | (1 << GremlinParser.T__41) | (1 << GremlinParser.T__42) | (1 << GremlinParser.T__43) | (1 << GremlinParser.T__44) | (1 << GremlinParser.T__45) | (1 << GremlinParser.T__46) | (1 << GremlinParser.T__47) | (1 << GremlinParser.T__48) | (1 << GremlinParser.T__49) | (1 << GremlinParser.T__50) | (1 << GremlinParser.T__51) | (1 << GremlinParser.T__52) | (1 << GremlinParser.T__53) | (1 << GremlinParser.T__54) | (1 << GremlinParser.T__55) | (1 << GremlinParser.T__56) | (1 << GremlinParser.T__57) | (1 << GremlinParser.T__58) | (1 << GremlinParser.T__59) | (1 << GremlinParser.T__60) | (1 << GremlinParser.T__61) | (1 << GremlinParser.T__62))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (GremlinParser.T__63 - 64)) | (1 << (GremlinParser.T__64 - 64)) | (1 << (GremlinParser.T__65 - 64)) | (1 << (GremlinParser.T__66 - 64)) | (1 << (GremlinParser.T__67 - 64)) | (1 << (GremlinParser.T__68 - 64)) | (1 << (GremlinParser.T__69 - 64)) | (1 << (GremlinParser.T__70 - 64)) | (1 << (GremlinParser.T__71 - 64)) | (1 << (GremlinParser.T__72 - 64)) | (1 << (GremlinParser.T__73 - 64)) | (1 << (GremlinParser.T__74 - 64)) | (1 << (GremlinParser.T__75 - 64)) | (1 << (GremlinParser.T__76 - 64)) | (1 << (GremlinParser.T__77 - 64)) | (1 << (GremlinParser.T__78 - 64)) | (1 << (GremlinParser.T__79 - 64)) | (1 << (GremlinParser.T__80 - 64)) | (1 << (GremlinParser.T__81 - 64)) | (1 << (GremlinParser.T__82 - 64)) | (1 << (GremlinParser.T__83 - 64)) | (1 << (GremlinParser.T__84 - 64)) | (1 << (GremlinParser.T__85 - 64)) | (1 << (GremlinParser.T__86 - 64)) | (1 << (GremlinParser.T__87 - 64)) | (1 << (GremlinParser.T__88 - 64)) | (1 << (GremlinParser.T__89 - 64)) | (1 << (GremlinParser.T__90 - 64)) | (1 << (GremlinParser.T__91 - 64)) | (1 << (GremlinParser.T__92 - 64)) | (1 << (GremlinParser.T__93 - 64)) | (1 << (GremlinParser.T__94 - 64)) | (1 << (GremlinParser.T__95 - 64)) | (1 << (GremlinParser.T__96 - 64)) | (1 << (GremlinParser.T__97 - 64)) | (1 << (GremlinParser.T__98 - 64)) | (1 << (GremlinParser.T__99 - 64)) | (1 << (GremlinParser.T__100 - 64)) | (1 << (GremlinParser.T__101 - 64)) | (1 << (GremlinParser.T__102 - 64)) | (1 << (GremlinParser.T__103 - 64)) | (1 << (GremlinParser.T__104 - 64)) | (1 << (GremlinParser.T__105 - 64)) | (1 << (GremlinParser.T__106 - 64)) | (1 << (GremlinParser.T__107 - 64)) | (1 << (GremlinParser.T__108 - 64)) | (1 << (GremlinParser.T__109 - 64)) | (1 << (GremlinParser.T__110 - 64)) | (1 << (GremlinParser.T__111 - 64)))) != 0) or ((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & ((1 << (GremlinParser.T__132 - 133)) | (1 << (GremlinParser.T__133 - 133)) | (1 << (GremlinParser.T__134 - 133)) | (1 << (GremlinParser.T__135 - 133)) | (1 << (GremlinParser.T__146 - 133)) | (1 << (GremlinParser.T__147 - 133)) | (1 << (GremlinParser.T__148 - 133)) | (1 << (GremlinParser.T__149 - 133)) | (1 << (GremlinParser.T__150 - 133)) | (1 << (GremlinParser.T__151 - 133)) | (1 << (GremlinParser.T__152 - 133)) | (1 << (GremlinParser.T__153 - 133)) | (1 << (GremlinParser.T__154 - 133)) | (1 << (GremlinParser.T__155 - 133)) | (1 << (GremlinParser.T__156 - 133)) | (1 << (GremlinParser.T__157 - 133)) | (1 << (GremlinParser.T__185 - 133)) | (1 << (GremlinParser.T__186 - 133)) | (1 << (GremlinParser.T__187 - 133)) | (1 << (GremlinParser.T__188 - 133)))) != 0) or ((((_la - 245)) & ~0x3f) == 0 and ((1 << (_la - 245)) & ((1 << (GremlinParser.T__244 - 245)) | (1 << (GremlinParser.T__245 - 245)) | (1 << (GremlinParser.T__246 - 245)) | (1 << (GremlinParser.T__247 - 245)) | (1 << (GremlinParser.T__248 - 245)) | (1 << (GremlinParser.IntegerLiteral - 245)) | (1 << (GremlinParser.FloatingPointLiteral - 245)) | (1 << (GremlinParser.BooleanLiteral - 245)) | (1 << (GremlinParser.NullLiteral - 245)) | (1 << (GremlinParser.NonEmptyStringLiteral - 245)) | (1 << (GremlinParser.EmptyStringLiteral - 245)) | (1 << (GremlinParser.LBRACK - 245)) | (1 << (GremlinParser.TRAVERSAL_ROOT - 245)) | (1 << (GremlinParser.ANON_TRAVERSAL_ROOT - 245)))) != 0):
                    self.state = 2427
                    self.genericLiteral()


                self.state = 2434
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2435
            self.match(GremlinParser.RBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IntegerLiteral(self):
            return self.getToken(GremlinParser.IntegerLiteral, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_integerLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerLiteral" ):
                listener.enterIntegerLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerLiteral" ):
                listener.exitIntegerLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerLiteral" ):
                return visitor.visitIntegerLiteral(self)
            else:
                return visitor.visitChildren(self)




    def integerLiteral(self):

        localctx = GremlinParser.IntegerLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 432, self.RULE_integerLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2437
            self.match(GremlinParser.IntegerLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FloatLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FloatingPointLiteral(self):
            return self.getToken(GremlinParser.FloatingPointLiteral, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_floatLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloatLiteral" ):
                listener.enterFloatLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloatLiteral" ):
                listener.exitFloatLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFloatLiteral" ):
                return visitor.visitFloatLiteral(self)
            else:
                return visitor.visitChildren(self)




    def floatLiteral(self):

        localctx = GremlinParser.FloatLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 434, self.RULE_floatLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2439
            self.match(GremlinParser.FloatingPointLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BooleanLiteral(self):
            return self.getToken(GremlinParser.BooleanLiteral, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_booleanLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanLiteral" ):
                listener.enterBooleanLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanLiteral" ):
                listener.exitBooleanLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanLiteral" ):
                return visitor.visitBooleanLiteral(self)
            else:
                return visitor.visitChildren(self)




    def booleanLiteral(self):

        localctx = GremlinParser.BooleanLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 436, self.RULE_booleanLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2441
            self.match(GremlinParser.BooleanLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NonEmptyStringLiteral(self):
            return self.getToken(GremlinParser.NonEmptyStringLiteral, 0)

        def EmptyStringLiteral(self):
            return self.getToken(GremlinParser.EmptyStringLiteral, 0)

        def gremlinStringConstants(self):
            return self.getTypedRuleContext(GremlinParser.GremlinStringConstantsContext,0)


        def getRuleIndex(self):
            return GremlinParser.RULE_stringLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteral" ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteral" ):
                listener.exitStringLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteral" ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)




    def stringLiteral(self):

        localctx = GremlinParser.StringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 438, self.RULE_stringLiteral)
        try:
            self.state = 2446
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GremlinParser.NonEmptyStringLiteral]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2443
                self.match(GremlinParser.NonEmptyStringLiteral)
                pass
            elif token in [GremlinParser.EmptyStringLiteral]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2444
                self.match(GremlinParser.EmptyStringLiteral)
                pass
            elif token in [GremlinParser.T__244, GremlinParser.T__245, GremlinParser.T__246, GremlinParser.T__247]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2445
                self.gremlinStringConstants()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(GremlinParser.LPAREN, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(GremlinParser.StringLiteralContext,0)


        def RPAREN(self):
            return self.getToken(GremlinParser.RPAREN, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_dateLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateLiteral" ):
                listener.enterDateLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateLiteral" ):
                listener.exitDateLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateLiteral" ):
                return visitor.visitDateLiteral(self)
            else:
                return visitor.visitChildren(self)




    def dateLiteral(self):

        localctx = GremlinParser.DateLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 440, self.RULE_dateLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2448
            self.match(GremlinParser.T__248)
            self.state = 2449
            self.match(GremlinParser.LPAREN)
            self.state = 2450
            self.stringLiteral()
            self.state = 2451
            self.match(GremlinParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NullLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NullLiteral(self):
            return self.getToken(GremlinParser.NullLiteral, 0)

        def getRuleIndex(self):
            return GremlinParser.RULE_nullLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullLiteral" ):
                listener.enterNullLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullLiteral" ):
                listener.exitNullLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNullLiteral" ):
                return visitor.visitNullLiteral(self)
            else:
                return visitor.visitChildren(self)




    def nullLiteral(self):

        localctx = GremlinParser.NullLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 442, self.RULE_nullLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2453
            self.match(GremlinParser.NullLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[1] = self.query_sempred
        self._predicates[3] = self.traversalSource_sempred
        self._predicates[20] = self.chainedTraversal_sempred
        self._predicates[21] = self.chainedParentOfGraphTraversal_sempred
        self._predicates[140] = self.traversalPredicate_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def query_sempred(self, localctx:QueryContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def traversalSource_sempred(self, localctx:TraversalSourceContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         

    def chainedTraversal_sempred(self, localctx:ChainedTraversalContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 1)
         

    def chainedParentOfGraphTraversal_sempred(self, localctx:ChainedParentOfGraphTraversalContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 1)
         

    def traversalPredicate_sempred(self, localctx:TraversalPredicateContext, predIndex:int):
            if predIndex == 5:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 1)
         




